<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>每日记录</title>
    <url>/2020/11/29/daily/</url>
    <content><![CDATA[<h1 id="用-Hexo-搭建了个人-blog"><a href="#用-Hexo-搭建了个人-blog" class="headerlink" title="用 Hexo 搭建了个人 blog"></a>用 Hexo 搭建了个人 blog</h1><h2 id="Hexo-基本操作"><a href="#Hexo-基本操作" class="headerlink" title="Hexo 基本操作"></a>Hexo 基本操作</h2><ul>
<li><p>安装</p>
<p>  <code>npm install -g hexo-cli</code></p>
</li>
<li><p>初始化hexo</p>
<p>  <code>hexo init</code></p>
<ul>
<li>当前目录必须是空的</li>
</ul>
</li>
<li><p>新建文章</p>
<p>  <code>hexo new [layout] name</code></p>
<ul>
<li><p>layout 可以是 post, page, draft 之一</p>
</li>
<li><p>分别保存至 source/_posts, source, source/_drafts 中</p>
</li>
<li><p>新建文件名可以在 _config.yml 里面指定, <code>new_post_name</code>, 默认为 <code>name.md</code></p>
</li>
</ul>
</li>
<li><p>临时开启 server</p>
<p>  <code>hexo server</code></p>
</li>
</ul>
<h1 id="React-入门"><a href="#React-入门" class="headerlink" title="React 入门"></a>React 入门</h1><h2 id="复习-JavaScript"><a href="#复习-JavaScript" class="headerlink" title="复习 JavaScript"></a>复习 JavaScript</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript">很好的文章</a></li>
</ul>
<h1 id="Vue-和-React-路由模块的区别"><a href="#Vue-和-React-路由模块的区别" class="headerlink" title="Vue 和 React 路由模块的区别"></a>Vue 和 React 路由模块的区别</h1><h2 id="Vue-路由"><a href="#Vue-路由" class="headerlink" title="Vue 路由"></a>Vue 路由</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes: [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/inspect&#x27;</span>,</span><br><span class="line">        component: Layout,</span><br><span class="line">        redirect: <span class="string">&#x27;/inspect/table1&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;报表&#x27;</span>,</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;报表&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;table&#x27;</span> &#125;,</span><br><span class="line">        children: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;table1&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;Table&#x27;</span>,</span><br><span class="line">            component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/table/index&#x27;</span>),</span><br><span class="line">            meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;Table&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;table&#x27;</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Vue-深入-——-MVVM-框架"><a href="#Vue-深入-——-MVVM-框架" class="headerlink" title="Vue 深入 —— MVVM 框架"></a>Vue 深入 —— MVVM 框架</h1><ul>
<li><p>Observer 数据劫持</p>
</li>
<li><p>Dep/Watcher 发布订阅</p>
</li>
<li><p>Compiler 解析 <code>&#123;&#123; &#125;&#125;</code>, 创建watcher, 求解表达式</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>每日记录</title>
    <url>/2020/11/30/daily/</url>
    <content><![CDATA[<h1 id="Github-Developer-Settings"><a href="#Github-Developer-Settings" class="headerlink" title="Github Developer Settings"></a>Github Developer Settings</h1><ul>
<li><p>GitHub Apps</p>
</li>
<li><p>OAuth Apps</p>
<ul>
<li>需要用到Github API的App</li>
</ul>
</li>
<li><p>Personal access tokens</p>
<ul>
<li><p>Tokens you have generated that can be used to access the GitHub API. </p>
</li>
<li><p>权限类似于账号+密码登录</p>
</li>
</ul>
</li>
</ul>
<h1 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h1><ul>
<li><p>类似Travis-CI的持续集成平台</p>
</li>
<li><p>使用方法</p>
<ul>
<li><p>在项目根目录创建 .github/workflows</p>
</li>
<li><p>继续创建 pages.yml</p>
</li>
<li><p>关键字: jobs, runs-on, steps, name, uses, with等等</p>
</li>
</ul>
</li>
</ul>
<h1 id="Hexo博客评论系统"><a href="#Hexo博客评论系统" class="headerlink" title="Hexo博客评论系统"></a>Hexo博客评论系统</h1><ul>
<li><p>Gitalk</p>
<ul>
<li><p>利用Github Issues功能实现的评论系统, 开源</p>
</li>
<li><p>不支持回复评论</p>
</li>
<li><p>修改评论需要打开对应的Issue页修改</p>
</li>
<li><p>登录需要的Github权限太高(Github自身问题)</p>
</li>
</ul>
</li>
<li><p>Disqus</p>
<ul>
<li><p>界面好看</p>
</li>
<li><p>需要翻墙才能正常使用</p>
</li>
</ul>
</li>
</ul>
<h1 id="Code-Server"><a href="#Code-Server" class="headerlink" title="Code-Server"></a>Code-Server</h1><ul>
<li>浏览器端的vscode</li>
</ul>
]]></content>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>每日记录</title>
    <url>/2020/12/01/daily/</url>
    <content><![CDATA[<h1 id="转换dos格式行尾为unix行尾"><a href="#转换dos格式行尾为unix行尾" class="headerlink" title="转换dos格式行尾为unix行尾"></a>转换dos格式行尾为unix行尾</h1><ul>
<li><p>工具: dos2unix</p>
</li>
<li><p>单文件: <code>dos2unix input output</code></p>
</li>
<li><p>递归转换: <code>find . -type f -print0 | xargs -0 dos2unix</code></p>
</li>
</ul>
<h1 id="Linux下-nodejs-环境配置"><a href="#Linux下-nodejs-环境配置" class="headerlink" title="Linux下 nodejs 环境配置"></a>Linux下 nodejs 环境配置</h1><ul>
<li><p>安装node(不是最新版): <code>sudo apt install nodejs</code></p>
</li>
<li><p>使用<code>n</code>来切换node版本: </p>
<ul>
<li><p><code>sudo npm install -g n</code></p>
</li>
<li><p><code>sudo n stable</code></p>
</li>
</ul>
</li>
<li><p>安装yarn: <code>sudo npm install -g yarn</code></p>
</li>
</ul>
<h1 id="Nodejs版本切换"><a href="#Nodejs版本切换" class="headerlink" title="Nodejs版本切换"></a>Nodejs版本切换</h1><ul>
<li><p>使用<code>n</code></p>
<ul>
<li><p>方法:</p>
<ul>
<li><p>安装: <code>sudo npm install -g n</code></p>
</li>
<li><p>切换版本: <code>sudo n stable</code></p>
</li>
</ul>
</li>
<li><p>缺点: 据说会导致node modules混乱</p>
</li>
</ul>
</li>
<li><p>使用<code>nvm</code></p>
</li>
</ul>
<h1 id="清理npm缓存"><a href="#清理npm缓存" class="headerlink" title="清理npm缓存"></a>清理npm缓存</h1><ul>
<li><p><code>npm cache clean --force</code></p>
</li>
<li><p>The default cache direconstructory is ~/.npm on Posix (mac or linux), or %AppData%/npm-cache on Windows.</p>
</li>
</ul>
<h1 id="Javascript-复习"><a href="#Javascript-复习" class="headerlink" title="Javascript 复习"></a>Javascript 复习</h1><ul>
<li><p>数据类型</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Symbol (new in ES2015)</li>
<li>Object<ul>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
</ul>
</li>
<li>null</li>
<li>undefined</li>
</ul>
</li>
<li><p>关于变量</p>
<ul>
<li><p>用<code>var</code>定义的变量具有<strong>函数</strong>作用域</p>
<ul>
<li><p>name hiding: <code>(function () &#123; ... &#125;)();</code></p>
</li>
<li><p>允许递归版(IIFEs): <code>(function foo() &#123; ...foo()... &#125;)();</code></p>
</li>
</ul>
</li>
<li><p>尽量使用<code>let</code>和<code>const</code></p>
</li>
</ul>
</li>
<li><p>关于Array:</p>
<ul>
<li><p>相当于一个下标是整数, 有一个length属性, 外表看起来像是数组的Object</p>
</li>
<li><p>数组的length属性是数组中最大的下标+1</p>
</li>
<li><p>当然作为Object, 也可以有非整数类型的下标</p>
</li>
<li><p>for…in…循环遍历实际存储的值, for…of…循环遍历下标</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = []</span><br><span class="line"></span><br><span class="line">a[<span class="number">100</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> a) <span class="built_in">console</span>.log(i) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> a) <span class="built_in">console</span>.log(i) <span class="comment">// undefined, undefined, ... , 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>关于String</p>
<ul>
<li><p>String + any = String</p>
</li>
<li><p>any + String = String</p>
</li>
<li><p>注意结合性</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="string">&#x27;3&#x27;</span> <span class="comment">// &#x27;33&#x27;</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">2</span> + <span class="number">3</span> <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>关于Object:</p>
<ul>
<li><p>对象字面量<code>&#123;&#125;</code>等效于<code>new Object()</code></p>
<ul>
<li><p>不过<code>Object()</code>可以被重载</p>
</li>
<li><p>对象字面量不能被重载</p>
</li>
</ul>
</li>
<li><p><code>new XXX()</code>: 相当于创建了一个类实例(实际上是个Object), <code>XXX()</code>函数可以对其进行进一步修饰</p>
</li>
</ul>
</li>
<li><p>关于<code>function</code>:</p>
<ul>
<li>函数是对象</li>
</ul>
</li>
<li><p>关于<code>new</code>:</p>
<ul>
<li><p>new的功能:</p>
<ul>
<li><p>创建一个空对象{}</p>
</li>
<li><p>设置空对象的<code>__proto__</code>(与浏览器实现有关)为构造函数的<code>prototype</code></p>
</li>
<li><p>让this指向空对象</p>
</li>
<li><p>执行构造函数, 传入参数this</p>
</li>
<li><p>如果构造函数不返回一个对象, 则返回this</p>
</li>
</ul>
</li>
<li><p>模仿一个new:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fake_new</span>(<span class="params">ctor, ...args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Object</span>.create(ctor.prototype); <span class="comment">// ES5 创建新对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">///* before ES5 */</span></span><br><span class="line">    <span class="comment">// function F() &#123;&#125;</span></span><br><span class="line">    <span class="comment">// F.prototype = ctor.prototype;</span></span><br><span class="line">    <span class="comment">// let x = new F();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = ctor.call(x, ...args); <span class="comment">//借用外部传入的构造器给obj设置属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? res : x; <span class="comment">//确保构造器总是返回一个对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>关于<code>this</code>:</p>
<ul>
<li><p>如何正确绑定this</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123; ... &#125;, <span class="comment">// bad, `this` is bound to the object</span></span><br><span class="line">    foo = <span class="function">() =&gt;</span> &#123; ... &#125;, <span class="comment">// good, `this` is bound dynamically</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Javascript面向对象:</p>
<ul>
<li><p>不用<code>new</code>模拟对象, 利用闭包</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePerson</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        first: first,</span><br><span class="line">        last: last,</span><br><span class="line">        fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.first + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.last;</span><br><span class="line">        &#125;,</span><br><span class="line">        fullNameReversed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.last + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = makePerson(<span class="string">&#x27;Simon&#x27;</span>, <span class="string">&#x27;Willison&#x27;</span>);</span><br><span class="line">s.fullName(); <span class="comment">// &quot;Simon Willison&quot;</span></span><br><span class="line">s.fullNameReversed(); <span class="comment">// &quot;Willison, Simon&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>new</code></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.first = first;</span><br><span class="line">    <span class="built_in">this</span>.last = last;</span><br><span class="line">    <span class="built_in">this</span>.fullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.first + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.last;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.fullNameReversed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.last + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.first;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Person(<span class="string">&#x27;Simon&#x27;</span>, <span class="string">&#x27;Willison&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化: 减少函数对象的拷贝, 利用原型链</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.first = first;</span><br><span class="line">    <span class="built_in">this</span>.last = last;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.fullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.first + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.last;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.fullNameReversed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.last + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="React-复习"><a href="#React-复习" class="headerlink" title="React 复习"></a>React 复习</h1><ul>
<li><p>JSX语法</p>
  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;h1 className=<span class="string">&quot;greeting&quot;</span> onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Hello, world!</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">    <span class="string">&#x27;h1&#x27;</span>, <span class="comment">// label type</span></span><br><span class="line">    &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>, <span class="attr">onClick</span>: <span class="built_in">this</span>.handleClick&#125;, <span class="comment">// attrs</span></span><br><span class="line">    <span class="string">&#x27;Hello, world!&#x27;</span> <span class="comment">// children</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>遇到<code>&lt;</code>开始解析HTML, 遇到<code>&#123;</code>开始解析Javascript</p>
</li>
<li><p>要比Vue的模板更加灵活</p>
</li>
</ul>
</li>
<li><p>数据流</p>
<ul>
<li><p>外层-&gt;内层组件: <code>props</code>, 只读</p>
</li>
<li><p>组件自己的状态: <code>state</code>, 可以修改</p>
<ul>
<li><p>初始化: 在构造函数内直接赋值</p>
</li>
<li><p>更新: 通过<code>this.setState(&#123;&#125;)</code></p>
</li>
<li><p>state可以被传递给子组件作为子组件的props</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>受控组件:</p>
<ul>
<li><p>不自己维护状态的组件</p>
</li>
<li><p>状态变化全部交给外部来做: props.value, props.onValueChanged()</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
        <tag>npm</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日记录</title>
    <url>/2020/12/02/daily/</url>
    <content><![CDATA[<ul>
<li><p>React</p>
<ul>
<li>children属性: 子元素构成的数组</li>
</ul>
</li>
<li><p>React-redux</p>
<ul>
<li><p>引入: <code>import &#123;...&#125; from &#39;react-redux&#39;</code></p>
</li>
<li><p><code>Store</code></p>
<ul>
<li><p>Redux maintains a <code>store</code>, which hold <code>state</code> and <code>reducer</code></p>
</li>
<li><p><code>createStore(reducer, initState)</code></p>
<ul>
<li><code>reducer</code> and <code>initState</code> should have the same keys</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Reducer</code>: (state, action) =&gt; (newstate)</p>
</li>
<li><p><code>&lt;Provider&gt;</code>: Inject global <code>state</code> to its children component </p>
</li>
<li><p><code>connect(mapStateToProps)(Component)</code></p>
<ul>
<li><p>map current states to <code>Component</code>‘s props</p>
</li>
<li><p><code>mapStateToProps</code>: is a function: (state) =&gt; { …someProp }</p>
</li>
<li><p>一般和<Provider>结合起来用</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>React-Router</p>
<ul>
<li><p>引入: <code>import &#123;&#125; from &#39;react-router-dom&#39;</code></p>
</li>
<li><p><code>&lt;Route path&gt;</code>: 当url与path匹配时, 渲染内容</p>
<ul>
<li><p><code>&lt;BrowserRouter&gt;, &lt;HashRouter&gt;</code>: <Route>的容器</p>
</li>
<li><p><code>&lt;Switch&gt;</code>: 保证其下的所有Route只会选中一个</p>
</li>
<li><p>参数化匹配</p>
<ul>
<li><p>参数定义: <code>path=&quot;/hsl/:h/:s/:l&quot;</code></p>
</li>
<li><p>参数获取: 在children组件中 <code>let &#123; h, s, l &#125; = useParams();</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>&lt;Link to&gt;</code>: 跳转到to的a标签</p>
<ul>
<li><code>&lt;Redirect&gt;</code>: 渲染时自动跳转</li>
</ul>
</li>
<li><p>嵌套使用: </p>
  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; path, url &#125; = useRouteMatch(); <span class="comment">// 获取上一级的path和url</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;Route path=&#123;<span class="string">`<span class="subst">$&#123;path&#125;</span>/next`</span>&#125;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Vue-Router</p>
<ul>
<li><p><code>&lt;router-link :to&gt;</code>: 跳转的a标签</p>
</li>
<li><p><code>&lt;router-view&gt;</code>: 匹配的路由内容会渲染到这里</p>
</li>
<li><p><code>Router</code>: 在这里定义全局路由表</p>
</li>
</ul>
</li>
<li><p>Ubuntu 安装 rpm 包</p>
<ul>
<li><p>sudo apt install alien</p>
</li>
<li><p>sudo alien packagename.rpm</p>
</li>
<li><p>sudo apt install ./packagename.deb</p>
</li>
<li><p>一步到位: sudo alien -i packagename.rpm</p>
</li>
</ul>
</li>
<li><p>Oracle 的连接方式</p>
<ul>
<li><p>SID/System IDentifier: 数据库实例的全局唯一ID, 每个实例都不一样</p>
</li>
<li><p>SERVICE_NAME: 用于对外提供服务的名字, 被客户端使用</p>
<ul>
<li>也可以被数据库端用来区分对不同客户端提供的服务</li>
</ul>
</li>
<li><p>TNS/Transparent Network Substrate: 由Oracle创造的, 专门用于Oracle数据库连接的, 基于TCP/IP, SDP和命名管道的, 同构p2p连接技术</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; STATE.WORLD是一个TNS Name</span><br><span class="line">STAGE.WORLD &#x3D;</span><br><span class="line">    (DESCRIPTION &#x3D;</span><br><span class="line">        (ADDRESS &#x3D;</span><br><span class="line">            (PROTOCOL &#x3D; TCP) </span><br><span class="line">            (PORT &#x3D; 1521)</span><br><span class="line">            (HOST &#x3D; LITTLECOMPUTER.ACME.ORG) &#x2F;&#x2F; 服务器地址</span><br><span class="line">        )</span><br><span class="line">        (CONNECT_DATA &#x3D; (SID &#x3D; MYSID)) &#x2F;&#x2F; 数据库标识, 可以使用SID或者SERVICE_NAME</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; PROD.WORLD也是一个TNS Name</span><br><span class="line">PROD.WORLD &#x3D;</span><br><span class="line">    (DESCRIPTION &#x3D;</span><br><span class="line">        (ADDRESS &#x3D;</span><br><span class="line">            (PROTOCOL &#x3D; TCP) </span><br><span class="line">            (PORT &#x3D; 1521)</span><br><span class="line">            (HOST &#x3D; BIGCOMPUTER.ACME.ORG)</span><br><span class="line">        )</span><br><span class="line">        (CONNECT_DATA &#x3D; (SERVICE_NAME &#x3D; MYNAME))</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>每日记录</title>
    <url>/2020/12/03/daily/</url>
    <content><![CDATA[<h1 id="秘书问题"><a href="#秘书问题" class="headerlink" title="秘书问题"></a>秘书问题</h1><ul>
<li><p>又称相亲问题、止步问题、见好就收问题、苏丹的嫁妆问题、挑剔的求婚者问题等</p>
</li>
<li><p>要聘请一名秘书，有 n 个应聘者。每次面试一人，面试后就要及时决定是否聘他，如果当时决定不聘他，他便不会回来。面试后总能清楚了解应聘者的合适程度，并能和之前的每个人做比较。问什么样的策略，才使最佳人选被选中的概率最大。 </p>
</li>
<li><p>答案:</p>
  <details>
  <summary>展开</summary>

<ul>
<li><p>这个问题的最优解是一个停止规则。在这个规则里，面试官会拒绝头 r - 1 个应聘者 (令他们中的最佳人选为 应聘者 M)，然后选出第一个比 M 好的应聘者。可见最优策略包含于这个系列的策略中。 (如果M在所有n个应聘者中也是最好的一个，那么这个策略将选不出任何人选)对于任意的截断值 r，最佳人选被选中的概率是： </p>
<p>  $${\displaystyle {\begin{aligned}P(r)&amp;=\sum _{i=1}^{n}P\left({\text{applicant }}i{\text{ is selected}}\cap {\text{applicant }}i{\text{ is the best}}\right)\&amp;=\sum _{i=1}^{n}P\left({\text{applicant }}i{\text{ is selected}}|{\text{applicant }}i{\text{ is the best}}\right)\cdot P\left({\text{applicant }}i{\text{ is the best}}\right)\&amp;=\left[\sum _{i=1}^{r-1}0+\sum _{i=r}^{n}P\left(\left.{\begin{array}{l}{\text{the best of the first }}i-1{\text{ applicants}}\{\text{is in the first }}r-1{\text{ applicants}}\end{array}}\right|{\text{applicant }}i{\text{ is the best}}\right)\right]\cdot {\frac {1}{n}}\&amp;=\left[\sum _{i=r}^{n}{\frac {r-1}{i-1}}\right]\cdot {\frac {1}{n}}\quad =\quad {\frac {r-1}{n}}\sum _{i=r}^{n}{\frac {1}{i-1}}.\end{aligned}}}$$</p>
</li>
<li><p>当n趋近于无穷大时</p>
<p>  $${\displaystyle P(x)=x\int _{x}^{1}{\frac {1}{t}},dt=-x\ln(x).}$$</p>
</li>
<li><p>求出最优的x值为</p>
<p>  $$\frac {1}{e}$$</p>
</details>


</li>
</ul>
</li>
</ul>
<h1 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h1><ul>
<li><p>root: 表示去哪个目录下寻找对应url的文件, 实际上是添加前缀</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;aaaa&#x2F; &#123;</span><br><span class="line">    root &#x2F;home&#x2F;tom&#x2F;www&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>请求: http://(hostname)<span style="background-color: yellow;">/aaaa/</span>hello.txt</p>
</li>
<li><p>返回: <span style="background-color: #cdffd8;">/home/tom/www</span><span style="background-color: yellow;">/aaaa/</span>hello.txt</p>
</li>
</ul>
</li>
<li><p>alias: 表示把匹配成功的路径<strong>替换</strong>成alias</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;aaaa&#x2F; &#123;</span><br><span class="line">    alias &#x2F;home&#x2F;tom&#x2F;www&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>请求: http://(hostname)<span style="background-color: yellow;">/aaaa/</span>hello.txt </p>
</li>
<li><p>返回: <span style="background-color: #cdffd8;">/home/tom/www/</span>hello.txt</p>
</li>
</ul>
</li>
<li><p>PS: Nginx会自动将两个连续的斜杠替换成一个</p>
</li>
</ul>
<h1 id="Flask-嵌套路由配置"><a href="#Flask-嵌套路由配置" class="headerlink" title="Flask 嵌套路由配置"></a>Flask 嵌套路由配置</h1><ul>
<li><p>使用<code>register_blueprint</code>时的<code>url_prefix</code>参数</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create app, blueprints, etc.</span></span><br><span class="line">app.register_blueprint(myblueprint, url_prefix=<span class="string">&#x27;/somepath&#x27;</span>)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="视频网站设计思考"><a href="#视频网站设计思考" class="headerlink" title="视频网站设计思考"></a>视频网站设计思考</h1><ul>
<li>视频文件存储到哪里: OSS对象存储服务</li>
</ul>
<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><ol>
<li><p>读未提交(Read Uncommitted)</p>
</li>
<li><p>读已提交(Read Committed)/不可重复读 大多数数据库默认的隔离级别</p>
</li>
<li><p>可重复读(Repeatable-Read) mysql数据库所默认的级别</p>
</li>
<li><p>序列化(serializable)</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Nginx</tag>
        <tag>Math</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>每日记录</title>
    <url>/2020/12/04/daily/</url>
    <content><![CDATA[<h1 id="Java-包-Package-Jar和模块-Module-的区别"><a href="#Java-包-Package-Jar和模块-Module-的区别" class="headerlink" title="Java 包(Package), Jar和模块(Module)的区别"></a>Java 包(Package), Jar和模块(Module)的区别</h1><ul>
<li><p>包 (Package)</p>
<ul>
<li><p>是Java源文件的集合, 包含Class/Interface/Annotation的定义</p>
</li>
<li><p>与文件系统中的目录对应</p>
</li>
<li><p>主要目的是<em>防止命名冲突</em></p>
</li>
</ul>
</li>
<li><p>Jar (Java Archive File)</p>
<ul>
<li><p>是编译后的Java代码(<code>.class</code>)的压缩包</p>
</li>
<li><p>实际上是一个zip格式文件</p>
</li>
<li><p>对Jar的操作用<code>jar</code>命令, 其语法类似Linux下的<code>tar</code></p>
<ul>
<li><p>创建Jar包: <code>jar cvf test.jar test</code></p>
</li>
<li><p>解压Jar包: <code>jar xvf test.jar</code></p>
</li>
<li><p>列举Jar包的内容: <code>jar tvf test.jar</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>模块 (Module)</p>
<ul>
<li><p>是Java语言内置的一种管理组件之间依赖关系的方法, 在Java 9被引入</p>
</li>
<li><p>Module 解决的问题:</p>
<ul>
<li><p>在Java 9之前, <strong>主要使用package作为封装方式，使用Jar作为模块, 封装方式由 package和访问修饰符 (private, protected, public,包私有) 控制</strong></p>
<ul>
<li><p>任何模块都能访问其他模块的public的代码，不同Jar下的同名包可以相互访问包私有的代码。</p>
</li>
<li><p>无法控制非平台开发者对平台内部包的访问，如应用代码可以访问sun.misc、com.sun.security这样和具体平台绑定的包。</p>
</li>
<li><p>没有明确的依赖信息，模块开发者无法设置必须的依赖，模块使用者不清楚该模块必须依赖哪些模块。只能使用外部的工具，如Maven、Gradle、OSGI等。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Module 的优势</p>
<ul>
<li><p>明确的依赖配置，JPMS会在编译和运行之前检查当前环境是否满足依赖的要求。JPMS会检查版本冲突，即当有两个模块暴露了相同的包名时，系统会抛出异常。JPMS支持传递性依赖。</p>
</li>
<li><p>强大的封装，模块可以明确指定哪些包能暴露给哪些模块，JPMS不允许代码使用反射的方式访问不对外开放的包。</p>
</li>
<li><p>性能优化，JPMS完全清楚哪些模块是需要的，所以不需要的模块不会被JVM载入。</p>
</li>
</ul>
</li>
<li><p>Module 的不足:</p>
<ul>
<li>缺乏对模块的版本的支持</li>
</ul>
</li>
<li><p>特点:</p>
<p>  <img src="images/java-module.jpg"></p>
</li>
</ul>
</li>
</ul>
<h1 id="Linux-Ubuntu-硬件管理"><a href="#Linux-Ubuntu-硬件管理" class="headerlink" title="Linux (Ubuntu) 硬件管理"></a>Linux (Ubuntu) 硬件管理</h1><ul>
<li><p>通用</p>
<ul>
<li><code>lshw -short</code>: 列举所有硬件信息</li>
</ul>
</li>
<li><p>CPU</p>
<ul>
<li><p><code>lscpu</code>: 查看CPU信息</p>
</li>
<li><p><code>cat /proc/cpuinfo</code>: 查看每个CPU的信息</p>
</li>
</ul>
</li>
<li><p>内存</p>
<ul>
<li><p><code>free [-m|-g|-k|-b|-h]</code>: 查看内存使用情况</p>
</li>
<li><p><code>cat /proc/meminfo</code>: 查看内存详细使用情况</p>
</li>
<li><p><code>dmidecode -t memory</code>: 查看内存硬件信息</p>
</li>
</ul>
</li>
<li><p>硬盘</p>
<ul>
<li><p><code>lsblk</code>: 查看硬盘和分区信息</p>
</li>
<li><p><code>fdisk -l</code>: 查看详细分区表</p>
</li>
<li><p><code>df -h</code>: 查看硬盘剩余空间</p>
</li>
</ul>
</li>
<li><p>主板 BIOS</p>
<ul>
<li><code>dmidecode -t bios</code>: 查看bios信息</li>
</ul>
</li>
<li><p>PCI设备</p>
<ul>
<li><code>lspci</code></li>
</ul>
</li>
<li><p>网卡</p>
<ul>
<li><p><code>lspci | grep -i &#39;Ethernet&#39;</code>: 查看网卡硬件信息 (Ethernet 以太网)</p>
</li>
<li><p><code>lspci | grep -i &#39;Wireless&#39;</code>: 查看无线网卡硬件信息</p>
</li>
<li><p><code>ifconfig -a</code>: 查看系统的所有网络接口</p>
</li>
</ul>
</li>
<li><p>USB 设备</p>
<ul>
<li><code>lsusb</code></li>
</ul>
</li>
</ul>
<h1 id="apt-remove-与-apt-purge-的区别"><a href="#apt-remove-与-apt-purge-的区别" class="headerlink" title="apt remove 与 apt purge 的区别"></a>apt remove 与 apt purge 的区别</h1><ul>
<li>purge会删除配置文件, 而remove只会删除程序文件</li>
</ul>
<h1 id="Java-学习"><a href="#Java-学习" class="headerlink" title="Java 学习"></a>Java 学习</h1><ul>
<li><p>Java多线程</p>
<ul>
<li>interrupt() 向该进程发送中断信号, 具体怎么处理由该进程实现</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>每日记录</title>
    <url>/2020/12/05/daily/</url>
    <content><![CDATA[<h1 id="Java-Spring-框架学习"><a href="#Java-Spring-框架学习" class="headerlink" title="Java Spring 框架学习"></a>Java Spring 框架学习</h1><p>Spring框架，它最主要的功能就是管理一堆使App（应用）发挥功能的类，这些作为整个App的基石、主干的类，就叫做bean。</p>
<p>要管理bean，也即是这堆发挥业务功能的类，就不能直接把它们new出来，这样缺乏统一的调度。所以，Spring使用.xml配置文件作为媒介，以IoC（Inversion of Control 控制反转）作为工具，将这些bean拿给Spring container作统一管理。</p>
<h1 id="Git-submodule-使用"><a href="#Git-submodule-使用" class="headerlink" title="Git submodule 使用"></a>Git submodule 使用</h1><ul>
<li><p>添加子模块</p>
<ul>
<li><code>git submodule add &lt;url&gt; &lt;path&gt;</code></li>
</ul>
</li>
<li><p>设置子模块的分支</p>
<ul>
<li><code>git submodule set-branch --branch &lt;branch&gt; &lt;path&gt;</code></li>
</ul>
</li>
<li><p>克隆下来的项目包含子模块</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git submodule init</span><br><span class="line">$ git submodule update</span><br></pre></td></tr></table></figure>

<p>  或者</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
</li>
<li><p>子模块的更新</p>
<ol>
<li><p>在子模块内部, 作为一般的git项目更新(<code>pull</code>)</p>
</li>
<li><p>在项目目录下<code>git add</code></p>
</li>
</ol>
</li>
<li><p>子模块的删除</p>
<ul>
<li><p><code>rm -rf 子模块目录</code> 删除子模块目录及源码</p>
</li>
<li><p>删除项目目录下.gitmodules文件中子模块相关条目</p>
</li>
<li><p>vi .git/config 删除配置项中子模块相关条目</p>
</li>
<li><p><code>rm .git/module/*</code> 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可</p>
</li>
</ul>
</li>
</ul>
<h1 id="Github-开源项目包含不想公开的密码-Token等怎么处理"><a href="#Github-开源项目包含不想公开的密码-Token等怎么处理" class="headerlink" title="Github 开源项目包含不想公开的密码/Token等怎么处理"></a>Github 开源项目包含不想公开的密码/Token等怎么处理</h1><p>可以将隐私数据包含在项目的Secret设置中, 在Github Action中使用脚本将隐私数据注入到文件中</p>
<h1 id="YAML-语言"><a href="#YAML-语言" class="headerlink" title="YAML 语言"></a>YAML 语言</h1><p>基本类型:</p>
<blockquote>
<ul>
<li><p>String</p>
</li>
<li><p>Bool: <code>true</code>, <code>false</code></p>
</li>
<li><p>Int</p>
</li>
<li><p>Number</p>
</li>
<li><p>null: <code>~</code></p>
</li>
<li><p>Time: ISO8601 格式, 例<code>2001-12-14t21:59:43.10-05:00</code></p>
</li>
<li><p>Date: <code>1976-07-31</code></p>
</li>
</ul>
</blockquote>
<p>注释: <code>#</code></p>
<p>使用左端对齐的键值对表示对象:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">key1:</span> <span class="string">abc</span></span><br><span class="line">  <span class="attr">key2:</span> <span class="number">123</span></span><br><span class="line">  <span class="attr">key3:</span> <span class="string">sss</span></span><br></pre></td></tr></table></figure>

<p>使用以<code>-</code>开头的对齐的值表示数组: </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fruits:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">orange</span></span><br></pre></td></tr></table></figure>

<p>数组套对象:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">objs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">object</span> <span class="string">A</span></span><br><span class="line">    <span class="attr">desp:</span> <span class="string">I&#x27;am</span> <span class="string">an</span> <span class="string">object</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Object</span> <span class="string">B</span></span><br><span class="line">    <span class="attr">desp:</span> <span class="string">I&#x27;am</span> <span class="string">another</span> <span class="string">object</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Object</span> <span class="string">C</span></span><br><span class="line">    <span class="attr">desp:</span> <span class="string">I&#x27;am</span> <span class="string">still</span> <span class="string">an</span> <span class="string">object</span></span><br></pre></td></tr></table></figure>

<p>数组套数组:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">matrix:</span> </span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">a11</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a12</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a13</span></span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">a21</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a22</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a23</span></span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">a31</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a32</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a33</span></span><br></pre></td></tr></table></figure>

<p>对象套数组:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">frezcirno</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Boy</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Handsome</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Student</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Cool</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
