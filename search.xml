<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>word2vec</title>
    <url>/2023/10/28/word2vec/</url>
    <content><![CDATA[<h2 id="whats-it">What's it</h2>
<p>2013年，Google开源的，用于词向量计算的工具</p>
<h2 id="架构">架构</h2>
<p>X -- Dense -- Dense -- Softmax -- Y</p>
<p>CBoW: 利用上下文预测当前词</p>
<p>Skip-gram: 利用当前词预测上下文</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>LLVM 中间语言参考</title>
    <url>/2023/12/22/llvm/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>LLVM is a <em>Static Single Assignment (SSA)</em> based representation that provides <em>type safety</em>, low-level operations, flexibility, and the capability of <em>representing ‘all’ high-level languages cleanly</em></p>
<p>更严谨, 更formal的 C 语言</p>
<p>LLVM IR 有三种形态: 位于llvm工具内存中, 以二进制格式存储(.bc文件), 以文本格式存储(.ll文件). 用 <code>llvm-as</code> 可以把 .ll 格式转换为 .bc 格式, <code>llvm-dis</code> 反之</p>
<p>LLVM IR 由和高级语言类似的语句组成.</p>
<h2 id="注释">注释</h2>
<p>以 ; 开头的行是注释</p>
<h2 id="局部变量">局部变量</h2>
<p>LLVM IR 中的变量存储临时结果</p>
<p>变量名字以 % 开头, 变量名中可以有 . 等字符, 可以是纯数字</p>
<p>变量不需要提前声明, 赋值即定义变量</p>
<p>变量采用 SSA 模式, 不能被重复赋值</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">mul</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> <span class="number">7</span></span><br><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">zext</span> <span class="type">i1</span> <span class="variable">%1</span> <span class="keyword">to</span> <span class="type">i32</span></span><br></pre></td></tr></table></figure>
<h2 id="全局变量">全局变量</h2>
<p>全局变量名字以 @ 开头</p>
<h2 id="类型">类型</h2>
<p>LLVM IR 必须指定每个变量, 函数的类型</p>
<p>不会发生自动类型转换</p>
<h2 id="函数">函数</h2>
<p>declare 声明函数</p>
<p>define 定义函数</p>
<h2 id="标签-label">标签 label</h2>
<p>LLVM IR 的标签和 C 语言中类似</p>
<h2 id="phi">Phi</h2>
<p>有时需要对已经定义的变量赋一个新的值 (例如循环变量)</p>
<p>SSA 不允许这样做 -&gt; phi 运算</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">&lt;result&gt; <span class="operator">=</span> <span class="keyword">phi</span> &lt;ty&gt; [&lt;val<span class="number">0</span>&gt;<span class="punctuation">,</span> &lt;label<span class="number">0</span>&gt;]<span class="punctuation">,</span> [&lt;val<span class="number">1</span>&gt;<span class="punctuation">,</span> &lt;label<span class="number">1</span>&gt;] …</span><br></pre></td></tr></table></figure>
<p>根据前一个基本块是哪一个 选择对应的值</p>
<h2 id="复合类型-array-struct">复合类型 array struct</h2>
<p>数组的类型用 [<size> x <ty>] 表示</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@array</span> <span class="operator">=</span> <span class="keyword">global</span> [<span class="number">42</span> <span class="keyword">x</span> <span class="type">i32</span>] <span class="keyword">zeroinitializer</span></span><br></pre></td></tr></table></figure>
<p>结构体用</p>
<h2 id="常用指令">常用指令</h2>
<h3 id="栈内存分配-alloca">栈内存分配 alloca</h3>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%ptr</span> <span class="operator">=</span> <span class="keyword">alloca</span> &lt;<span class="keyword">type</span>&gt;</span><br></pre></td></tr></table></figure>
<p>背后是栈指针的改变</p>
<h3 id="读取写入值-load-store">读取/写入值 load store</h3>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">&lt;result&gt; <span class="operator">=</span> <span class="keyword">load</span> [<span class="keyword">volatile</span>] &lt;ty&gt;<span class="punctuation">,</span> &lt;ty&gt;* &lt;pointer&gt;</span><br><span class="line">    [<span class="punctuation">,</span> <span class="keyword">align</span> &lt;alignment&gt;]</span><br><span class="line">    [<span class="punctuation">,</span> <span class="title">!nontemporal</span> !]</span><br><span class="line">    [<span class="punctuation">,</span> <span class="title">!invariant.load</span> !&lt;empty_node&gt;]</span><br><span class="line">    [<span class="punctuation">,</span> <span class="title">!invariant.group</span> !]</span><br><span class="line">    [<span class="punctuation">,</span> <span class="title">!nonnull</span> !&lt;empty_node&gt;]</span><br><span class="line">    [<span class="punctuation">,</span> <span class="title">!dereferenceable</span> !]</span><br><span class="line">    [<span class="punctuation">,</span> <span class="title">!dereferenceable_or_null</span> !&lt;deref_bytes_node&gt;]</span><br><span class="line">    [<span class="punctuation">,</span> <span class="title">!align</span> !]</span><br><span class="line">    [<span class="punctuation">,</span> <span class="title">!noundef</span> !&lt;empty_node&gt;]</span><br></pre></td></tr></table></figure>
<h3 id="指针偏移-get-element-pointer-gep">指针偏移 Get Element Pointer (GEP)</h3>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">&lt;result&gt; <span class="operator">=</span> <span class="keyword">getelementptr</span> &lt;ty&gt;<span class="punctuation">,</span> &lt;ty&gt;* &lt;ptrval&gt;<span class="punctuation">,</span> [<span class="type">i32</span> &lt;idx&gt;]+</span><br><span class="line"><span class="comment">; 语法: getelementptr 结果类型  数组类型* 数组变量  索引(可以有多个)</span></span><br></pre></td></tr></table></figure>
<p>GEP 仅计算指针加上偏移后的值, 本身并不进行任何数据的访问或修改</p>
<p>偏移按照指向对象的类型, 相当于 C 语言里面的 数组+偏移量 的模式</p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>程序分析</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学</title>
    <url>/2023/10/31/discrete-mathematics/</url>
    <content><![CDATA[<p>集合</p>
<p>偏序集(poset):</p>
]]></content>
      <categories>
        <category>course-notes</category>
      </categories>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/2021/01/08/linear-algebra/</url>
    <content><![CDATA[<h1 id="线性代数笔记">线性代数笔记</h1>
<h2 id="行列式">1. 行列式</h2>
<h3 id="基本概念">基本概念</h3>
<p>二阶行列式</p>
<p>三阶行列式</p>
<p>全排列</p>
<p>对换</p>
<p>n阶行列式</p>
<p>上下三角行列式</p>
<p>对角行列式</p>
<p>转置行列式</p>
<h4 id="性质">性质</h4>
<ul>
<li>转置行列式, 行列式不变</li>
<li><strong>对换行(列), 行列式变号</strong>
<ul>
<li>两行(列)完全相同, 行列式=0</li>
<li>两行(列)成比例, 行列式=0</li>
</ul></li>
<li>一行(列)乘k = 整体乘k
<ul>
<li><strong>行(列)系数提到外面, 行列式不变</strong></li>
</ul></li>
<li>可以按照某一行(列)分成两个行列式相加</li>
<li><strong>一行乘k加到另一行, 行列式不变</strong></li>
</ul>
<h3 id="按行列展开">按行(列)展开</h3>
<ul>
<li>余子式 <span class="math inline">\(M_{ij}\)</span></li>
<li>代数余子式 <span class="math inline">\(A_{ij}=(-1)^{i+j}{M_{ij}}\)</span></li>
</ul>
<h4 id="性质-1">性质</h4>
<ul>
<li><p>按行(列)展开法则 <span class="math inline">\(D=\sum_{i=1}^{n}{a_{ij}A_{ij}}, (j=1,2,...,n)=\sum_{j=1}^{n}{a_{ij}A_{ij}}, (i=1,2,...,n)\)</span></p></li>
<li><p>如果上式中<span class="math inline">\(a\)</span>和<span class="math inline">\(A\)</span>的<span class="math inline">\(j(i)\)</span>错开, 则结果为0</p></li>
</ul>
<h4 id="范德蒙德行列式">范德蒙德行列式</h4>
<p><span class="math display">\[
D_n=\begin{vmatrix}
1&amp;1&amp;...&amp;1 \\
x_1&amp;x_2&amp;...&amp;x_n \\
x_1^2&amp;x_2^2&amp;...&amp;x_n^2 \\
:&amp;:&amp; &amp;: \\
x_1^{n-1}&amp;x_2^{n-1}&amp;...&amp;x_n^{n-1}
\end{vmatrix} 
=\prod_{n\ge i\ge j\ge 1}{(x_i-x_j)}
(注意顺序)
\]</span></p>
<h2 id="矩阵及其运算">2. 矩阵及其运算</h2>
<p>线性方程组</p>
<p>非齐次线性方程组</p>
<p>齐次线性方程组</p>
<p>齐次线性方程组的零解</p>
<h3 id="矩阵">矩阵</h3>
<p>同型矩阵</p>
<p>系数矩阵</p>
<p>未知数矩阵</p>
<p>常数项矩阵</p>
<p>增广矩阵</p>
<p>线性变换</p>
<h4 id="按性质">按性质</h4>
<ul>
<li>非奇异矩阵/可逆矩阵/满秩矩阵</li>
<li>奇异矩阵/不可逆矩阵/降秩矩阵</li>
</ul>
<h4 id="按形状">按形状</h4>
<ul>
<li>对角矩阵</li>
<li>单位矩阵</li>
<li>对称矩阵</li>
</ul>
<h3 id="矩阵运算">矩阵运算</h3>
<ul>
<li>矩阵加法
<ul>
<li>负矩阵</li>
</ul></li>
<li>数乘</li>
<li>矩阵乘法
<ul>
<li>可交换</li>
<li>纯量阵: 一定可交换</li>
</ul></li>
<li>幂</li>
<li>转置</li>
<li>行列式</li>
<li>伴随矩阵</li>
<li>矩阵多项式</li>
</ul>
<h4 id="性质-2">性质</h4>
<h5 id="转置性质">转置性质</h5>
<ul>
<li>自反性 <span class="math inline">\((A^{T})^{T}=A\)</span></li>
<li>线性 <span class="math inline">\((\lambda A+B)^{T}=\lambda A^{T}+B^{T}\)</span></li>
<li>嵌套 <span class="math inline">\((AB)^{T}=B^{T}A^{T}\)</span></li>
<li>判零 <span class="math inline">\(A^TA=O\Leftrightarrow A=O\)</span></li>
</ul>
<h5 id="行列式性质">行列式性质</h5>
<ul>
<li>常数放大 <span class="math inline">\(\left|\lambda A\right|=\lambda^n\left|A\right|\)</span></li>
<li>可乘性 <span class="math inline">\(\left|AB\right|=\left|A\right|\left|B\right|\)</span></li>
</ul>
<h5 id="伴随矩阵性质">伴随矩阵性质</h5>
<ul>
<li>与转置可交换 <span class="math inline">\((A^T)^*=(A^*)^T\)</span></li>
<li>与逆可交换 <span class="math inline">\((A^{-1})^*=(A^*)^{-1}\)</span></li>
<li>嵌套 <span class="math inline">\((AB)^*=B^*A^*\)</span></li>
<li>常数部分放大 <span class="math inline">\((\lambda A)^*=\lambda^{n-1}A^*\)</span></li>
</ul>
<h5 id="伴随矩阵的行列式和秩">伴随矩阵的行列式和秩</h5>
<ul>
<li><span class="math inline">\(\left|A^*\right|=\left|A\right|^{n-1}\)</span></li>
<li><span class="math inline">\(R(A^*)=\begin{cases}n,R(A)=n~(满秩不变)\\1,R(A)=n-1~(差1补1)\\0,R(A)&lt;n-1~(否则为0, A^*=0)\end{cases}\)</span></li>
</ul>
<h3 id="矩阵分块法">矩阵分块法</h3>
<p>分块矩阵</p>
<p>子块</p>
<p>分块对角矩阵 * 性质 * 行列式 <span class="math inline">\(\left|A\right|=\left|A_1\right|\left|A_2\right|...\left|A_n\right|\)</span> * 逆</p>
<h2 id="初等变换与线性方程组">3. 初等变换与线性方程组</h2>
<h3 id="初等变换">初等变换</h3>
<p>行(列)变换 <span class="math inline">\(\Leftrightarrow\)</span> 左(右)乘同样变化之后的<span class="math inline">\(E\)</span> * 对换两行(列) * 缩放某一行(列)加到另一行(列)上去 (源和目标可以一样)</p>
<p>初等矩阵: 施加一次初等行(列)变换的E</p>
<h3 id="矩阵等价">矩阵等价</h3>
<p>A和B等价: A经若干次初等变化可以变为B</p>
<p>等价关系: 自反性, 对称性, 传递性</p>
<p>推论: <span class="math inline">\(A\sim (r)\sim E\Leftrightarrow{A可逆}\)</span></p>
<h4 id="充要条件">充要条件</h4>
<p><span class="math inline">\(A\sim (r)\sim B\Leftrightarrow PA=B (P, Q可逆)\)</span></p>
<p><span class="math inline">\(A\sim (c)\sim B\Leftrightarrow AQ=B (P, Q可逆)\)</span></p>
<p><span class="math inline">\(A\sim B\Leftrightarrow PAQ=B (P, Q可逆)\)</span></p>
<h3 id="行阶梯形矩阵">行阶梯形矩阵</h3>
<p>左下角的0组成了一个从右下到左上的阶梯, 这个阶梯的宽度任意, 但是每一级的高度必定为1(两边不算)</p>
<p>非零首元: 非零行的首个非零元素</p>
<p><span class="math display">\[
\begin{pmatrix}
 x &amp; . &amp; . &amp; . &amp; .\\
 0 &amp; x &amp; . &amp; . &amp; .\\
 0 &amp; 0 &amp; x &amp; . &amp; .\\
 0 &amp; 0 &amp; 0 &amp; x &amp; .
\end{pmatrix}
\begin{pmatrix}
 x &amp; . &amp; . &amp; . &amp; .\\
 0 &amp; 0 &amp; 0 &amp; x &amp; .\\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
\end{pmatrix}
\]</span></p>
<h3 id="行最简形矩阵">行最简形矩阵</h3>
<p>在行阶梯型矩阵的基础上, 非零首元都是1, 非零首元的上下都是0, 则为行最简形矩阵</p>
<p><span class="math display">\[
\begin{pmatrix}
 1 &amp; 0 &amp; 0 &amp; 0 &amp; .\\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; .\\
 0 &amp; 0 &amp; 1 &amp; 0 &amp; .\\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; .
\end{pmatrix}
\begin{pmatrix}
 1 &amp; . &amp; . &amp; 0 &amp; .\\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; .\\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
\end{pmatrix}
\]</span></p>
<ul>
<li>一个矩阵的行最简形矩阵是唯一的</li>
</ul>
<h3 id="标准形">标准形</h3>
<p>对行最简形矩阵施加初等列变换, 是非零首元依次排列在左边, 右边全0</p>
<p>特点是左上角是个E</p>
<p><span class="math display">\[
\begin{pmatrix}
 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
\end{pmatrix}
\]</span></p>
<h3 id="技巧">技巧</h3>
<h4 id="pabab"><span class="math inline">\(P(A,B)=(A&#39;,B&#39;)\)</span></h4>
<ul>
<li><span class="math inline">\(P(A, E)=(E, A^{-1})\)</span>, 求A逆常用方法</li>
<li><span class="math inline">\(P(A, B)=(E, A^{-1}B)\)</span>, 解方程常用方法</li>
</ul>
<h3 id="矩阵的秩">矩阵的秩</h3>
<p>子式: 从行中选出一个子序列, 再从列中选出一个子序列, 得到的结果</p>
<p>秩: 最高阶非零子式的阶数</p>
<h4 id="性质-3">性质</h4>
<ol type="1">
<li><p>秩一定小于行(列)数</p></li>
<li><p>转置不改变秩</p></li>
<li><p>等价矩阵的秩一样: <span class="math inline">\(A\sim B\Leftrightarrow{R(A)=R(B)}\)</span></p></li>
<li><p>乘可逆矩阵不改变秩</p></li>
<li><p>拼接矩阵的秩可能比原秩要大: <span class="math inline">\(max\{R(A),R(B)\}\le{R(A~~B)}\)</span></p></li>
<li><p>拼接矩阵的秩不会大于原秩之和: <span class="math inline">\(R(A~~B)\le{R(A)+R(B)}\)</span></p></li>
<li><hr /></li>
<li><p>秩和大于和秩(由上一条可证): <span class="math inline">\(R(A+B)\le{R(A)+R(B)}\)</span></p></li>
<li><p>矩阵积的秩不大于任何一个原秩(从变换角度看): <span class="math inline">\(R(AB)\le{min\{R(A),R(B)\}}\)</span></p></li>
<li><p><span class="math inline">\(A_{m\times n}B_{n\times l}=O\Rightarrow{R(A)+R(B)\le{n}}\)</span></p></li>
<li><hr />
<p>列满秩: 秩等于列数, 对应的行最简形矩阵为<span class="math inline">\(\begin{pmatrix}E_{n} \\ O\end{pmatrix}_{m\times n}\)</span></p></li>
<li><p>乘法消去律: <span class="math inline">\(AB=O, A列满秩\Rightarrow B=O\)</span></p></li>
</ol>
<h3 id="秩与线性方程组的解">秩与线性方程组的解</h3>
<p>相容: 有解</p>
<p>不相容: 无解</p>
<p>判断条件<span class="math inline">\(Ax=b\)</span> * <span class="math inline">\(无解\Leftrightarrow{R(A)\lt{R(A~~b)}}\)</span> * <span class="math inline">\(有解\Leftrightarrow{R(A)={R(A~~b)}}\)</span> * <span class="math inline">\(有唯一解(齐次就是零解)\Leftrightarrow{R(A)=R(A~~b)=n}\)</span> * <span class="math inline">\(有无穷解(齐次有非零解)\Leftrightarrow{R(A)=R(A~~b)\lt n}\)</span></p>
<h2 id="向量组-线性相关性">4. 向量组, 线性相关性</h2>
<p>n维向量</p>
<p>实向量</p>
<p>复向量</p>
<p>单位坐标向量: E的列向量</p>
<h3 id="向量组">向量组</h3>
<h3 id="线性表示">线性表示</h3>
<p>线性组合</p>
<p><strong>线性表示</strong>: 一个向量(组)能被另一个向量组线性表示</p>
<p>向量组等价: 两个向量组能互相线性表示</p>
<h4 id="定理">定理</h4>
<ul>
<li><p><span class="math inline">\(向量b能被向量组A线性表示\Leftrightarrow{R(A)=R(A~~b)}\)</span></p></li>
<li><p><span class="math inline">\(向量组A能被向量组B线性表示\Leftrightarrow R(A)=R(A~~B)\)</span></p></li>
<li><p><span class="math inline">\(向量组A, B能相互线性表示(等价)\Leftrightarrow{R(A)=R(B)=R(A~~B)}\)</span></p></li>
<li><hr /></li>
<li><p><span class="math inline">\(若AB=C, 则C的列向量组能被A的列向量组线性表示, 表示的系数为B\)</span></p></li>
<li><p><span class="math inline">\(同理, C的行向量组能被B的行向量组线性表示, 表示的系数为A\)</span></p></li>
<li><p><span class="math inline">\(向量组B能被向量组A线性表示\Leftrightarrow R(B)=R(B~~A)\Rightarrow{R(B)\le R(A)}\)</span></p></li>
</ul>
<h3 id="线性相关">线性相关</h3>
<p>线性相关: 存在一个系数非全零的线性组合=0的向量组</p>
<p>线性无关</p>
<h4 id="性质-4">性质</h4>
<ul>
<li><span class="math inline">\(线性相关\Leftrightarrow{R(A)\lt m}\)</span></li>
<li><span class="math inline">\(线性无关\Leftrightarrow{R(A)=m}\)</span></li>
<li><span class="math inline">\(线性相关具有保持性质\)</span></li>
<li><span class="math inline">\(秩\lt向量个数\Leftrightarrow{线性相关}\)</span></li>
<li><span class="math inline">\(向量维数\lt向量个数\Rightarrow{线性相关}\)</span></li>
<li><span class="math inline">\(线性无关向量组A+b变线性相关\Rightarrow{b能被A唯一线性表示}\)</span></li>
</ul>
<h3 id="向量组的秩">向量组的秩</h3>
<p>向量组</p>
<p>最大(线性)无关(向量)组</p>
<p>秩: 最大无关组的向量个数</p>
<h4 id="性质见上节">性质见上节</h4>
<h3 id="线性方程组解的结构">线性方程组解的结构</h3>
<h4 id="齐次的解axo">齐次的解<span class="math inline">\(Ax=O\)</span></h4>
<ul>
<li>齐次: 解的线性组合仍是解</li>
<li>因此只要找到解集的一个最大无关组即可得出所有解</li>
</ul>
<p>基本解系: 齐次的解集的一个最大无关组</p>
<p>基本解系的秩: * <span class="math inline">\(对于方程组A_{m\times n}x=0, R_S=n-R(A)\)</span></p>
<p>求解步骤: 1. 对A进行行变换变成行最简形矩阵 2. 得到x之间的关系 3. 给每个自由变量赋值一个线性无关的向量(一般取单位向量)</p>
<p>例题:</p>
<img src="/2021/01/08/linear-algebra/qiutongjie.png" class="">
<h5 id="性质-5">性质</h5>
<ul>
<li><span class="math inline">\(Ax=O和Bx=O同解\Rightarrow R(A)=R(B)\)</span></li>
</ul>
<h4 id="非齐次的解axb">非齐次的解<span class="math inline">\(Ax=b\)</span></h4>
<ul>
<li>非齐次: 利用齐次</li>
<li>找到一个特解, 加上齐次的通解即为最终解</li>
</ul>
<h3 id="向量空间">向量空间</h3>
<p>向量空间: 对线性运算封闭的集合</p>
<p>子空间: 含于另一个向量空间的向量空间</p>
<p>基: 在向量空间中, 可以线性表示空间中任一向量的线性无关的向量组</p>
<p>自然基: <span class="math inline">\(R^n\)</span>中的单位坐标向量组</p>
<p>维数: 基的向量个数(固定)</p>
<p>坐标: 一个向量在某一个基下的表示</p>
<p><strong>基变换公式</strong>: 用一个基来表示另一个基的坐标(没啥用)</p>
<p><span class="math display">\[
B=AP=AA^{-1}B
\]</span></p>
<p><strong>过渡矩阵</strong>: 旧基逆乘新基, 可以用初等变换的方法快速求</p>
<p><span class="math display">\[
P=A^{-1}B
\]</span></p>
<p><strong>坐标变换公式</strong>: 一个向量在两个不同基下的坐标的关系式</p>
<p><span class="math display">\[
新坐标~Z=P^{-1}Y
\]</span></p>
<h2 id="相似矩阵与二次型">5. 相似矩阵与二次型</h2>
<p>内积: 数量积的推广, <span class="math inline">\([A,B]=A^TB\)</span></p>
<p>长度(范数): 模的推广, <span class="math inline">\(\left|\left|x\right|\right|=\sqrt{[x,x]}\)</span></p>
<p>投影: <span class="math inline">\(c=\frac{[a,b]}{[b,b]}b\)</span></p>
<p>单位向量</p>
<p>单位化</p>
<p>夹角: <span class="math inline">\(\theta=\arccos{\frac{[x,y]}{\left|\left|x\right|\right|~\left|\left|y\right|\right|}}\)</span></p>
<h3 id="正交矩阵">正交矩阵</h3>
<p>正交: 夹角为0</p>
<p>正交向量组: 一组向量两两正交, 必定线性无关</p>
<p>标准正交基: 单位向量组成的正交向量组</p>
<p>标准正交化, 施密特正交化</p>
<p>正交(矩)阵: 单位正交向量组构成的矩阵 * <span class="math inline">\(AA^T=E=A^TA\)</span> * <span class="math inline">\(A^T=A^{-1}\)</span> * <span class="math inline">\(\left|A\right|=1或-1\)</span> * 正交矩阵的逆(转置)也是正交矩阵 * 正交矩阵的积还是正交矩阵</p>
<p>正交变换: <span class="math inline">\(若P是正交矩阵, 则线性变换y=Px称为正交变换\)</span> * 特性 * 变换前后的长度不变 <span class="math inline">\(||y||=\sqrt{y^Ty}=\sqrt{x^TP^TPx}=\sqrt{x^Tx}=||x||\)</span></p>
<h3 id="特征值和特征向量">特征值和特征向量</h3>
<p>特征多项式: <span class="math inline">\(f(\lambda)=\left|A-\lambda E\right|\)</span></p>
<p>特征值/特征向量: <span class="math inline">\(A为n阶矩阵, 满足Ax=\lambda x, (A-\lambda E)x=0的\lambda和x\)</span></p>
<p>个数: <span class="math inline">\(f(\lambda)=0是一元n次方程, \lambda必有n个根, 所以方程有n个解\)</span></p>
<h4 id="性质-6">性质</h4>
<ul>
<li>特征值之和等于矩阵的迹</li>
<li>特征值之积等于矩阵的行列式</li>
<li>矩阵多项式的特征值等于矩阵特征值的多项式: <span class="math inline">\(f(\lambda)是f(A)的特征值\)</span></li>
<li><span class="math inline">\(特征值各不相等\Rightarrow特征向量线性无关\)</span></li>
<li>对角矩阵的对角元就是其特征值</li>
</ul>
<h4 id="求法">求法</h4>
<ol type="1">
<li>根据特征多项式=0求出特征值</li>
<li>将每个特征值代回原方程, 写出特征向量(个数=n-特征值重数)</li>
</ol>
<h3 id="相似矩阵">相似矩阵</h3>
<p>相似矩阵: <span class="math inline">\(P^{-1}AP=B\)</span></p>
<p>相似变换: <span class="math inline">\(P^{-1}AP\)</span></p>
<h4 id="性质-7">性质</h4>
<ul>
<li>特征多项式(<span class="math inline">\(f(\lambda)=\left|A-\lambda E\right|\)</span>)相同</li>
<li>特征值相同</li>
<li>迹相同</li>
<li><strong>计算矩阵多项式</strong>: <span class="math inline">\(\varphi(A)=P\varphi(B)P^{-1}\)</span>
<ul>
<li>一般B是对角矩阵, 从而可以快速计算B的幂:</li>
</ul></li>
</ul>
<p><span class="math display">\[
\varphi(\Lambda)=\begin{pmatrix}
\varphi(\lambda_1)&amp;&amp;&amp;\\
&amp;\varphi(\lambda_2)&amp;&amp;\\
&amp;&amp;...&amp;\\
&amp;&amp;&amp;\varphi(\lambda_n)
\end{pmatrix}
\]</span></p>
<h4 id="对角化">对角化</h4>
<p>对角化: 寻找相似变换矩阵P来使<span class="math inline">\(P^{-1}AP=\Lambda\)</span>为对角矩阵</p>
<p>能对角化的条件: <span class="math inline">\(A有n个线性无关的特征向量\)</span> - 常用条件: - <span class="math inline">\(有n个各不相同的特征值\)</span> - <span class="math inline">\(如果特征值有重根, 则可以判断特征矩阵的秩\)</span></p>
<h4 id="对称矩阵的对角化">对称矩阵的对角化</h4>
<p>对称矩阵的性质: * 特征值为实数 * 不相等的特征值对应的特征向量正交 * 一定存在正交矩阵P使得A<strong>可以被对角化</strong>为以特征值为对角元的对角矩阵</p>
<p>求法: 1. 求出A的特征值 2. 求出所有特征向量 3. 把这些特征向量正交化, 单位化 4. 排列得到<span class="math inline">\(P\)</span>和<span class="math inline">\(\Lambda\)</span>, 注意两者对应</p>
<img src="/2021/01/08/linear-algebra/duijiaohua.png" class="">
<h3 id="二次型-标准形">二次型, 标准形</h3>
<p>二次型: 含n个变量的<strong>二次齐次</strong>函数</p>
<p><span class="math inline">\(f(x_1,x_2,...,x_n)=\sum{a_{i,j}x_{i}x_{j}}\)</span></p>
<p>标准形(法式): 只含<strong>平方项</strong>的二次型</p>
<p><span class="math inline">\(f(x_1,x_2,...,x_n)=\sum{k_{i}x_{i}^2}\)</span></p>
<p>规范形: 系数只在-1,0,1中取值的标准形</p>
<p>二次型的矩阵表示: 二次型可以用系数组成的对称矩阵唯一表示</p>
<p><span class="math display">\[
\begin{aligned}
f&amp;=\sum{a_{ij}x_{i}x_{j}}, (a_{ij}=a_{ji})\\
&amp;=\begin{pmatrix}
x_1&amp;x_2&amp;...&amp;x_n
\end{pmatrix}
\begin{pmatrix}
a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\
a_{21}&amp;a_{22}&amp;...&amp;a_{2n}\\
...&amp;...&amp;...&amp;...\\
a_{n1}&amp;a_{n2}&amp;...&amp;a_{nn}
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
...\\
x_n
\end{pmatrix}\\
&amp;=x^TAx
\end{aligned}
\]</span></p>
<p>二次型的秩: 对应矩阵的秩</p>
<h3 id="合同对角化">合同对角化</h3>
<p><strong>合同</strong>: <span class="math inline">\(若存在可逆矩阵C使得B=C^TAC, 则称B与A合同\)</span></p>
<p>性质 * 对阵矩阵的合同矩阵也对称</p>
<p><strong>合同对角化</strong>: <span class="math inline">\(寻找可逆矩阵C, 使得C^TAC为对角矩阵, 从而使二次型A通过x=Cy变换成标准形\)</span></p>
<p><span class="math display">\[
\begin{aligned}
f&amp;=x^TAx\\
&amp;=y^T(C^TAC)y
\end{aligned}
\]</span></p>
<p>可以证明(由对称矩阵性质)这个矩阵一定存在, 而且是正交矩阵, 变换后的<span class="math inline">\(C^TAC\)</span>由特征值构成</p>
<h3 id="正定二次型">正定二次型</h3>
<p>惯性定理: 同一个二次型的两种标准化结果中正负系数的个数相同</p>
<p>正(负)惯性指数: 其中的正(负)系数的个数</p>
<p>正(负)定二次型, 正(负)定矩阵: 如果二次型的值恒大(小)于零(x=0除外), 则称f为正(负)定二次型, 称A是正(负)定的 * <span class="math inline">\(正定\Leftrightarrow正惯性指数=n\Leftrightarrow特征值全正\\\Leftrightarrow各阶主子式都为正\Leftrightarrow存在可逆P,使得P^TAP=E(与E合同)\)</span> * <span class="math inline">\(负定\Leftrightarrow奇数阶主子式为负, 偶数阶为正\)</span></p>
<h2 id="线性空间与线性变换">6. 线性空间与线性变换</h2>
<p>向量空间(线性空间): 定义了线性运算且封闭, 且满足以下运算规律的非空集合 1. 加法交换律 2. 加法结合律 3. 加法零元 4. 加法逆元 5. 乘法单位元 6. 乘法交换律 7. 乘法结合律 8. 乘法对加法分配律</p>
<p>向量: 线性空间中的元素</p>
<p>子空间: 线性空间的仍是线性空间的非空子集</p>
<p>基, 维数, 坐标: 同线性空间</p>
<p>过渡矩阵 <span class="math inline">\(P=A^{-1}B\)</span></p>
<p>基变换公式, 坐标变换公式</p>
<h3 id="线性变换">线性变换</h3>
<p>映射(变换): 表示为<span class="math inline">\(\beta=T(\alpha)或\beta=T\alpha\)</span></p>
<p>定义域A, 值域B, 像集T(A): <span class="math inline">\(T(A)=\{\beta=T(\alpha)|\alpha\in A\} \subseteq B\)</span></p>
<p>线性映射(线性变换): 从Vn到Um的保持线性组合的对应关系的映射. 特别地, 如果Vn=Um, 称T为线性空间Vn中的线性变换 * <span class="math inline">\(T(a+b)=T(a)+T(b)\)</span> * <span class="math inline">\(T(\lambda b)=\lambda T(b)\)</span></p>
<p>线性变换的性质: 1. T(0)=0 2. 线性组合的变换等于变换的线性组合 3. 变换前线性相关=&gt;变换后也线性相关 4. 像集<span class="math inline">\(T(V_n)\)</span>也是线性空间, 称为<strong>像空间</strong> 5. <span class="math inline">\(N_T=\{\alpha|\alpha\in V_n, T\alpha=0\}\)</span>构成线性空间, 称为线性变换T的<strong>核</strong></p>
<h3 id="线性变换的矩阵表示">线性变换的矩阵表示</h3>
<p>线性变换的矩阵: 在Vn中取定一个基, 这个基的像的线性表示的系数矩阵称为线性变换在这个基下的矩阵, 即</p>
<p><span class="math display">\[
\left\{\begin{matrix}
T(\alpha_1)=\sum_{j=1}^{n}{a_{j1}\alpha_j}\\
T(\alpha_2)=\sum_{j=1}^{n}{a_{j2}\alpha_j}\\
...\\
T(\alpha_n)=\sum_{j=1}^{n}{a_{jn}\alpha_j}
\end{matrix}\right.
\]</span> 令 <span class="math display">\[
A=\begin{pmatrix}
a_{11}&amp; a_{12}&amp; ...&amp; a_{1n}\\  
a_{21}&amp; a_{22}&amp; ...&amp; a_{2n}\\  
:&amp; :&amp; &amp; :\\  
a_{n1}&amp; a_{n2}&amp; ...&amp; a_{nn}\\  
\end{pmatrix}\\
\]</span> 则 <span class="math display">\[
\begin{aligned}
T(\alpha_1, \alpha_2, ..., \alpha_n)&amp;=(\alpha_1, \alpha_2, ..., \alpha_n)A
\end{aligned}
\]</span></p>
<h4 id="性质-8">性质</h4>
<ul>
<li>同一个变换在不同基下的矩阵<strong>相似</strong>, 且相似变换矩阵就是两个基的过渡矩阵P</li>
</ul>
<h4 id="相似-合同与等价">相似, 合同与等价</h4>
<ul>
<li><p>等价<span class="math inline">\(\Leftrightarrow\)</span>AB秩相同</p></li>
<li><p>合同=等价+正负惯性系数相同</p></li>
<li><p>相似=合同+特征值相同+主对角线元素之和相同+矩阵的值相同</p></li>
</ul>
<p>由此可见，等价到合同到相似，条件越来越苛刻，AB共同点越来越多</p>
]]></content>
      <categories>
        <category>course-notes</category>
      </categories>
  </entry>
  <entry>
    <title>Oracle APEX学习</title>
    <url>/2020/12/07/oracle-apex/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>什么垃圾软件, 毁我人生!!</p>
<h1 id="安装">安装</h1>
<p>略</p>
<h1 id="启动">启动</h1>
<p>启动apex安装到的数据库(PDB默认不会自动open)</p>
<p>启动ords服务</p>
<p><code>$ java -jar ords.war</code></p>
<h1 id="怎么修改密码">怎么修改密码</h1>
<p><code>SQL&gt; @apxchpwd.sql</code></p>
]]></content>
      <categories>
        <category>course-notes</category>
      </categories>
  </entry>
  <entry>
    <title>Oracle数据库学习</title>
    <url>/2020/12/03/oracledb/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>参考资料:</p>
<p><a href="https://docs.oracle.com/en/database/oracle/oracle-database/index.html">Oracle官方文档</a></p>
<h1 id="schema">Schema</h1>
<p>Schema是表, 索引, 存储过程等等数据库对象(DB Object)的存储容器</p>
<p>用户与Schema之间是<strong>一对一</strong>的关系</p>
<p>例如: 访问用户A的xxx对象就通过 <code>A.xxx</code></p>
<img src="/2020/12/03/oracledb/user-schema-tables.png" class="">
<h1 id="oracle-表空间">Oracle 表空间</h1>
<p>表空间是逻辑上, 存放数据表的容器</p>
<p>每张表一定属于某个表空间</p>
<p>每个用户(Schema)可以拥有多个表空间, 而且都有一个默认表空间</p>
<p>用户之间可以通过共享表空间的方式共享数据表</p>
<p>物理上, 表空间的存储可能不是连续的</p>
<h1 id="plsql">PL/SQL</h1>
<ul>
<li>A primary benefit of PL/SQL is the ability to store application logic in the database itself.</li>
</ul>
<h1 id="oracle-体系结构-重要">Oracle 体系结构 (重要)</h1>
<ul>
<li>Oracle Server = Oracle Instance + Oracle Database</li>
</ul>
<h2 id="oracle实例-oracle-instance">1. Oracle实例 (Oracle Instance)</h2>
<p>Oracle Instance = SGA(system global area) + Background Process</p>
<p>是一组<strong>OS进程(线程)和一些内存(SGA)</strong>的总称</p>
<p>可以用来mount和open一个数据库</p>
<p>一个实例在其生存期中最多只能装载和打开一个数据库。要想再打开这个（或其他）数据库，必须先丢弃这个实例，并创建一个新的实例。</p>
<p>一个数据库实例的状态分为以下几种</p>
<ul>
<li><p><code>started</code></p></li>
<li><p><code>mounted</code></p></li>
<li><p><code>open</code></p></li>
<li><p><code>close</code></p></li>
<li><p><code>mounted</code></p></li>
<li><p><code>open</code></p></li>
</ul>
<h3 id="started-状态"><code>started</code> 状态</h3>
<p>在执行<code>startup nomount</code>命令后, Oracle会执行以下操作, 之后实例会进入<code>started</code>状态, 此时实例还未绑定数据库</p>
<ul>
<li><p>读取配置文件</p></li>
<li><p>分配<code>SGA</code></p></li>
<li><p>启动后台进程</p></li>
<li><p>打开一些用于记录的文件</p></li>
</ul>
<h3 id="mounted-状态"><code>mounted</code> 状态</h3>
<p>在执行<code>startup mount</code>或者<code>alter database mount</code>命令后, 实例会进入<code>mounted</code>状态, 对应数据库的open_mode也是<code>mounted</code>。</p>
<p>数据库打开后, 执行<code>alter database close</code>命令后, 实例也会进入<code>mounted</code>状态, 对应数据库的open_mode也是<code>mounted</code>。</p>
<p>此时实例与数据库建立了联系, 但是只有DBA能够访问数据库。</p>
<h3 id="open-状态"><code>open</code> 状态</h3>
<p>在执行<code>startup</code>或者<code>alter database open</code>命令后, 实例会进入<code>open</code>状态。</p>
<p>此时实例与数据库建立了联系, 数据库完全启动, 普通用户也可以访问数据库。</p>
<h2 id="oracle数据库-oracle-database">2. Oracle数据库 (Oracle Database)</h2>
<p>Oracle Database = Controlfile + datafile + logfile + spfile + ...</p>
<p>是存储在<strong>磁盘</strong>上的<strong>一组数据文件</strong>的集合</p>
<p>一般来说, 一个数据库上只有一个实例对其进行操作</p>
<p>但是也有例外: RAC（Real Application Clusters）就允许在集群环境中的多台计算机上操作，这样就可以有多台实例同时装载并打开一个数据库（位于一组共享物理磁盘上）</p>
<p>例外2: 容器式数据库</p>
<h2 id="oracle数据库和oracle实例的关系">3. <em>Oracle数据库</em>和<em>Oracle实例</em>的关系</h2>
<ol type="1">
<li><p>一个实例一生只能够装载及打开一个数据库</p></li>
<li><p>一个数据库能够被多个实例装载并打开(RAC)</p></li>
<li><p>每个运行着的数据库一定与至少一个实例关联</p></li>
</ol>
<img src="/2020/12/03/oracledb/instance-and-database.png" class="">
<p>Oracle数据库与实例的启动过程</p>
<img src="/2020/12/03/oracledb/startup-sequence.png" class="">
<p>Oracle数据库与实例的关闭过程</p>
<img src="/2020/12/03/oracledb/shutdown-sequence.png" class="">
<h1 id="常用命令">常用命令</h1>
<ul>
<li><p>名称, 版本信息查看</p>
<ul>
<li><p>查询数据库版本信息</p>
<pre><code>`SQL&gt; select * from v$version;`</code></pre></li>
<li><p>查看数据库名称</p>
<pre><code>`SQL&gt; show parameter db_name;`</code></pre></li>
<li><p>查看数据库服务名</p>
<pre><code>`SQL&gt; show parameter service_names;`</code></pre></li>
<li><p>查询全局数据库名称</p>
<pre><code>`SQL&gt; select * from global_name;`</code></pre></li>
</ul></li>
<li><p>数据库实例 (Instance)</p>
<ul>
<li><p>查询当前数据库实例名称</p>
<pre><code>`SQL&gt; select instance_name from v$instance;`</code></pre></li>
<li><p>查看当前数据库实例状态(open/mount等)</p>
<pre><code>`SQL&gt; select status from v$instance;`</code></pre></li>
<li><p>查看数据库实例启动时间</p>
<pre><code>`SQL&gt; SELECT TO_CHAR(STARTUP_TIME,&#39;MON-DD-RR HH24:MI:SS&#39;) AS &quot;Inst Start Time&quot; FROM V$INSTANCE;`</code></pre></li>
<li><p>创建一个新的数据库实例、加载数据库、打开数据库 (需要DBA权限)</p>
<pre><code>`SQL&gt; startup [nomount | mount | open];`</code></pre></li>
<li><p>关闭实例绑定的数据库、卸载数据库、结束当前实例 (需要DBA权限)</p>
<pre><code>`SQL&gt; shutdown [normal | transactional | immediate];`</code></pre></li>
<li><p>关闭实例绑定的数据库、卸载数据库</p>
<pre><code>`SQL&gt; alter database close;`</code></pre></li>
<li><p>加载数据库/打开数据库</p>
<pre><code>`SQL&gt; alter database [mount | open];`</code></pre></li>
</ul></li>
<li><p>数据库设置, 统计信息等</p>
<ul>
<li><p>查询数据库打开模式(mounted/open/read write)</p>
<pre><code>`SQL&gt; select open_mode from v$database;`</code></pre></li>
<li><p>查看数据库DBF文件位置</p>
<pre><code>`SQL&gt; select name from v$datafile;`</code></pre></li>
<li><p>查询数据文件状态</p>
<pre><code>`SQL&gt; select file#,name,status,enabled,checkpoint_change# from v$datafile;`</code></pre></li>
<li><p>查询数据文件位置</p>
<pre><code>`SQL&gt; select name from v$datafile;`</code></pre></li>
<li><p>查询数据文件（表空间）大小</p>
<pre><code>`SQL&gt; select sum(bytes)/1024/1024/1024 as GB from v$datafile;`</code></pre></li>
<li><p>查询有效数据大小</p>
<pre><code>`SQL&gt; select sum(bytes)/1024/1024/1024 as GB from dba_segments;`</code></pre></li>
<li><p>查看当前库的所有数据表</p>
<pre><code>`SQL&gt; select TABLE_NAME from all_tables;`</code></pre></li>
</ul></li>
<li><p>可插拔数据库 (PDB) 管理</p>
<ul>
<li><p>查看数据库是CDB还是传统DB</p>
<pre><code>`SQL&gt; select name, cdb, open_mode, con_id from v$database;`</code></pre></li>
<li><p>查看当前容器 (CDB) 名</p>
<pre><code>`SQL&gt; show con_name;`</code></pre></li>
<li><p>列举当前容器中的所有PDB以及状态</p>
<pre><code>`SQL&gt; select con_id, dbid, guid, name, open_mode from v$pdbs;`</code></pre></li>
<li><p>切换到某个PDB</p>
<pre><code>`SQL&gt; alter session set container=&lt;PDB&gt;;`</code></pre></li>
<li><p>启动PDB数据库</p>
<pre><code>`SQL&gt; alter pluggable database &lt;PDB&gt; open;`

或者

`SQL&gt; alter session set container=&lt;PDB&gt;;`
`SQL&gt; startup`</code></pre></li>
<li><p>关闭PDB数据库</p>
<pre><code>`SQL&gt; alter pluggable database &lt;PDB&gt; close;`</code></pre></li>
</ul></li>
<li><p>用户管理</p>
<ul>
<li>创建用户</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>course-notes</category>
      </categories>
  </entry>
  <entry>
    <title>软件工程</title>
    <url>/2020/12/23/software-engineer/</url>
    <content><![CDATA[<ol type="1">
<li><p>软件的本质</p>
<ol type="1">
<li>软件的本质
<ol type="1">
<li>定义
<ol type="1">
<li>有很多种定义, 以书上(P3)的定义为准, 指令的集合+数据结构+软件描述信息</li>
</ol></li>
<li>软件应用的领域
<ol type="1">
<li>系统软件/应用软件/工业软件/嵌入式软件/产品线软件/Web移动应用程序/AI软件</li>
</ol></li>
<li>遗留软件
<ol type="1">
<li>挑战:
<ol type="1">
<li>生命周期长</li>
<li>质量差</li>
<li>原有功能质量不符合现代的要求</li>
</ol></li>
<li>需要演化的情况
<ol type="1">
<li>适应性调整, 满足新的环境/技术</li>
<li>升级, 实现新的商业需求</li>
<li>拓展, 与新的系统或数据库互操作</li>
<li>改建, 适应不断演化的计算环境</li>
</ol></li>
</ol></li>
</ol></li>
<li>软件的变更本质
<ol type="1">
<li>是生命体, 在生长</li>
<li>四大类占主导地位的软件
<ol type="1">
<li>WebApp/移动App/云计算/产品线软件</li>
</ol></li>
</ol></li>
<li>软件失效率曲线
<ol type="1">
<li>理想曲线: 未知的缺陷将在软件生命周期的前期造成高失效率, 但随着错误的纠正, 曲线将趋于平缓, 软件不会磨损, 但是会退化</li>
<li>事实曲线: 软件会面临变更, 每次变更都会导致失效率陡然上升, 在曲线回到最初的状态前, 新的变化又会再次导致曲线上升, 最终导致最小的失效率点沿斜线的形状逐渐上升</li>
<li>不断的变更是导致软件失效的根本原因</li>
</ol></li>
<li>云计算
<ol type="1">
<li>应用软件: 监控/内容/协作/通信/财务</li>
<li>平台: 对象存储/身份/运行时/队列/数据库</li>
<li>基础设施: 计算/块存储/网络</li>
</ol></li>
</ol></li>
<li><p>软件工程</p>
<ol type="1">
<li><strong>软件工程的定义</strong>
<ol type="1">
<li>以书上为准 IEEE
<ol type="1">
<li>将(系统化, 规范的, 可量化的)工程化方法应用于软件的开发,运行和维护</li>
<li>对上述方法的研究</li>
</ol></li>
<li>软件工程层次
<ol type="1">
<li>工具on方法on过程on质量关注点</li>
<li>过程process
<ol type="1">
<li>包括
<ol type="1">
<li>活动activities
<ol type="1">
<li>实现宽泛的目标</li>
</ol></li>
<li>动作actions
<ol type="1">
<li>主要工作产品生产过程中的一系列任务</li>
</ol></li>
<li>任务tasks
<ol type="1">
<li>小而明确的目标, 实际产品</li>
</ol></li>
</ol></li>
<li>过程框架
<ol type="1">
<li><strong>沟通/策划/建模/构建/部署</strong></li>
<li>软件工程: 过程框架/普适性活动/框架活动i/软件工程动作i.j/任务集</li>
</ol></li>
</ol></li>
<li>方法method:</li>
<li>工具tool:</li>
</ol></li>
</ol></li>
<li><strong>软件开发神话</strong>: 为什么需要软件工程</li>
<li>注意思考题</li>
</ol></li>
<li><p>软件过程</p>
<ol type="1">
<li>通用过程框架
<ol type="1">
<li>每个框架活动由一系列动作构成, 每个动作由任务集来定义</li>
<li>任务集明确了将要完成的工作任务,将要产生的工作产品,需要的质量保证点,用于表明过程状态的里程碑</li>
</ol></li>
<li>过程流图
<ol type="1">
<li>线性过程流</li>
<li>迭代过程流</li>
<li>演化过程流</li>
<li>并行过程流</li>
</ol></li>
<li>明确任务集(细胞)
<ol type="1">
<li>注意<img src="/2020/12/23/software-engineer/3.3.png" class="" title="3.3信息栏"></li>
</ol></li>
<li>过程模式
<ol type="1">
<li>注意<img src="/2020/12/23/software-engineer/3.4.png" class="" title="3.4信息栏"></li>
<li>模板process pattern
<ol type="1">
<li>模式名称</li>
<li>驱动力</li>
<li>类型
<ol type="1">
<li>步骤模式</li>
<li>任务模式</li>
<li>阶段模式</li>
</ol></li>
<li>启动条件</li>
<li>问题</li>
<li>解决方案</li>
<li>结果</li>
<li>相关模式</li>
<li>已知应用和实例</li>
</ol></li>
</ol></li>
</ol></li>
<li><p>过程模型: 1,2个, 也可能简答题</p>
<ol type="1">
<li>分类: 传统的/敏捷的</li>
<li>各种模型的特点</li>
<li>瀑布模型是基础
<ol type="1">
<li>沟通/策划/建模/构建/部署</li>
</ol></li>
<li>V模型</li>
<li>增量模型
<ol type="1">
<li>特点
<ol type="1">
<li><strong>第一个增量是核心产品</strong></li>
</ol></li>
</ol></li>
<li>螺旋模型
<ol type="1">
<li>结合原型的选代性质和瀑布模型的可控性和系统性特点</li>
<li>特点
<ol type="1">
<li>风险识别和应对</li>
</ol></li>
</ol></li>
<li>UP统一过程
<ol type="1">
<li><img src="/2020/12/23/software-engineer/4.7.png" class="" title="4.7"></li>
</ol></li>
</ol></li>
<li><p>敏捷</p>
<ol type="1">
<li>定义</li>
<li>敏捷宣言</li>
<li>XP
<ol type="1">
<li>特征
<ol type="1">
<li>保持KIS原则</li>
<li>鼓励使用CRC</li>
<li>先单元测试后代码</li>
<li>结对编程</li>
<li>重构: 以不改变其外部功能或行为而改进设计（或源代码）的内部结构。</li>
</ol></li>
<li>用户故事: 描述将要开发的软件所需要的输出, 特征以及功能</li>
</ol></li>
<li>Scrum
<ol type="1">
<li>特征
<ol type="1">
<li>待定项backlog</li>
<li>冲刺sprint</li>
<li>每日站会</li>
</ol></li>
<li>人员
<ol type="1">
<li>Product Owner：杜老师</li>
<li>Scrum Master：邱博</li>
<li>Team：三个组员</li>
</ol></li>
<li>步骤
<ol type="1">
<li>我们首先要确定一个Product Backlog（按优先顺序排列的一个产品需求列表）</li>
<li>团队根据product backlog做工作量的估算</li>
<li>通过Sprint Planning meeting，来从中挑选出一个Story作为本次迭代完成的目标，时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog</li>
<li>在Sprint backlog再细化成更小的任务，成员领取任务（2天的工作量左右）</li>
<li>过程中要进行每日站立会议，控制在15分钟左右，汇报昨天完成了什么，今天要做什么，遇到了哪些问题</li>
<li>做到每日集成，每天都可以有一个成功编译，并且可以演示的版本。</li>
<li>当一个Story完成，业绩就是Sprint backlog完成，表示一次Sprint的完成，这时，要进行Sprint review meeting。</li>
<li>最后就是Spring Retrospective Meeting，总结会议，每个人总结并讨论改进，放入到下一次Sprint的产品需求中。</li>
</ol></li>
</ol></li>
</ol></li>
<li><p>__</p></li>
<li><p>指导实践的原则</p>
<ol type="1">
<li>软件工程知识</li>
<li>核心原则</li>
<li>指导每个框架活动的原则</li>
</ol></li>
<li><p>需求工程</p>
<ol type="1">
<li>需求工程过程: 开始/获取/细化/协商/<strong>规格说明(SRS)</strong>/确认/需求管理</li>
<li>用例模板
<ol type="1">
<li>用例</li>
<li>主/次要参与者, 使用方式</li>
<li>何时可用/使用频率</li>
</ol></li>
<li>需求的建立(开始): 利益相关者/协同合作</li>
<li>收集需求(获取)</li>
<li>开发用例: 编写<strong>用例规约</strong></li>
<li>构建<strong>分析模型</strong>:
<ol type="1">
<li>元素: 基于场景的元素(活动图)/基于类的元素(类图)/行为元素(状态图)
<ol type="1">
<li>状态图: [状态名|状态变量|状态活动]</li>
</ol></li>
</ol></li>
</ol></li>
<li><p>需求建模: 基于场景</p>
<ol type="1">
<li>域分析: 查找或创建广泛应用的分析类或分析模式, 进行复用
<ol type="1">
<li>输入: 技术资料/已有的应用系统/客户调查/专家建议/当前,未来需求</li>
<li>输出: 类的分类/复用标准/功能模型/域语言</li>
</ol></li>
<li>用例图, 活动图</li>
<li>泳道图</li>
</ol></li>
<li><p>需求建模: 类</p>
<ol type="1">
<li>识别分析类, 属性, 操作</li>
<li>语法分析法
<ol type="1">
<li>名词: 类/属性</li>
<li>动词: 操作</li>
</ol></li>
<li>CRC</li>
</ol></li>
<li><p>需求建模: 行为和模式</p>
<ol type="1">
<li>识别行为模型: 相对前面的建模是动态的</li>
<li>识别用例事件</li>
<li>状态表达:
<ol type="1">
<li><strong>状态图</strong></li>
<li>顺序图(序列图)</li>
</ol></li>
<li>Web/移动App的需求建模
<ol type="1">
<li>类型:
<ol type="1">
<li>内容模型
<ol type="1">
<li>包含所有内容对象和分析类</li>
<li></li>
</ol></li>
<li>交互模型
<ol type="1">
<li>功能, 内容和行为之间的交流</li>
<li>包括用例/时序图/状态图/UI原型</li>
</ol></li>
<li>功能模型</li>
<li>导航模型</li>
<li>配置模型</li>
</ol></li>
</ol></li>
</ol></li>
<li><p>设计</p>
<ol type="1">
<li>作用
<ol type="1">
<li>产生设计模型: 数据/类设计,体系结构设计,接口设计,构建级设计</li>
<li><img src="/2020/12/23/software-engineer/12.1.png" class=""></li>
</ol></li>
<li>设计概念定义
<ol type="1">
<li>抽象/体系结构/模式/关注点分离/模块化/信息隐蔽/功能独立/逐步求精/方面/重构/OOP/设计类/依赖倒置/测试设计</li>
</ol></li>
<li>设计模型
<ol type="1">
<li>xx设计元素: 数据/体系结构/接口/构建级/部署级</li>
</ol></li>
</ol></li>
<li><p>架构级设计</p>
<ol type="1">
<li>软件体系结构: 系统的一个或者多个结构，它包括软件构件、构件的外部可见属性以及它们之间的相互关系。</li>
<li>体系结构环境图ACD</li>
</ol></li>
<li><p>构件级设计</p>
<ol type="1">
<li>构件
<ol type="1">
<li>系统中模块化的, 可部署的和可替换的部件, 该部件封装了实现并对外提供一组接口</li>
</ol></li>
<li>设计原则
<ol type="1">
<li>OCP/LSP/DIP/ISP/REP/CCP/CRP</li>
</ol></li>
</ol></li>
</ol>
<h2 id="最后一题-uml的五类图-40分">最后一题: UML的五类图 40分</h2>
<ol type="1">
<li>用例图</li>
<li>静态图
<ol type="1">
<li>类图</li>
<li>对象图</li>
<li>包图</li>
</ol></li>
<li>行为图
<ul>
<li>状态图和活动图格式完全一样, 起点用黑点, 终点是带圈黑点</li>
<li>活动图可以带泳道</li>
</ul>
<ol type="1">
<li>状态图
<ul>
<li>仅为那些有多个状态其行为受外界环境的影响并且发生改变的类画状态图</li>
<li><img src="/2020/12/23/software-engineer/state_diagram.png" class=""></li>
</ul></li>
<li>活动图
<ul>
<li><img src="/2020/12/23/software-engineer/activity_diagram.png" class=""></li>
</ul></li>
</ol></li>
<li>交互图
<ol type="1">
<li>顺序图(序列图)
<ul>
<li>强调时间和顺序</li>
<li><img src="/2020/12/23/software-engineer/sequence_diagram.png" class=""></li>
</ul></li>
<li>协作图(通讯图)
<ul>
<li>强调上下级关系</li>
<li><img src="/2020/12/23/software-engineer/comm_diagram.png" class=""></li>
</ul></li>
</ol></li>
<li>实现图
<ol type="1">
<li>构件图
<ul>
<li><img src="/2020/12/23/software-engineer/comp_diagram.png" class=""></li>
</ul></li>
<li>配置图
<ul>
<li><img src="/2020/12/23/software-engineer/deploy_diagram.png" class=""></li>
</ul></li>
</ol></li>
</ol>
<p>CMM: 一级为初始级，二级为可重复级，三级为已定义级，四级为已管理级，五级为优化级</p>
<p>P179 构建细化</p>
]]></content>
      <categories>
        <category>course-notes</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统基础</title>
    <url>/2024/04/04/distributed-system/</url>
    <content><![CDATA[<h1 id="为什么需要分布式系统">为什么需要分布式系统</h1>
<p>单点故障，分布式增加冗余提高系统的可用性</p>
<h1 id="分布式系统存在的问题">分布式系统存在的问题</h1>
<h2 id="cap-定理">CAP 定理</h2>
<p>对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li>一致性 (Consistency): 所有节点都能够访问到同一份最新的数据副本或者错误。</li>
<li>可用性 (Availability): 每次请求都能获取到非错误响应，但不保证获取的数据为最新数据。</li>
<li>分区容错性 (Partition tolerance): 在节点之间的网络通信出现故障的情况下，系统仍能继续运行。</li>
</ul>
<p>分析:</p>
<ul>
<li>网络故障必定存在，如果一发生网络分区整个系统就不可用，是没有意义的。因此分布式系统必须首先要保证P性质，接下来有两个选择: C或者A。</li>
<li>如果选择 C 一致性，则当网络分区无法保证数据是最新的时候，系统就会返回错误或者超时，即不可用。</li>
<li>如果选择 A 可用性，则系统始终尝试返回信息的最新版本，但是无法保证是最新的。</li>
</ul>
<h2 id="base-碱-语义">BASE (碱) 语义</h2>
<p>分布式系统的一种用于实现高可用性的一致性模型，弱化一致性的承诺，保证可用性，因此属于AP的一种拓展。</p>
<ul>
<li>基本可用 (Basically Available): 读写操作尽可能是可用的，但是不保证一致性 (在冲突的情况下，写值可能不会成功; 读值可能不是最新的)</li>
<li>软状态 (Soft-state): 没有强一致性保证。</li>
<li>最终一致性 (Eventually consistent): 系统运行足够长的时间后，多个节点最终会达到一致。</li>
</ul>
<h2 id="c-与-a-如何取舍">C 与 A 如何取舍</h2>
<ol type="1">
<li>选择一致性: 对一致性要求较高的系统，例如:</li>
</ol>
<p>传统ACID数据库，服务注册中心 (Etcd, Zookeeper, Nacos)，HBase，金融系统，银行系统，与钱相关的</p>
<ol start="2" type="1">
<li>选择可用性:</li>
</ol>
<p>Eureka，Redis 集群，Nacos配置中心</p>
]]></content>
      <categories>
        <category>distributed-system</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期实习 - 面试准备</title>
    <url>/2024/04/07/interview/</url>
    <content><![CDATA[<h2 id="leetcode">Leetcode</h2>
<ul>
<li>链表 ✅</li>
<li>dp ✅</li>
<li>排列组合 ❓</li>
<li>大数模运算 ❓</li>
<li>图算法 ❓</li>
<li>数论 ❓</li>
<li>字符串 ❓</li>
</ul>
<h2 id="杂项">杂项</h2>
<ul>
<li>自我介绍 ✅</li>
<li>开放性问题
<ul>
<li>项目中遇到的困难问题</li>
<li>最近关注的新技术</li>
<li>最近读了什么书
<ul>
<li>高性能MySQL</li>
<li>设计数据密集型应用 DDIA</li>
</ul></li>
<li>还在面其他的什么公司没</li>
<li>职业规划</li>
<li>优点
<ul>
<li>实事求是</li>
</ul></li>
<li>缺点
<ul>
<li>i人 有时喜欢自闭</li>
</ul></li>
<li>印象最深的事情
<ul>
<li></li>
</ul></li>
<li>烦恼
<ul>
<li>有点i</li>
</ul></li>
<li>最大的挫折
<ul>
<li>论文被拒</li>
</ul></li>
<li>朋友评价
<ul>
<li>有责任感</li>
<li>能力强</li>
<li>热心 乐于助人</li>
<li>有点i</li>
</ul></li>
<li>激发
<ul>
<li>挑战</li>
<li>成就</li>
</ul></li>
<li>动机
<ul>
<li>发挥特长 收获满足</li>
</ul></li>
</ul></li>
<li>什么时间可以入职
<ul>
<li>25.3 毕业</li>
<li>6月份~毕业</li>
<li>杭州!</li>
</ul></li>
<li>反问问题
<ul>
<li>面试表现如何</li>
<li>还需要加强哪些方面</li>
<li>实习生培养</li>
<li>对于实习生的期望</li>
<li>转正率有多少 (一般不回答)</li>
</ul></li>
</ul>
<h2 id="智力题">智力题</h2>
<ul>
<li>高楼扔鸡蛋</li>
<li>老鼠喝毒药</li>
<li>海盗分金</li>
<li>博弈论
<ul>
<li>两个人轮流拿1或2或3个的石头，怎么能保证拿到最后一个</li>
</ul></li>
</ul>
<h2 id="计算机基础">计算机基础</h2>
<h3 id="数据结构">数据结构 ✅</h3>
<ul>
<li>哈希表
<ul>
<li>冲突解决
<ul>
<li>开链法
<ul>
<li>链表</li>
<li>JDK&gt;=8 红黑树</li>
</ul></li>
<li>开放寻址
<ul>
<li>线性探测法</li>
<li>二次探测法</li>
</ul></li>
<li>再哈希</li>
</ul></li>
<li>扩缩容
<ul>
<li>负载因子 = 元素个数 / 桶个数
<ul>
<li>JDK默认 &gt;0.75 扩容</li>
<li>Redis &lt;0.1 缩容</li>
</ul></li>
<li>Redis - 渐进式Rehash
<ul>
<li>防止扩容时key过多导致卡顿</li>
<li>懒迁移</li>
</ul></li>
<li>HashMap 一次性完成</li>
</ul></li>
</ul></li>
<li>AVL</li>
<li>Rb-tree</li>
<li>B树 B+树
<ul>
<li>+节点密度大, 3层能存2kw数据, 需要的IO少</li>
<li>-节点分裂合并复杂</li>
<li>使用场景
<ul>
<li>MySQL索引</li>
</ul></li>
</ul></li>
<li>SkipList
<ul>
<li>查找,插入 O(logn)</li>
<li>+编写简单</li>
<li>+插入删除更简单</li>
<li>-2kw需要24层, 查询需要的跳转/IO次数多</li>
<li>使用场景
<ul>
<li>Redis</li>
<li>RocksDB</li>
<li>Lucene &amp; ElasticSearch</li>
</ul></li>
</ul></li>
<li>堆</li>
</ul>
<h3 id="算法">算法 ❓</h3>
<ul>
<li>排序算法
<ul>
<li>选择排序</li>
<li>插入排序 (打牌) 稳</li>
<li>冒泡排序 稳</li>
<li>快速排序</li>
<li>归并排序 稳</li>
<li>桶排序</li>
<li>堆排序</li>
<li>基数排序 稳</li>
<li>希尔排序</li>
<li>稳定 &amp; 不稳定</li>
<li>STL -&gt; timsort</li>
<li>Java -&gt;</li>
</ul></li>
</ul>
<p>排序方法 平均 好 坏 空间 稳定性 插入排序 n² n n² O(1) 稳 希尔排序 n² n n² O(1)<br />
选择排序 n² n² n² O(1)<br />
冒泡排序 n² n n² O(1) 稳 堆排序 nlogn nlogn nlogn O(1)<br />
快速排序 nlogn nlogn n² nlogn<br />
归并排序 nlogn nlogn nlogn n 稳 基数排序 O(d(r+n)) O(d(n+rd)) O(d(r+n)) O(rd+n) 稳</p>
<ul>
<li>布隆过滤器
<ul>
<li>key -&gt; hash到多个key</li>
<li>快速判断元素是否存在于某个集合里面</li>
</ul></li>
</ul>
<h3 id="体系结构">体系结构 ❓</h3>
<ul>
<li>MMU
<ul>
<li>位于CPU芯片内部</li>
<li>将CPU请求的虚拟地址翻译成物理地址</li>
<li>TLB
<ul>
<li>缓存了当前进程使用的页表项(PTE)</li>
<li>在MMU旁边 被MMU使用</li>
</ul></li>
</ul></li>
<li>CPU Cache
<ul>
<li>速度
<ul>
<li>L1: 1ns</li>
<li>L2: 4ns</li>
<li>Memory: 100ns</li>
</ul></li>
<li>拓扑
<ul>
<li>Write Through: 写内存同时写Cache</li>
<li>Write Back: 写Cache, 异步写内存</li>
</ul></li>
<li>多核缓存一致性
<ul>
<li>MESI协议 ❓</li>
<li>MOESI协议 ❓</li>
</ul></li>
</ul></li>
<li>内存栅栏 ❓</li>
<li>NUMA
<ul>
<li>UMA 多核对称</li>
<li>NUMA 多核不对称</li>
</ul></li>
</ul>
<h3 id="操作系统">操作系统 ✅</h3>
<ul>
<li>Socket</li>
<li>文件系统</li>
<li>Shell命令 ✅</li>
<li>CPU管理
<ul>
<li>进程 线程 协程
<ul>
<li>进程
<ul>
<li>资源分配单位</li>
<li>有自己的地址空间 堆 PCB 页表 文件表 信号处理</li>
</ul></li>
<li>线程
<ul>
<li>执行和调度单位</li>
<li>有自己的栈 寄存器</li>
</ul></li>
<li>协程
<ul>
<li>用户态模拟的线程</li>
<li>程序自己控制切换</li>
</ul></li>
</ul></li>
<li>进程状态
<ul>
<li>R: Running 可被调度</li>
<li>S: Sleeping 等待中 可以被信号等中断</li>
<li>D: Sleeping 系统调用中 不可被中断</li>
<li>T: Stopped 收到了SIGSTOP/SIGCONT继续</li>
<li>Z: Zombies 进程已结束 但在等待父进程读取状态</li>
<li>X: Dead 已经退出</li>
</ul></li>
<li>孤儿进程: 父进程退出</li>
<li>进程文件: lsof, /proc/fd/fd</li>
<li>调度算法
<ul>
<li>FCFS</li>
<li>SPF</li>
<li>RR</li>
<li>多级队列</li>
</ul></li>
<li>进线程切换
<ul>
<li>上下文切换</li>
<li>特权级切换</li>
<li>页表切换
<ul>
<li>刷新TLB</li>
</ul></li>
</ul></li>
<li>进程间通信
<ul>
<li>管道/FIFO</li>
<li>信号</li>
<li>uds</li>
<li>共享内存 shm{get,at}()</li>
<li>消息队列 msg{get,snd,rcv}()</li>
<li>信号量 sem{init,post,wait}()</li>
</ul></li>
</ul></li>
<li>锁
<ul>
<li>mutex</li>
<li>semaphore</li>
<li>原子变量</li>
<li>条件变量</li>
<li>volatile</li>
<li>CAS
<ul>
<li>ABA问题</li>
</ul></li>
<li>死锁</li>
</ul></li>
<li>内存管理
<ul>
<li>为什么需要段页
<ul>
<li>-如果连续分配内存会导致碎片</li>
</ul></li>
<li>段式内存管理
<ul>
<li>段表 段权限</li>
<li>-外碎片</li>
</ul></li>
<li>页式内存管理 x86-64
<ul>
<li>4k固定大小 页权限</li>
<li>+缓解外碎片 提高内存使用效率</li>
<li>-内碎片</li>
<li>缺页中断</li>
<li>换页算法
<ul>
<li>LRU</li>
<li>LFU</li>
<li>FIFO</li>
</ul></li>
</ul></li>
<li>段页结合
<ul>
<li>段表+页号+偏移</li>
<li>-&gt; 页表+页号+偏移</li>
<li>-&gt; 地址</li>
</ul></li>
<li>Linux实际上跳过段机制</li>
</ul></li>
</ul>
<h3 id="oop-设计模式">OOP &amp; 设计模式 ❓</h3>
<ul>
<li>封装 继承 多态</li>
<li>继承的缺点
<ul>
<li>不够灵活 随着项目发展 不利于重构</li>
<li>会有菱形继承问题</li>
<li>golang Rust等很多语言去掉继承</li>
</ul></li>
<li>重载</li>
<li>工厂模式</li>
<li>单例模式</li>
<li>Builder模式</li>
<li>代理模式</li>
<li>适配器模式</li>
</ul>
<h3 id="计算机网络">计算机网络 ❓</h3>
<ul>
<li>OSI七层
<ul>
<li>L7 应用层</li>
<li>L6 表示层</li>
<li>L5 会话层</li>
<li>L4 传输层</li>
<li>L3 网络层</li>
<li>L2 数据链路层</li>
<li>L1 物理层</li>
</ul></li>
<li>OSI五层</li>
<li>交换机 路由器</li>
<li>常见的网络协议
<ul>
<li>MAC</li>
<li>TCP/UDP</li>
<li>SSH</li>
<li>FTP</li>
<li>ARP</li>
</ul></li>
<li>IP协议 网络层
<ul>
<li>IP头 20字节 源ip 目标ip</li>
<li>ARP
<ul>
<li>广播 ARP 请求 询问</li>
<li>ARP 欺骗</li>
</ul></li>
<li>ICMP ping</li>
<li>DHCP</li>
<li>NAT</li>
</ul></li>
<li>TCP协议 传输层
<ul>
<li>可靠 点对点 字节流 面向连接 20字节</li>
<li>源port 目标port seq ack 长度 标志</li>
<li>可靠性保证 ❓
<ul>
<li>序列号 确认机制</li>
<li>超时重传</li>
<li>...</li>
<li>握手流程
<ul>
<li>第二次握手重试</li>
</ul></li>
<li>挥手流程
<ul>
<li>主动方 TIME_WAIT 等待2MSL ❓
<ul>
<li>保证对端正确断开</li>
<li>保证本次连接所有报文都过期 不影响下次连接</li>
</ul></li>
</ul></li>
<li>保活机制 (Linux SO_KEEPALIVE) 非标准 ❓</li>
</ul></li>
<li>流量控制 ❓
<ul>
<li>侧重按照接收者的接收能力来发送数据</li>
<li>发送 接收 滑动窗口
<ul>
<li>Selective ACK 额外回复收到了哪些段数据</li>
<li>Duplicate ACK 额外回复哪些段数据重复接收</li>
<li>Nagle算法 接收窗口太小时 累计一定数据后(MSS)再发送
<ul>
<li>-实时性变差</li>
<li>TCP_NODELAY 关闭</li>
</ul></li>
<li>延迟ACK 组合多个ACK为一个
<ul>
<li>-实时性变差</li>
<li>TCP_QUICKACK 关闭</li>
</ul></li>
</ul></li>
</ul></li>
<li>拥塞控制 ❓
<ul>
<li>侧重避免网络出现负载过大的情况</li>
<li>慢启动 指数增加</li>
<li>拥塞避免 线性增加</li>
<li>拥塞发生 超时重传 RTO指数倍增 保险 回到起点</li>
<li>快速恢复 快速重传 收到了3ACK 没超时但是重传</li>
<li>BBR拥塞控制算法 ❓</li>
</ul></li>
<li>调优选项
<ul>
<li>TCP Fast Open(TFO)
<ul>
<li>第二次连接 通过TFO cookie省略一个RTT</li>
</ul></li>
<li>tcp_tw_recycle
<ul>
<li>TIME_WAIT状态快速回收</li>
</ul></li>
<li>tcp_tw_reuse
<ul>
<li>复用TIME_WAIT状态的连接</li>
<li>依赖 tcp_timestamps 启用时间戳</li>
</ul></li>
</ul></li>
<li>缺陷
<ul>
<li>-队头阻塞: 中间丢包导致后面阻塞</li>
<li>-不支持网络迁移</li>
</ul></li>
<li>网络攻击
<ul>
<li>syn flood
<ul>
<li>服务器只收到SYN -&gt; SYN_RCVD 半连接</li>
<li>增大半连接队列</li>
<li>syn cookie</li>
</ul></li>
</ul></li>
<li>应用问题
<ul>
<li>对端断电 保持ESTABLISHED状态
<ul>
<li>对端退出 FIN</li>
<li>对端重启 RST</li>
</ul></li>
<li>大量SYN_RCVD (等待对方第三次握手)
<ul>
<li>缩短超时 (SYN Timeout) 时间</li>
<li>增大半连接队列</li>
<li>SYN cookie 技术
<ul>
<li>自己不再分配内存记录 而是将信息保存到第二次握手回复中</li>
<li>等第三次握手再获取这个信息</li>
</ul></li>
</ul></li>
<li>大量CLOSE_WAIT (等待我方close())
<ul>
<li>对端shutdown 自己没有shutdown</li>
</ul></li>
<li>大量TIME_WAIT (先关闭方 等待第四次的ack彻底过期)
<ul>
<li>确保应用层使用长连接 Connection: Keep-Alive
<ul>
<li>设置长连接超时时间</li>
</ul></li>
<li>使用 tcp_tw_reuse 和 timestamp</li>
<li>增大 tcp_max_tw_buckets 默认18000</li>
<li>SO_LINGER: 用 RST 代替 FIN, 不安全</li>
</ul></li>
</ul></li>
</ul></li>
<li>QUIC协议 传输层
<ul>
<li>基于UDP实现可靠传输 旨在取代TCP</li>
<li>+单连接传输多个流 避免队头阻塞</li>
<li>+握手过程集成TLS 节约连接设置的开销</li>
<li>+包含连接ID 支持底层网络切换</li>
</ul></li>
<li>UDP协议 传输层
<ul>
<li>无状态 面向报文 8字节</li>
</ul></li>
<li>HTTP协议
<ul>
<li>0.9</li>
<li>1.0</li>
<li>1.1
<ul>
<li>Keep-Alive 默认开启
<ul>
<li>Connection: close 服务器回完resp就close
<ul>
<li>容易导致TIME_WAIT</li>
</ul></li>
</ul></li>
<li>流水线
<ul>
<li>-HTTP队头阻塞</li>
</ul></li>
</ul></li>
<li>2.0 ❓
<ul>
<li>http请求头压缩编码</li>
<li>二进制帧 请求头可以二进制</li>
<li>引入流 可以单连接传输多个流</li>
<li>服务器推送</li>
<li>-TCP队头阻塞</li>
</ul></li>
<li>3.0 ❓
<ul>
<li>底层TCP-&gt;QUIC</li>
</ul></li>
<li>报文格式
<ul>
<li>GET / HTTP/1.1: xxx.com</li>
<li>HTTP/1.1 200 OK-Type: application/json</li>
</ul></li>
<li>状态码
<ul>
<li>101 Switch</li>
<li>200 OK</li>
<li>301 Moved Permanently</li>
<li>302 Found</li>
<li>400 Bad Request</li>
<li>403 Forbidden</li>
<li>404 Not Found</li>
<li>500 Server Error</li>
<li>502 Bad Gateway</li>
</ul></li>
<li>请求方法</li>
<li>请求头</li>
<li>缓存控制</li>
</ul></li>
<li>DNS协议 应用层
<ul>
<li>over UDP
<ul>
<li>DOH DOT DOQ</li>
</ul></li>
<li>本地域名服务器
<ul>
<li>递归解析</li>
</ul></li>
<li>根域名服务器
<ul>
<li>DNS 劫持</li>
<li>DNS 放大
<ul>
<li>假装受害者发起大量DNS查询请求</li>
</ul></li>
<li>DNS flood</li>
</ul></li>
</ul></li>
<li>SSL/TLS协议 应用层和传输层之间/会话层
<ul>
<li>建立流程 四次握手 ❓
<ul>
<li>ClientHello - ServerHello</li>
<li>KeyExchange - Finished</li>
</ul></li>
<li>密钥协商</li>
<li>对称加密</li>
<li>证书机制</li>
<li>中间人攻击</li>
</ul></li>
<li>RPC
<ul>
<li>一种调用方式</li>
<li>没有http的条条框框 效率更高</li>
<li>可以定制 例如使用protobuf thrift</li>
<li>一般基于tcp实现 也有基于http2.0</li>
</ul></li>
<li>WebSocket
<ul>
<li>HTTP长连接</li>
<li>HTTP长轮询</li>
</ul></li>
<li>扫码登录</li>
</ul>
<h3 id="软件测试">软件测试</h3>
<ul>
<li>单元测试框架
<ul>
<li>CppUnit</li>
<li>GTest</li>
</ul></li>
<li>压测
<ul>
<li>TCP压测 iperf3</li>
<li>HTTP压测 wrk</li>
</ul></li>
</ul>
<h3 id="编译原理">编译原理</h3>
<ul>
<li>编译器过程</li>
<li>C/C++编译过程</li>
</ul>
<h2 id="语言">语言</h2>
<h3 id="java">Java ❓</h3>
<ul>
<li><p>基本数据类型</p>
<ul>
<li>int vs Integer</li>
</ul></li>
<li><p>抽象类 接口</p></li>
<li><p>重载 重写</p></li>
<li><p>字符串处理</p></li>
<li><p>Collections ✅</p>
<ul>
<li>HashMap 线程安全
<ul>
<li>x2扩容</li>
<li>get() ❓</li>
<li>put() ❓</li>
</ul></li>
<li>HashTable</li>
<li>Vector</li>
<li>LinkedList</li>
<li>ArrayList
<ul>
<li>x1.5扩容</li>
</ul></li>
</ul></li>
<li><p>Comparable</p></li>
<li><p>面向对象特性</p>
<ul>
<li>Object类
<ul>
<li>析构 finalize()</li>
<li>复制 clone()</li>
<li>容器 hashCode() equals()
<ul>
<li>equals() 默认实现比较引用是否相同</li>
</ul></li>
<li>反射 getClass()</li>
<li>字符串 toString()</li>
<li>同步相关 wait() notify() notifyAll()
<ul>
<li>wait() 让持有此对象的监视器的线程等待</li>
<li>notify() 唤醒</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>并发 ❓</p>
<ul>
<li>ThreadLocal</li>
<li>Lock</li>
<li>synchronized
<ul>
<li>修饰方法</li>
<li>修饰代码块</li>
<li>持有对象的锁</li>
</ul></li>
<li>volatile</li>
<li>JUC</li>
<li>线程</li>
<li>线程池
<ul>
<li>创建线程开销大</li>
<li>状态
<ul>
<li>RUNNING</li>
<li>SHUTDOWN</li>
<li>STOP</li>
<li>TERMINATED</li>
</ul></li>
<li>参数调优
<ul>
<li>CPU密集: n+1</li>
<li>IO密集: 2n</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>反射</p></li>
<li><p>JVM ❓</p>
<ul>
<li>内存结构 ❓
<ul>
<li>堆结构</li>
</ul></li>
<li>垃圾回收GC ❓
<ul>
<li>CMS
<ul>
<li>Minor GC</li>
<li>Full GC</li>
</ul></li>
<li>ZGC</li>
</ul></li>
</ul></li>
<li><p>JDBC</p></li>
</ul>
<h3 id="cc">C/C++ ❓</h3>
<ul>
<li>malloc
<ul>
<li>sbrk() mmap()</li>
<li>ptmalloc glibc</li>
<li>jemalloc Facebook</li>
<li>tcmalloc Google
<ul>
<li>thread cache</li>
</ul></li>
</ul></li>
<li>编译
<ul>
<li>工具
<ul>
<li>cmake</li>
<li>meson</li>
<li>makefile/ninja</li>
<li>gradle</li>
</ul></li>
</ul></li>
<li>编译和链接
<ul>
<li>变量位置
<ul>
<li>局部变量 栈上</li>
<li>全局 静态变量 零初始化bss 否则data</li>
</ul></li>
</ul></li>
<li>STL容器
<ul>
<li>vector
<ul>
<li>扩容 VSx1.5 GCCx2
<ul>
<li>x2会导致重新分配</li>
</ul></li>
</ul></li>
<li>map/set</li>
<li>unordered_map/set</li>
<li>list</li>
</ul></li>
<li>引用</li>
<li>OOP
<ul>
<li>类
<ul>
<li>构造 析构</li>
<li>复制 移动</li>
<li>类 vs 结构体
<ul>
<li>类默认private 结构体默认public</li>
</ul></li>
<li>空类 1字节</li>
</ul></li>
<li>封装
<ul>
<li>保护级别</li>
<li>friend</li>
</ul></li>
<li>继承
<ul>
<li>保护级别 区别</li>
<li>虚继承
<ul>
<li>防止菱形继承</li>
<li>使得虚函数表更加复杂 且内存布局变化</li>
</ul></li>
</ul></li>
<li>多态
<ul>
<li>虚函数
<ul>
<li>构造函数不能是虚函数</li>
<li>基类析构函数必须是虚函数</li>
<li>虚函数实现
<ul>
<li>抽象类
<ul>
<li>有虚函数</li>
<li>不可以被new</li>
</ul></li>
<li>虚函数表
<ul>
<li>每个类一个 编译器分配</li>
<li>每个对象有一个隐式的虚表指针成员</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>C++11
<ul>
<li>move() forward()</li>
</ul></li>
<li>C++20 协程</li>
<li>四种cast
<ul>
<li>static_cast</li>
<li>const_cast</li>
<li>reinterpret_cast</li>
<li>dynamic_cast</li>
</ul></li>
<li>异常
<ul>
<li>构造函数抛异常</li>
<li>析构函数抛异常</li>
<li>new抛异常</li>
</ul></li>
<li>智能指针
<ul>
<li>unique_ptr
<ul>
<li>内部: 对象指针</li>
</ul></li>
<li>shared_ptr &amp; weak_ptr
<ul>
<li>内部: 对象指针, &amp;use_count, &amp;weak_count, (可选)Mutex</li>
<li>多个共享指针持有同一个控制块</li>
<li>make_shared 创建智能指针</li>
<li>: public shared_from_this
<ul>
<li>内部: 一个 weak_ptr(this)</li>
</ul></li>
</ul></li>
<li>auto_ptr</li>
<li>实现
<ul>
<li>原子变量</li>
<li>引用计数</li>
</ul></li>
</ul></li>
<li>并发
<ul>
<li>原子操作
<ul>
<li>i++ 不是原子</li>
</ul></li>
<li>volatile
<ul>
<li>标记变量可能被未知的因素更改</li>
<li>避免激进的优化 每次都去读内存</li>
</ul></li>
</ul></li>
<li>malloc</li>
</ul>
<h3 id="golang">Golang</h3>
<ul>
<li>GMP模型
<ul>
<li>G 协程</li>
<li>M OS线程</li>
<li>P CPU核</li>
</ul></li>
<li>避免共享内存 使用通信</li>
<li>defer语法</li>
</ul>
<h3 id="javascript">JavaScript</h3>
<h3 id="rust">Rust ❓</h3>
<ul>
<li>OwnerShip</li>
<li>Lifetime</li>
<li>泛型</li>
<li>trait</li>
<li>Tokio异步
<ul>
<li>异步任务</li>
</ul></li>
<li>比c/c++的优势
<ul>
<li>内存安全</li>
</ul></li>
<li>Unsafe
<ul>
<li>有时候安全更重要</li>
</ul></li>
</ul>
<h2 id="linux">Linux</h2>
<ul>
<li>文件
<ul>
<li>一切皆文件</li>
<li>类型
<ul>
<li>Regular</li>
<li>Directory</li>
<li>Link</li>
<li>Char Dev</li>
<li>Block Dev</li>
<li>Socket</li>
<li>Pipe</li>
</ul></li>
<li>inode
<ul>
<li>内容
<ul>
<li>大小</li>
<li>权限</li>
<li>所有者</li>
<li>三个时间</li>
<li>链接数</li>
</ul></li>
</ul></li>
<li>打开文件: path-&gt;inode-&gt;block</li>
</ul></li>
<li>锁
<ul>
<li>自旋锁 spinlock
<ul>
<li>-饥饿</li>
</ul></li>
<li>Rwlock</li>
<li>seqlock</li>
<li>RCU</li>
<li>futex ❓</li>
</ul></li>
<li>ELF
<ul>
<li>结构
<ul>
<li>ELF头</li>
<li>Program HT程序头</li>
<li>Section HT节数组</li>
</ul></li>
<li>静态链接
<ul>
<li></li>
</ul></li>
<li>动态链接
<ul>
<li>链接
<ul>
<li>加载libc.so</li>
<li></li>
</ul></li>
<li>装载
<ul>
<li>dl{open,sym,close}()</li>
</ul></li>
</ul></li>
</ul></li>
<li>PIE vs PIC</li>
<li>IO多路复用
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul></li>
<li>零拷贝
<ul>
<li>内核态only 减少切换次数: sendfile, splice</li>
<li>利用 DMA</li>
<li>COW</li>
<li>用户态IO: SPDK, DPDK</li>
</ul></li>
<li>Coredump</li>
<li>链接与库
<ul>
<li>静态链接</li>
<li>动态链接</li>
<li>装载</li>
</ul></li>
<li>运维命令
<ul>
<li>负载
<ul>
<li>uptime</li>
<li>vmstat</li>
<li>top</li>
</ul></li>
<li>网络
<ul>
<li>netstat</li>
<li>ss</li>
</ul></li>
<li>内存
<ul>
<li>sar</li>
</ul></li>
</ul></li>
<li>缓存 ❓
<ul>
<li>kswapd</li>
<li>硬盘 Page Cache</li>
<li>File Cache</li>
</ul></li>
<li>I/O 模型
<ul>
<li>Reactor 对IO事件反应
<ul>
<li>单线程</li>
<li>多线程</li>
</ul></li>
<li>Proactor</li>
</ul></li>
<li>UDS vs TCP</li>
<li>connect() 系统调用实现</li>
<li>上下文切换
<ul>
<li>X86 Gate</li>
</ul></li>
<li>硬件中断
<ul>
<li>顶半部 底半部</li>
<li>软件中断
<ul>
<li>softirq</li>
<li>tasklet</li>
<li>workqueue</li>
</ul></li>
</ul></li>
<li>CPU调度
<ul>
<li>时机
<ul>
<li>时钟中断 时间片用完</li>
<li>系统调用</li>
</ul></li>
</ul></li>
<li>tcpdump
<ul>
<li>eBPF
<ul>
<li>嵌入内核的虚拟机</li>
<li>Hook内核API</li>
</ul></li>
</ul></li>
</ul>
<h2 id="mysql">MySQL ❓</h2>
<ul>
<li>SQL 基本
<ul>
<li>语句</li>
<li>SQL注入
<ul>
<li>PreparedStatement</li>
<li>WAF过滤</li>
</ul></li>
</ul></li>
<li>数据类型</li>
<li>范式 ❓
<ul>
<li>第一范式 列不可分</li>
<li>第二范式 非主属性完全函数依赖于主键</li>
<li>第三范式 非主属性既不部分依赖于主键也不传递依赖于主键</li>
<li>BC范式 不允许主键的一部分被另一部分或其它部分决定</li>
</ul></li>
<li>引擎
<ul>
<li>MyISAM
<ul>
<li>+插入, 查询性能</li>
<li>-只有表锁</li>
<li>-不支持外键</li>
<li>-不支持事务</li>
<li>适合非事务型负载 OLAP?</li>
</ul></li>
<li>InnoDB
<ul>
<li>+行锁</li>
<li>+聚簇索引</li>
<li>+支持外键</li>
<li>+支持事务</li>
</ul></li>
<li>底层存储
<ul>
<li>MyISAM
<ul>
<li>数据.myd和索引.myi分开存储</li>
<li>数据按插入顺序存储</li>
<li>索引B+树叶子节点存数据行号 -&gt; 没有聚簇索引</li>
</ul></li>
<li>InnoDB
<ul>
<li>数据和索引保存在一起</li>
<li>主索引B+树叶子节点存数据本身 -&gt; 聚簇索引</li>
<li>需要一个主key 没有会自己创建</li>
</ul></li>
</ul></li>
<li>区别</li>
</ul></li>
<li>索引 ❓❓
<ul>
<li>优缺点
<ul>
<li>+加快速度</li>
<li>-空间开销</li>
<li>-维护索引开销</li>
</ul></li>
<li>索引类型
<ul>
<li>hash索引
<ul>
<li>-范围查询</li>
<li>-模糊查询</li>
<li>-联合索引 最左匹配</li>
</ul></li>
<li>Btree索引</li>
<li>Fulltext索引
<ul>
<li>+查询文本中的关键字</li>
<li>模糊匹配
<ul>
<li>like '%abc%' 场景</li>
</ul></li>
</ul></li>
<li>Rtree索引
<ul>
<li>+地理数据范围查询</li>
</ul></li>
</ul></li>
<li>聚簇索引
<ul>
<li>聚簇索引
<ul>
<li>数据和索引放在一起存储 索引的叶子节点保存数据</li>
<li>相对的 其他索引叫做二级索引</li>
<li>举例 InnoDB</li>
</ul></li>
<li>非聚簇索引
<ul>
<li>数据和索引分开存储 索引的叶子节点保存数据行号</li>
<li>举例 MyISAM</li>
</ul></li>
</ul></li>
<li>覆盖索引
<ul>
<li>查询结果都包含在索引中</li>
<li>不需要回表</li>
</ul></li>
<li>最左匹配原则</li>
<li>索引失效的场景
<ul>
<li>like '%abc' '%abc%'</li>
<li>使用了表达式/函数/UDF</li>
<li>包含隐式类型转换</li>
<li>非前缀匹配</li>
<li>OR单边索引</li>
</ul></li>
<li>索引使用原则
<ul>
<li>经常查询的where条件</li>
<li>长串索引需要限定前缀长度 看区分度</li>
</ul></li>
</ul></li>
<li>优化
<ul>
<li>查询慢
<ul>
<li>缺少索引</li>
</ul></li>
<li>插入慢
<ul>
<li>索引太多</li>
</ul></li>
<li>show_query_log 定位慢查询</li>
<li>explain
<ul>
<li>"Using index" = 使用了覆盖索引</li>
<li>"type: ALL" = 全表扫描</li>
<li>"key: xxxx" = 使用了xxxx索引</li>
</ul></li>
<li>optimize table 碎片整理</li>
</ul></li>
<li>事务 ✅
<ul>
<li>概念</li>
<li>ACID ✅
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul></li>
<li>问题 ❓
<ul>
<li>脏读</li>
<li>不可重复读: 在同一个事务中，多次读取同一数据返回的结果有所不同</li>
<li>幻读: 一个事务读取了另一个事务插入的新纪录</li>
<li>丢失修改</li>
</ul></li>
<li>MySQL 如何保证 ACID ❓❓
<ul>
<li>保证原子性A
<ul>
<li>Undo log</li>
</ul></li>
<li>保证隔离性I
<ul>
<li>锁 + MVCC机制</li>
<li>SQL标准隔离级别 ✅
<ul>
<li>RU读未提交 (问题: 脏读, 不可重复读, 幻读)</li>
<li>RC读已提交 (问题: 不可重复读, 幻读)
<ul>
<li>事务开始创建一个Read View
<ul>
<li>+解决不可重复读, 幻读</li>
</ul></li>
</ul></li>
<li>RR可重复读 (问题: 幻读)
<ul>
<li>快照读
<ul>
<li>MVCC机制
<ul>
<li>事务开始创建一个Read View</li>
<li>版本号</li>
</ul></li>
</ul></li>
<li>当前读
<ul>
<li>记录锁</li>
<li>间隙锁 防止幻读</li>
</ul></li>
</ul></li>
<li>S序列化 (完美)
<ul>
<li>-性能很差</li>
</ul></li>
</ul></li>
<li>锁
<ul>
<li>记录锁(行锁) 锁定行 (3)</li>
<li>间隙锁 锁定一个区间 (3,5)</li>
<li>临界锁 (3,5]</li>
<li>插入意向锁</li>
</ul></li>
</ul></li>
<li>保证持久性D
<ul>
<li>WAL 先写日志</li>
<li>Redo log
<ul>
<li>Innodb 日志</li>
<li>用于防止 Buffer Pool 因为异步落盘 数据丢失</li>
<li>两个文件循环写 为了性能</li>
<li>格式
<ul>
<li>数据页位置+修改内容</li>
</ul></li>
</ul></li>
<li>Binlog
<ul>
<li>Server层日志</li>
<li>三种格式
<ul>
<li>STATEMENT SQL语句</li>
<li>ROW 最终数据</li>
<li>MIXED</li>
</ul></li>
<li>保存开机后全量日志</li>
<li>用于备份恢复 主从同步</li>
</ul></li>
</ul></li>
<li>保证一致性C
<ul>
<li>前三个加起来</li>
</ul></li>
</ul></li>
</ul></li>
<li>锁 ❓
<ul>
<li>全局锁</li>
<li>表锁
<ul>
<li>MyISAM默认</li>
</ul></li>
<li>行锁
<ul>
<li>MyISAM没有</li>
<li>InnoDB默认</li>
<li>可能导致死锁</li>
</ul></li>
<li>页面锁</li>
<li>乐观锁 &amp; 悲观锁
<ul>
<li>乐观锁: 先更新再检查是否有其他事务修改
<ul>
<li>举例 共享文档 Git</li>
</ul></li>
<li>悲观锁: 先加锁再更新</li>
</ul></li>
</ul></li>
<li>MVCC 多版本并发控制
<ul>
<li>提高并发性能</li>
<li>当前读 读最新版本</li>
<li>快照读</li>
</ul></li>
<li>主从同步
<ul>
<li>目的 实现读写分离</li>
<li>同步模式
<ul>
<li>异步复制 (默认)</li>
<li>全同步复制</li>
<li>半同步复制</li>
</ul></li>
<li>配置
<ul>
<li>主库 cnf 设置 server-id log-bin(&gt;=8默认开启)</li>
<li>创建同步账户</li>
<li>SHOW MASTER STATUS;</li>
<li>从库执行SQL
<ul>
<li>START SLAVE;</li>
<li>SHOW SLAVE STATUS </li>
<li>STOP SLAVE SQL_THREAD;</li>
</ul></li>
<li>从库升级成主库
<ul>
<li>RESET MASTER;</li>
<li>CHANGE MASTER TO</li>
<li>START SLAVE;</li>
</ul></li>
</ul></li>
<li>主库在事务提交时 同步binlog到从库</li>
<li>从库保存到relay log 重放
<ul>
<li>从库重放是SQL Thread单线程</li>
</ul></li>
<li>主从延迟
<ul>
<li>避免大事务</li>
<li>从库自身读压力太大 -&gt; 增加从库数量分散压力</li>
<li>设置 slave_parallel_workers 并行复制线程数 slave-parallel-type 并行复制策略</li>
<li>semi-sync 半同步复制</li>
</ul></li>
</ul></li>
<li>分库分表
<ul>
<li>单表行数超 500 万行或者单表容量超过 2GB</li>
<li>垂直分库 按业务类型</li>
<li>垂直分表 按字段</li>
<li>水平拆分
<ul>
<li>ID取模</li>
</ul></li>
<li>MyCat
<ul>
<li>MySQL Stub</li>
</ul></li>
<li>ShardingSphere
<ul>
<li>JDBC Stub</li>
</ul></li>
</ul></li>
</ul>
<h2 id="redis">Redis ✅</h2>
<ul>
<li>特点
<ul>
<li>性能</li>
<li>功能</li>
</ul></li>
<li>单线程</li>
<li>数据类型
<ul>
<li>string</li>
<li>list</li>
<li>hash</li>
<li>set</li>
<li>zset</li>
</ul></li>
<li>底层存储
<ul>
<li>int</li>
<li>sds</li>
<li>quicklist</li>
<li>压缩列表/listpack</li>
<li>skiplist
<ul>
<li>SkipList vs B+tree
<ul>
<li>实现简单</li>
<li>占用内存少</li>
<li>插入删除性能更好，没有旋转平衡的开销</li>
</ul></li>
</ul></li>
<li>hashtable
<ul>
<li>MurmurHash2</li>
</ul></li>
</ul></li>
<li>持久化
<ul>
<li>RDB
<ul>
<li>压缩</li>
</ul></li>
<li>AOF 增量日志
<ul>
<li>会定期rewrite</li>
</ul></li>
<li>混合</li>
</ul></li>
<li>Pub/Sub机制</li>
<li>Key过期机制
<ul>
<li>惰性删除</li>
<li>定期删除</li>
</ul></li>
<li>内存淘汰
<ul>
<li>noeviction</li>
<li>volatile-random</li>
<li>volatile-ttl</li>
<li>volatile-lru 默认</li>
<li>volatile-lfu</li>
<li>allkeys-random</li>
<li>allkeys-lru</li>
<li>allkeys-lfu</li>
<li>LFU 更好, LRU 容易受缓存污染影响</li>
</ul></li>
<li>实现事务
<ul>
<li>Redis事务</li>
<li>Lua脚本</li>
</ul></li>
<li>发布订阅</li>
<li>Redis集群
<ul>
<li>主从
<ul>
<li>主库读写, 从库只读</li>
<li>Gossip</li>
<li>同步机制
<ul>
<li>全量复制</li>
<li>基于长连接的命令传播</li>
<li>增量复制</li>
</ul></li>
</ul></li>
<li>主从+哨兵
<ul>
<li>一个Raft集群 负责维护Redis集群的可用性
<ul>
<li>监控集群是否正常</li>
<li>自动故障转移</li>
<li>提供配置</li>
<li>通知客户端</li>
</ul></li>
<li>当&gt;=quorum个哨兵认为主库下线 则开始换主
<ul>
<li>选择数据最完整的从库作为主库</li>
</ul></li>
<li>哨兵之间利用Raft算法选主</li>
</ul></li>
<li>Cluster模式
<ul>
<li>去中心化 不区分主从 每个节点存储不同的分片
<ul>
<li>没有使用一致性hash 而是使用crc16(key)/16384</li>
<li>存在迁出导入开销</li>
</ul></li>
<li>MOVED 重定向用户请求</li>
</ul></li>
<li>脑裂问题
<ul>
<li>主节点虚假故障 丢失数据</li>
<li>可以用min-slaves缓解 但是不能彻底解决</li>
<li>换用强一致性的Zookeeper</li>
</ul></li>
</ul></li>
<li>使用问题
<ul>
<li>大key</li>
<li>缓存击穿 热点key过期
<ul>
<li>设置热点key永不过期</li>
</ul></li>
<li>缓存雪崩 大量key同时失效
<ul>
<li>随机过期时间或永不过期</li>
<li>热点数据分散</li>
</ul></li>
<li>缓存穿透 热点key不存在
<ul>
<li>设置key-null</li>
</ul></li>
</ul></li>
<li>缓存一致性 (分布式一致性问题)
<ul>
<li>缓存策略
<ul>
<li>Cache Aside: 读者读db时顺便设置缓存
<ul>
<li>-需要缓存设置过期时间</li>
<li>-过期时间内可能是旧的值</li>
</ul></li>
<li>Read Through:</li>
<li>Write Through: 只写db, 异步推送到缓存</li>
<li>Write Back: 只更新缓存, 异步写入db</li>
</ul></li>
<li>同步机制
<ul>
<li>更新派
<ul>
<li>🔃缓存, 🔃db
<ul>
<li>不好 缓存可能被另一个进程刷新为旧值</li>
</ul></li>
<li>🔃db, 🔃缓存
<ul>
<li>不好 更新缓存需要计算 浪费系统资源</li>
</ul></li>
</ul></li>
<li>删除派
<ul>
<li>🆑️缓存, 🔃db
<ul>
<li>不好 缓存可能被另一个进程刷新为旧值</li>
<li>延迟双删可以: 🆑️缓存, 🔃db, 延迟, 🆑️缓存</li>
</ul></li>
<li>🔃db, 🆑️缓存
<ul>
<li>好 第二步需要重试保证</li>
</ul></li>
</ul></li>
</ul></li>
<li>通用技巧
<ul>
<li>过期时间</li>
<li>终极方案 分布式锁</li>
<li>失败重试
<ul>
<li>单独线程</li>
<li>MQ</li>
</ul></li>
<li>binlog订阅</li>
</ul></li>
</ul></li>
</ul>
<h2 id="nginx">Nginx</h2>
<ul>
<li>功能
<ul>
<li>负载均衡
<ul>
<li>轮询</li>
<li>加权轮询</li>
<li>随机</li>
<li>源地址(用户IP)哈希</li>
<li>最小连接数</li>
<li>插件
<ul>
<li>fair (最快的)</li>
<li>URL(访问目标)哈希</li>
</ul></li>
</ul></li>
<li>反向代理</li>
</ul></li>
<li>实现
<ul>
<li>主从Reactor模式</li>
</ul></li>
</ul>
<h2 id="前端技术">前端技术</h2>
<ul>
<li>Session &amp; Cookie &amp; Token
<ul>
<li>Session 服务端用于保存每个连接用户状态的对象</li>
<li>Cookie
<ul>
<li>结构 name, domain, path, secure</li>
<li>生命周期
<ul>
<li>没设置过期时间 =&gt; 会话Cookie 浏览器关闭即消失</li>
<li>设置过期时间 保存在硬盘上</li>
</ul></li>
</ul></li>
</ul></li>
<li>LocalStorage
<ul>
<li>生命周期 不会过期</li>
<li>大小 一般5M</li>
</ul></li>
<li>SessionStorage
<ul>
<li>生命周期 浏览器关闭即消失</li>
</ul></li>
<li>浏览器加载资源的过程</li>
<li>浏览器输入URL之后的过程</li>
</ul>
<h2 id="后端技术">后端技术</h2>
<ul>
<li>缓存 -&gt; Redis</li>
<li>Spring
<ul>
<li>AOP</li>
<li>IOC</li>
<li>循环依赖
<ul>
<li>Bean互相依赖</li>
<li>三级缓存
<ul>
<li>一级缓存为单例池 singletonObjects</li>
<li>二级缓存为早期曝光对象 earlySingletonObjects</li>
<li>三级缓存为早期曝光对象工厂 singletonFactories</li>
</ul></li>
</ul></li>
<li>Filter ❓</li>
</ul></li>
<li>MyBatis</li>
<li>高并发下库存超卖问题 ❓
<ul>
<li>设置字段为无符号 依赖异常</li>
<li>使用悲观锁</li>
<li>Redis分布式锁
<ul>
<li>事务 lua脚本</li>
<li>集群同步问题 RedLock</li>
</ul></li>
</ul></li>
<li>限流
<ul>
<li>固定窗口/滑动窗口</li>
<li>QPS限流
<ul>
<li>+简单</li>
<li>+可以改周期增大突发流量</li>
<li>-周期边界不平滑</li>
<li>-放过请求不均匀</li>
</ul></li>
<li>令牌桶
<ul>
<li>+流量均匀</li>
<li>-第一个周期不平滑</li>
</ul></li>
<li>漏桶
<ul>
<li>-出水速度恒定 瞬时大流量会被丢弃</li>
</ul></li>
</ul></li>
</ul>
<h2 id="中间件">中间件</h2>
<ul>
<li>缓存</li>
<li>消息队列</li>
<li>定时任务</li>
<li>日志采集</li>
</ul>
<h2 id="消息队列">消息队列</h2>
<ul>
<li>作用 异步削峰解耦</li>
<li>监控</li>
<li>怎么保证消息不丢失
<ul>
<li>消费者反馈消息收到</li>
<li>数据持久化</li>
</ul></li>
<li>消息积压 ❓
<ul>
<li>保存到硬盘上</li>
</ul></li>
<li>RabbitMQ ❓</li>
</ul>
<h2 id="分布式系统">分布式系统</h2>
<ul>
<li>CAP理论 ✅
<ul>
<li>C 强一致性</li>
<li>A 可用性</li>
<li>P 分区可用性</li>
<li>C+A:</li>
<li>C+P: Raft</li>
</ul></li>
<li>BASE理论 ✅
<ul>
<li>BA 基本可用</li>
<li>S 软状态</li>
<li>E 最终一直性</li>
</ul></li>
<li>强一致性
<ul>
<li>线性一致性 集群看起来和单个节点一样</li>
<li>顺序一致性 弱一点</li>
</ul></li>
<li>分布式共识算法 CP
<ul>
<li>Paxos ❓
<ul>
<li>三种身份 Proposers Acceptors Learners</li>
<li>-解决不了拜占庭问题</li>
</ul></li>
<li>Raft ❓
<ul>
<li>关键点: 心跳同步log, 新log覆盖旧log, 选主过半数机制</li>
</ul></li>
<li>ZAB
<ul>
<li>过半数ACK提交</li>
</ul></li>
</ul></li>
<li>分布式锁 ❓
<ul>
<li>Redis setnx
<ul>
<li>需设置过期时间 防止死锁</li>
<li>需设置独特value 防止被别人释放</li>
<li>锁提前释放 后台线程去续期锁 可以用Redission</li>
<li>Redis集群同步可能丢锁 使用Redlock</li>
</ul></li>
<li>ZooKeeper 临时节点
<ul>
<li>写强一致性 读不是(顺序一致性)
<ul>
<li>读之前sync()一下就是强一致</li>
</ul></li>
<li>+连接结束会自动释放</li>
<li>-如果进程卡住 心跳不及时 会导致提前释放</li>
</ul></li>
<li>Google Chubby (Paxos)</li>
</ul></li>
<li>一致性哈希
<ul>
<li>防止节点扩容导致未知变化</li>
<li>Hash环</li>
<li>虚拟节点</li>
</ul></li>
<li>负载均衡算法
<ul>
<li>RR</li>
<li>Weight RR</li>
<li>Random</li>
<li>Weight Random</li>
<li>Hash</li>
</ul></li>
<li>分布式ID
<ul>
<li>雪花算法</li>
</ul></li>
<li>分布式事务
<ul>
<li>两阶段提交 2PC ❓❓
<ul>
<li>+原理简单，实现方便</li>
<li>-同步阻塞 即所偶参与的事务逻辑均处于阻塞状态。</li>
<li>-单点故障 协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。</li>
<li>-脑裂问题 在阶段二中，如果只有部分参与者接受并执行了Commit请求，会导致节点数据不一致。</li>
</ul></li>
<li>三阶段提交 3PC ❓❓
<ul>
<li>+降低了阻塞范围 在等待超时后，协调者或参与者会中断事务。</li>
<li>+避免单点故障 阶段3中协调者出现问题时，参与者会继续提交事务。</li>
<li>-脑裂问题</li>
</ul></li>
<li>TCC</li>
</ul></li>
<li>系统
<ul>
<li>ZooKeeper ❓
<ul>
<li>分布式注册中心 按照目录层级划分 可以监听节点</li>
<li>ZAB算法</li>
<li>最好奇数个节点</li>
</ul></li>
<li>Etcd
<ul>
<li>强一致性</li>
</ul></li>
<li>Consul
<ul>
<li></li>
</ul></li>
</ul></li>
<li>Hive ❓</li>
<li>分布式文件系统
<ul>
<li>GFS ❓</li>
<li>HDFS ❓</li>
</ul></li>
<li>Hadoop ❓</li>
<li>表格存储
<ul>
<li>Google BigTable ❓</li>
<li>HBase ❓</li>
</ul></li>
</ul>
<h2 id="大数据">大数据</h2>
<ul>
<li>Spark</li>
<li>Lucene</li>
<li>海量数据处理问题
<ul>
<li>离线Top n</li>
<li>在线Top n</li>
<li>通用技巧
<ul>
<li>数据结构: 位图 平衡树 索引 Trie BloomFilter</li>
<li>分治 合并</li>
</ul></li>
</ul></li>
<li>MapReduce</li>
</ul>
<h2 id="微服务">微服务</h2>
<ul>
<li>RPC
<ul>
<li>原理</li>
<li>框架</li>
</ul></li>
<li>Nacos 注册中心</li>
<li>Dubbo 微服务框架</li>
</ul>
<h2 id="存储">存储</h2>
<ul>
<li>块存储</li>
<li>文件存储</li>
<li>对象存储 ✅</li>
<li>快照机制
<ul>
<li>COW
<ul>
<li>-1次写变1读2写 写放大 性能低</li>
</ul></li>
<li>ROW (Redirect On Write)
<ul>
<li>+不会有额外的写入</li>
<li>-有数据碎片</li>
</ul></li>
</ul></li>
</ul>
<h2 id="数据库内核">数据库内核</h2>
<ul>
<li>LSM-Tree ❓</li>
<li>LevelDB ❓</li>
<li>RocksDB ❓</li>
<li>MySQL</li>
<li>Buffer Pool
<ul>
<li>文件系统缓存层</li>
</ul></li>
</ul>
<h2 id="搜索">搜索</h2>
<ul>
<li>粗排</li>
<li>精排</li>
<li>召回</li>
<li>算法</li>
</ul>
<h2 id="离散数学-密码学">离散数学 &amp; 密码学</h2>
<ul>
<li>格 理想</li>
<li>哈希算法
<ul>
<li>MD5 SHA1 SHA256</li>
<li>MurmurHash3 Fnv1a</li>
</ul></li>
<li>对称加密
<ul>
<li>DES 3DES AES</li>
</ul></li>
<li>非对称加密
<ul>
<li>RSA
<ul>
<li>-不支持前向保密</li>
<li>大质因数分解</li>
</ul></li>
<li>DSA
<ul>
<li>大数离散对数</li>
</ul></li>
</ul></li>
<li>密钥交换
<ul>
<li>Diffie-Hellman</li>
<li>EC Diffie-Hellman</li>
</ul></li>
</ul>
<h2 id="隐私计算">隐私计算</h2>
<ul>
<li>方法
<ul>
<li>差分隐私 DP
<ul>
<li>将原始数据淹没在噪音中, 使得无法得到原始数据</li>
</ul></li>
<li>混淆电路 GC</li>
<li>密钥分享 SS</li>
<li>同态加密 HE
<ul>
<li>原理 先加密再运算</li>
<li>类型
<ul>
<li>半同态加密 (Partially HE, PHE) 加密后只支持加法或乘法运算</li>
<li>全同态加密 (Fully HE, FHE)</li>
</ul></li>
<li>方法
<ul>
<li>Pailier算法</li>
<li>复合剩余类问题 DCRA</li>
</ul></li>
<li>应用场景</li>
<li>工具
<ul>
<li>Microsoft SEAL</li>
</ul></li>
</ul></li>
</ul></li>
<li>应用场景
<ul>
<li>联合建模</li>
<li>联合统计</li>
<li>安全预测</li>
<li>隐匿查询</li>
<li>机构之间的联合计算</li>
</ul></li>
<li>安全两方计算 2PC
<ul>
<li>工具
<ul>
<li>Cheetah 猎豹 阿里安全</li>
</ul></li>
</ul></li>
<li>多方安全计算 MPC
<ul>
<li>把多个参与方的数据放在一起计算出特定的结果 同时保证每一方信息的细节不被泄露 典型 百万富翁问题</li>
</ul></li>
<li>硬件设备
<ul>
<li>多方安全计算 MPC</li>
<li>同态加密 HE</li>
<li>可信执行环境 TEE</li>
<li>可信密态计算 TECC</li>
</ul></li>
<li>可信执行环境 TEE
<ul>
<li>将处理器的一个区域与 CPU 的其余部分分开来使用基于硬件的安全计算模型
<ul>
<li>隔离</li>
<li>数据加密</li>
<li>完整性校验</li>
<li>远程认证</li>
</ul></li>
<li>+安全性</li>
<li>-侧信道攻击</li>
<li>实现
<ul>
<li>Intel SGX
<ul>
<li>LibOS</li>
<li>Grammy</li>
</ul></li>
<li>ARM TrustZone</li>
</ul></li>
<li>TEE OS
<ul>
<li>Occlum 蚂蚁</li>
</ul></li>
</ul></li>
<li>联邦学习 FL</li>
<li>隐私计算框架
<ul>
<li>TensorFlow Federated (TFF)</li>
<li>KubeTEE 蚂蚁</li>
<li>隐语 蚂蚁</li>
<li>PySyft OpenMined</li>
</ul></li>
</ul>
<h2 id="安全">安全</h2>
<ul>
<li>Web漏洞
<ul>
<li>CSRF</li>
<li>XSS</li>
<li>SQL</li>
<li>WAF</li>
</ul></li>
<li>安全机制
<ul>
<li>SELinux</li>
<li>AppArmor</li>
<li>NX(Dep)</li>
<li>Seccomp 过滤系统调用</li>
<li>namespace
<ul>
<li>User</li>
<li>Net</li>
<li>PID</li>
<li>FS</li>
</ul></li>
</ul></li>
</ul>
<h2 id="云计算-虚拟化">云计算 &amp; 虚拟化</h2>
<ul>
<li>云计算
<ul>
<li>IaaS</li>
<li>PaaS</li>
<li>FaaS</li>
</ul></li>
<li>QEMU</li>
<li>KVM</li>
<li>Hypervisor</li>
<li>体系结构</li>
<li>virtio
<ul>
<li>模拟PCI设备 麻烦</li>
</ul></li>
</ul>
<h2 id="容器">容器</h2>
<ul>
<li>Docker
<ul>
<li>底层
<ul>
<li>namespace</li>
<li>cgroups</li>
</ul></li>
<li>Containerd</li>
</ul></li>
<li>K8S
<ul>
<li>架构
<ul>
<li>kubelet</li>
<li>apiserver</li>
<li>etcd (raft) 配置信息和服务发现</li>
<li>controller</li>
<li>scheduler</li>
<li>runtime
<ul>
<li>containerd</li>
</ul></li>
<li>kube-proxy</li>
</ul></li>
<li>概念
<ul>
<li>Pod</li>
<li>Node</li>
<li>Container</li>
</ul></li>
<li>CRI</li>
<li>CNI</li>
<li>OCI</li>
</ul></li>
<li>Docker</li>
<li>Containerd</li>
<li>Kata
<ul>
<li>+资源管理</li>
<li>+隔离彻底</li>
<li>-比较重</li>
</ul></li>
<li>gVisor
<ul>
<li>+轻量级 开销更小</li>
<li>-不支持资源限制</li>
<li>-仍然是同一个内核</li>
<li>两种工作模式
<ul>
<li>ptrace + Seccomp
<ul>
<li>退出场景
<ul>
<li>执行syscall</li>
<li>收到signal</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="音视频">音视频</h2>
<h2 id="机器学习-深度学习">机器学习 &amp; 深度学习</h2>
<ul>
<li>CNN
<ul>
<li>卷积层</li>
</ul></li>
<li>RNN</li>
<li>LSTM</li>
<li>Transformer
<ul>
<li></li>
</ul></li>
<li>移动端部署
<ul>
<li>TensorFlow Lite</li>
<li>NCNN</li>
<li>MNN</li>
<li>Paddle-Lite</li>
<li>技术点
<ul>
<li>big.LITTLE调度</li>
<li>OpenCL</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/11/29/2020-11-29/</url>
    <content><![CDATA[<h1 id="用-hexo-搭建了个人-blog">用 Hexo 搭建了个人 blog</h1>
<h2 id="hexo-基本操作">Hexo 基本操作</h2>
<ul>
<li><p>安装</p>
<p><code>npm install -g hexo-cli</code></p></li>
<li><p>初始化hexo</p>
<p><code>hexo init</code></p>
<ul>
<li>当前目录必须是空的</li>
</ul></li>
<li><p>新建文章</p>
<p><code>hexo new [layout] name</code></p>
<ul>
<li><p>layout 可以是 post, page, draft 之一</p></li>
<li><p>分别保存至 source/_posts, source, source/_drafts 中</p></li>
<li><p>新建文件名可以在 _config.yml 里面指定, <code>new_post_name</code>, 默认为 <code>name.md</code></p></li>
</ul></li>
<li><p>临时开启 server</p>
<p><code>hexo server</code></p></li>
</ul>
<h1 id="react-入门">React 入门</h1>
<h2 id="复习-javascript">复习 JavaScript</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript">很好的文章</a></li>
</ul>
<h1 id="vue-和-react-路由模块的区别">Vue 和 React 路由模块的区别</h1>
<h2 id="vue-路由">Vue 路由</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/inspect&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">        <span class="attr">redirect</span>: <span class="string">&#x27;/inspect/table1&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;报表&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;报表&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;table&#x27;</span> &#125;,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;table1&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Table&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/table/index&#x27;</span>),</span><br><span class="line">            <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;Table&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;table&#x27;</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="vue-深入-mvvm-框架">Vue 深入 —— MVVM 框架</h1>
<ul>
<li><p>Observer 数据劫持</p></li>
<li><p>Dep/Watcher 发布订阅</p></li>
<li><p>Compiler 解析 <code>&#123;&#123; &#125;&#125;</code>, 创建watcher, 求解表达式</p></li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/11/30/2020-11-30/</url>
    <content><![CDATA[<h1 id="github-developer-settings">Github Developer Settings</h1>
<ul>
<li><p>GitHub Apps</p></li>
<li><p>OAuth Apps</p>
<ul>
<li>需要用到Github API的App</li>
</ul></li>
<li><p>Personal access tokens</p>
<ul>
<li><p>Tokens you have generated that can be used to access the GitHub API.</p></li>
<li><p>权限类似于账号+密码登录</p></li>
</ul></li>
</ul>
<h1 id="github-actions">Github Actions</h1>
<ul>
<li><p>类似Travis-CI的持续集成平台</p></li>
<li><p>使用方法</p>
<ul>
<li><p>在项目根目录创建 .github/workflows</p></li>
<li><p>继续创建 pages.yml</p></li>
<li><p>关键字: jobs, runs-on, steps, name, uses, with等等</p></li>
</ul></li>
</ul>
<h1 id="hexo博客评论系统">Hexo博客评论系统</h1>
<ul>
<li><p>Gitalk</p>
<ul>
<li><p>利用Github Issues功能实现的评论系统, 开源</p></li>
<li><p>不支持回复评论</p></li>
<li><p>修改评论需要打开对应的Issue页修改</p></li>
<li><p>登录需要的Github权限太高(Github自身问题)</p></li>
</ul></li>
<li><p>Disqus</p>
<ul>
<li><p>界面好看</p></li>
<li><p>需要翻墙才能正常使用</p></li>
</ul></li>
</ul>
<h1 id="code-server">Code-Server</h1>
<ul>
<li>浏览器端的vscode</li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/01/2020-12-01/</url>
    <content><![CDATA[<h1 id="转换dos格式行尾为unix行尾">转换dos格式行尾为unix行尾</h1>
<ul>
<li><p>工具: dos2unix</p></li>
<li><p>单文件: <code>dos2unix input output</code></p></li>
<li><p>递归转换: <code>find . -type f -print0 | xargs -0 dos2unix</code></p></li>
</ul>
<h1 id="linux下-nodejs-环境配置">Linux下 nodejs 环境配置</h1>
<ul>
<li><p>安装node(不是最新版): <code>sudo apt install nodejs</code></p></li>
<li><p>使用<code>n</code>来切换node版本:</p>
<ul>
<li><p><code>sudo npm install -g n</code></p></li>
<li><p><code>sudo n stable</code></p></li>
</ul></li>
<li><p>安装yarn: <code>sudo npm install -g yarn</code></p></li>
</ul>
<h1 id="nodejs版本切换">Nodejs版本切换</h1>
<ul>
<li><p>使用<code>n</code></p>
<ul>
<li><p>方法:</p>
<ul>
<li><p>安装: <code>sudo npm install -g n</code></p></li>
<li><p>切换版本: <code>sudo n stable</code></p></li>
</ul></li>
<li><p>缺点: 据说会导致node modules混乱</p></li>
</ul></li>
<li><p>使用<code>nvm</code></p></li>
</ul>
<h1 id="清理npm缓存">清理npm缓存</h1>
<ul>
<li><p><code>npm cache clean --force</code></p></li>
<li><p>The default cache direconstructory is ~/.npm on Posix (mac or linux), or %AppData%/npm-cache on Windows.</p></li>
</ul>
<h1 id="javascript-复习">Javascript 复习</h1>
<ul>
<li><p>数据类型</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Symbol (new in ES2015)</li>
<li>Object
<ul>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
</ul></li>
<li>null</li>
<li>undefined</li>
</ul></li>
<li><p>关于变量</p>
<ul>
<li><p>用<code>var</code>定义的变量具有<strong>函数</strong>作用域</p>
<ul>
<li><p>name hiding: <code>(function () &#123; ... &#125;)();</code></p></li>
<li><p>允许递归版(IIFEs): <code>(function foo() &#123; ...foo()... &#125;)();</code></p></li>
</ul></li>
<li><p>尽量使用<code>let</code>和<code>const</code></p></li>
</ul></li>
<li><p>关于Array:</p>
<ul>
<li><p>相当于一个下标是整数, 有一个length属性, 外表看起来像是数组的Object</p></li>
<li><p>数组的length属性是数组中最大的下标+1</p></li>
<li><p>当然作为Object, 也可以有非整数类型的下标</p></li>
<li><p>for...in...循环遍历实际存储的值, for...of...循环遍历下标</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = []</span><br><span class="line"></span><br><span class="line">a[<span class="number">100</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">length</span> <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> a) <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> a) <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// undefined, undefined, ... , 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>关于String</p>
<ul>
<li><p>String + any = String</p></li>
<li><p>any + String = String</p></li>
<li><p>注意结合性</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="string">&#x27;3&#x27;</span> <span class="comment">// &#x27;33&#x27;</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">2</span> + <span class="number">3</span> <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>关于Object:</p>
<ul>
<li><p>对象字面量<code>&#123;&#125;</code>等效于<code>new Object()</code></p>
<ul>
<li><p>不过<code>Object()</code>可以被重载</p></li>
<li><p>对象字面量不能被重载</p></li>
</ul></li>
<li><p><code>new XXX()</code>: 相当于创建了一个类实例(实际上是个Object), <code>XXX()</code>函数可以对其进行进一步修饰</p></li>
</ul></li>
<li><p>关于<code>function</code>:</p>
<ul>
<li>函数是对象</li>
</ul></li>
<li><p>关于<code>new</code>:</p>
<ul>
<li><p>new的功能:</p>
<ul>
<li><p>创建一个空对象{}</p></li>
<li><p>设置空对象的<code>__proto__</code>(与浏览器实现有关)为构造函数的<code>prototype</code></p></li>
<li><p>让this指向空对象</p></li>
<li><p>执行构造函数, 传入参数this</p></li>
<li><p>如果构造函数不返回一个对象, 则返回this</p></li>
</ul></li>
<li><p>模仿一个new:</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fake_new</span>(<span class="params">ctor, ...args</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="title class_">Object</span>.<span class="title function_">create</span>(ctor.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// ES5 创建新对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">///* before ES5 */</span></span><br><span class="line">    <span class="comment">// function F() &#123;&#125;</span></span><br><span class="line">    <span class="comment">// F.prototype = ctor.prototype;</span></span><br><span class="line">    <span class="comment">// let x = new F();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = ctor.<span class="title function_">call</span>(x, ...args); <span class="comment">//借用外部传入的构造器给obj设置属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? res : x; <span class="comment">//确保构造器总是返回一个对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>关于<code>this</code>:</p>
<ul>
<li><p>如何正确绑定this</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="title function_">foo</span>(<span class="params"></span>) &#123; ... &#125;, <span class="comment">// bad, `this` is bound to the object</span></span><br><span class="line">    foo = <span class="function">() =&gt;</span> &#123; ... &#125;, <span class="comment">// good, `this` is bound dynamically</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>Javascript面向对象:</p>
<ul>
<li><p>不用<code>new</code>模拟对象, 利用闭包</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makePerson</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">first</span>: first,</span><br><span class="line">        <span class="attr">last</span>: last,</span><br><span class="line">        <span class="attr">fullName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fullNameReversed</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="title function_">makePerson</span>(<span class="string">&#x27;Simon&#x27;</span>, <span class="string">&#x27;Willison&#x27;</span>);</span><br><span class="line">s.<span class="title function_">fullName</span>(); <span class="comment">// &quot;Simon Willison&quot;</span></span><br><span class="line">s.<span class="title function_">fullNameReversed</span>(); <span class="comment">// &quot;Willison, Simon&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>使用<code>new</code></p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = last;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullNameReversed</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Simon&#x27;</span>, <span class="string">&#x27;Willison&#x27;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>优化: 减少函数对象的拷贝, 利用原型链</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fullName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fullNameReversed</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h1 id="react-复习">React 复习</h1>
<ul>
<li><p>JSX语法</p>
<p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;greeting&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Hello, world!</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&#x27;h1&#x27;</span>, <span class="comment">// label type</span></span><br><span class="line">    &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>, <span class="attr">onClick</span>: <span class="variable language_">this</span>.<span class="property">handleClick</span>&#125;, <span class="comment">// attrs</span></span><br><span class="line">    <span class="string">&#x27;Hello, world!&#x27;</span> <span class="comment">// children</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>遇到<code>&lt;</code>开始解析HTML, 遇到<code>&#123;</code>开始解析Javascript</p></li>
<li><p>要比Vue的模板更加灵活</p></li>
</ul></li>
<li><p>数据流</p>
<ul>
<li><p>外层-&gt;内层组件: <code>props</code>, 只读</p></li>
<li><p>组件自己的状态: <code>state</code>, 可以修改</p>
<ul>
<li><p>初始化: 在构造函数内直接赋值</p></li>
<li><p>更新: 通过<code>this.setState(&#123;&#125;)</code></p></li>
<li><p>state可以被传递给子组件作为子组件的props</p></li>
</ul></li>
</ul></li>
<li><p>受控组件:</p>
<ul>
<li><p>不自己维护状态的组件</p></li>
<li><p>状态变化全部交给外部来做: props.value, props.onValueChanged()</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
        <tag>npm</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/02/2020-12-02/</url>
    <content><![CDATA[<ul>
<li><p>React</p>
<ul>
<li>children属性: 子元素构成的数组</li>
</ul></li>
<li><p>React-redux</p>
<ul>
<li><p>引入: <code>import &#123;...&#125; from 'react-redux'</code></p></li>
<li><p><code>Store</code></p>
<ul>
<li><p>Redux maintains a <code>store</code>, which hold <code>state</code> and <code>reducer</code></p></li>
<li><p><code>createStore(reducer, initState)</code></p>
<ul>
<li><code>reducer</code> and <code>initState</code> should have the same keys</li>
</ul></li>
</ul></li>
<li><p><code>Reducer</code>: (state, action) =&gt; (newstate)</p></li>
<li><p><code>&lt;Provider&gt;</code>: Inject global <code>state</code> to its children component</p></li>
<li><p><code>connect(mapStateToProps)(Component)</code></p>
<ul>
<li><p>map current states to <code>Component</code>'s props</p></li>
<li><p><code>mapStateToProps</code>: is a function: (state) =&gt; { ...someProp }</p></li>
<li><p>一般和<Provider>结合起来用</p></li>
</ul></li>
</ul></li>
<li><p>React-Router</p>
<ul>
<li><p>引入: <code>import &#123;&#125; from 'react-router-dom'</code></p></li>
<li><p><code>&lt;Route path&gt;</code>: 当url与path匹配时, 渲染内容</p>
<ul>
<li><p><code>&lt;BrowserRouter&gt;, &lt;HashRouter&gt;</code>: <Route>的容器</p></li>
<li><p><code>&lt;Switch&gt;</code>: 保证其下的所有Route只会选中一个</p></li>
<li><p>参数化匹配</p>
<ul>
<li><p>参数定义: <code>path="/hsl/:h/:s/:l"</code></p></li>
<li><p>参数获取: 在children组件中 <code>let &#123; h, s, l &#125; = useParams();</code></p></li>
</ul></li>
</ul></li>
<li><p><code>&lt;Link to&gt;</code>: 跳转到to的a标签</p>
<ul>
<li><code>&lt;Redirect&gt;</code>: 渲染时自动跳转</li>
</ul></li>
<li><p>嵌套使用:</p>
<p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; path, url &#125; = <span class="title function_">useRouteMatch</span>(); <span class="comment">// 获取上一级的path和url</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">path</span>&#125;/<span class="attr">next</span>`&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">)</span></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>Vue-Router</p>
<ul>
<li><p><code>&lt;router-link :to&gt;</code>: 跳转的a标签</p></li>
<li><p><code>&lt;router-view&gt;</code>: 匹配的路由内容会渲染到这里</p></li>
<li><p><code>Router</code>: 在这里定义全局路由表</p></li>
</ul></li>
<li><p>Ubuntu 安装 rpm 包</p>
<ul>
<li><p>sudo apt install alien</p></li>
<li><p>sudo alien packagename.rpm</p></li>
<li><p>sudo apt install ./packagename.deb</p></li>
<li><p>一步到位: sudo alien -i packagename.rpm</p></li>
</ul></li>
<li><p>Oracle 的连接方式</p>
<ul>
<li><p>SID/System IDentifier: 数据库实例的全局唯一ID, 每个实例都不一样</p></li>
<li><p>SERVICE_NAME: 用于对外提供服务的名字, 被客户端使用</p>
<ul>
<li>也可以被数据库端用来区分对不同客户端提供的服务</li>
</ul></li>
<li><p>TNS/Transparent Network Substrate: 由Oracle创造的, 专门用于Oracle数据库连接的, 基于TCP/IP, SDP和命名管道的, 同构p2p连接技术</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// STATE.WORLD是一个TNS Name</span><br><span class="line">STAGE.WORLD =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">        (ADDRESS =</span><br><span class="line">            (PROTOCOL = TCP) </span><br><span class="line">            (PORT = 1521)</span><br><span class="line">            (HOST = LITTLECOMPUTER.ACME.ORG) // 服务器地址</span><br><span class="line">        )</span><br><span class="line">        (CONNECT_DATA = (SID = MYSID)) // 数据库标识, 可以使用SID或者SERVICE_NAME</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">// PROD.WORLD也是一个TNS Name</span><br><span class="line">PROD.WORLD =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">        (ADDRESS =</span><br><span class="line">            (PROTOCOL = TCP) </span><br><span class="line">            (PORT = 1521)</span><br><span class="line">            (HOST = BIGCOMPUTER.ACME.ORG)</span><br><span class="line">        )</span><br><span class="line">        (CONNECT_DATA = (SERVICE_NAME = MYNAME))</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/03/2020-12-03/</url>
    <content><![CDATA[<h1 id="秘书问题">秘书问题</h1>
<ul>
<li><p>又称相亲问题、止步问题、见好就收问题、苏丹的嫁妆问题、挑剔的求婚者问题等</p></li>
<li><p>要聘请一名秘书，有 n 个应聘者。每次面试一人，面试后就要及时决定是否聘他，如果当时决定不聘他，他便不会回来。面试后总能清楚了解应聘者的合适程度，并能和之前的每个人做比较。问什么样的策略，才使最佳人选被选中的概率最大。</p></li>
<li><p>答案:</p>
<details>
<p><summary>展开</summary></p>
<ul>
<li><p>这个问题的最优解是一个停止规则。在这个规则里，面试官会拒绝头 r - 1 个应聘者 (令他们中的最佳人选为 应聘者 M)，然后选出第一个比 M 好的应聘者。可见最优策略包含于这个系列的策略中。 (如果M在所有n个应聘者中也是最好的一个，那么这个策略将选不出任何人选)对于任意的截断值 r，最佳人选被选中的概率是：</p>
<pre><code>$$&#123;\displaystyle &#123;\begin&#123;aligned&#125;P(r)&amp;=\sum _&#123;i=1&#125;^&#123;n&#125;P\left(&#123;\text&#123;applicant &#125;&#125;i&#123;\text&#123; is selected&#125;&#125;\cap &#123;\text&#123;applicant &#125;&#125;i&#123;\text&#123; is the best&#125;&#125;\right)\\&amp;=\sum _&#123;i=1&#125;^&#123;n&#125;P\left(&#123;\text&#123;applicant &#125;&#125;i&#123;\text&#123; is selected&#125;&#125;|&#123;\text&#123;applicant &#125;&#125;i&#123;\text&#123; is the best&#125;&#125;\right)\cdot P\left(&#123;\text&#123;applicant &#125;&#125;i&#123;\text&#123; is the best&#125;&#125;\right)\\&amp;=\left[\sum _&#123;i=1&#125;^&#123;r-1&#125;0+\sum _&#123;i=r&#125;^&#123;n&#125;P\left(\left.&#123;\begin&#123;array&#125;&#123;l&#125;&#123;\text&#123;the best of the first &#125;&#125;i-1&#123;\text&#123; applicants&#125;&#125;\\&#123;\text&#123;is in the first &#125;&#125;r-1&#123;\text&#123; applicants&#125;&#125;\end&#123;array&#125;&#125;\right|&#123;\text&#123;applicant &#125;&#125;i&#123;\text&#123; is the best&#125;&#125;\right)\right]\cdot &#123;\frac &#123;1&#125;&#123;n&#125;&#125;\\&amp;=\left[\sum _&#123;i=r&#125;^&#123;n&#125;&#123;\frac &#123;r-1&#125;&#123;i-1&#125;&#125;\right]\cdot &#123;\frac &#123;1&#125;&#123;n&#125;&#125;\quad =\quad &#123;\frac &#123;r-1&#125;&#123;n&#125;&#125;\sum _&#123;i=r&#125;^&#123;n&#125;&#123;\frac &#123;1&#125;&#123;i-1&#125;&#125;.\end&#123;aligned&#125;&#125;&#125;$$</code></pre>
<ul>
<li><p>当n趋近于无穷大时</p>
<p><span class="math display">\[{\displaystyle P(x)=x\int _{x}^{1}{\frac {1}{t}}\,dt=-x\ln(x).}\]</span></p></li>
<li><p>求出最优的x值为</p>
<p><span class="math display">\[\frac {1}{e}\]</span></p></li>
</ul>
</details></li>
</ul></li>
</ul>
<h1 id="nginx-配置">Nginx 配置</h1>
<ul>
<li><p>root: 表示去哪个目录下寻找对应url的文件, 实际上是添加前缀</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /aaaa/ &#123;</span><br><span class="line">    root /home/tom/www/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>请求: http://(hostname)<span style="background-color: yellow;">/aaaa/</span>hello.txt</p></li>
<li><p>返回: <span style="background-color: #cdffd8;">/home/tom/www</span><span style="background-color: yellow;">/aaaa/</span>hello.txt</p></li>
</ul></li>
<li><p>alias: 表示把匹配成功的路径<strong>替换</strong>成alias</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /aaaa/ &#123;</span><br><span class="line">    alias /home/tom/www/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>请求: http://(hostname)<span style="background-color: yellow;">/aaaa/</span>hello.txt</p></li>
<li><p>返回: <span style="background-color: #cdffd8;">/home/tom/www/</span>hello.txt</p></li>
</ul></li>
<li><p>PS: Nginx会自动将两个连续的斜杠替换成一个</p></li>
</ul>
<h1 id="flask-嵌套路由配置">Flask 嵌套路由配置</h1>
<ul>
<li><p>使用<code>register_blueprint</code>时的<code>url_prefix</code>参数</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create app, blueprints, etc.</span></span><br><span class="line">app.register_blueprint(myblueprint, url_prefix=<span class="string">&#x27;/somepath&#x27;</span>)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h1 id="视频网站设计思考">视频网站设计思考</h1>
<ul>
<li>视频文件存储到哪里: OSS对象存储服务</li>
</ul>
<h1 id="数据库隔离级别">数据库隔离级别</h1>
<ol type="1">
<li><p>读未提交(Read Uncommitted)</p></li>
<li><p>读已提交(Read Committed)/不可重复读 大多数数据库默认的隔离级别</p></li>
<li><p>可重复读(Repeatable-Read) mysql数据库所默认的级别</p></li>
<li><p>序列化(serializable)</p></li>
</ol>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Math</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/04/2020-12-04/</url>
    <content><![CDATA[<h1 id="java-包package-jar和模块module的区别">Java 包(Package), Jar和模块(Module)的区别</h1>
<ul>
<li><p>包 (Package)</p>
<ul>
<li><p>是Java源文件的集合, 包含Class/Interface/Annotation的定义</p></li>
<li><p>与文件系统中的目录对应</p></li>
<li><p>主要目的是<em>防止命名冲突</em></p></li>
</ul></li>
<li><p>Jar (Java Archive File)</p>
<ul>
<li><p>是编译后的Java代码(<code>.class</code>)的压缩包</p></li>
<li><p>实际上是一个zip格式文件</p></li>
<li><p>对Jar的操作用<code>jar</code>命令, 其语法类似Linux下的<code>tar</code></p>
<ul>
<li><p>创建Jar包: <code>jar cvf test.jar test</code></p></li>
<li><p>解压Jar包: <code>jar xvf test.jar</code></p></li>
<li><p>列举Jar包的内容: <code>jar tvf test.jar</code></p></li>
</ul></li>
</ul></li>
<li><p>模块 (Module)</p>
<ul>
<li><p>是Java语言内置的一种管理组件之间依赖关系的方法, 在Java 9被引入</p></li>
<li><p>Module 解决的问题:</p>
<ul>
<li><p>在Java 9之前, <strong>主要使用package作为封装方式，使用Jar作为模块, 封装方式由 package和访问修饰符 (private, protected, public,包私有) 控制</strong></p>
<ul>
<li><p>任何模块都能访问其他模块的public的代码，不同Jar下的同名包可以相互访问包私有的代码。</p></li>
<li><p>无法控制非平台开发者对平台内部包的访问，如应用代码可以访问sun.misc、com.sun.security这样和具体平台绑定的包。</p></li>
<li><p>没有明确的依赖信息，模块开发者无法设置必须的依赖，模块使用者不清楚该模块必须依赖哪些模块。只能使用外部的工具，如Maven、Gradle、OSGI等。</p></li>
</ul></li>
</ul></li>
<li><p>Module 的优势</p>
<ul>
<li><p>明确的依赖配置，JPMS会在编译和运行之前检查当前环境是否满足依赖的要求。JPMS会检查版本冲突，即当有两个模块暴露了相同的包名时，系统会抛出异常。JPMS支持传递性依赖。</p></li>
<li><p>强大的封装，模块可以明确指定哪些包能暴露给哪些模块，JPMS不允许代码使用反射的方式访问不对外开放的包。</p></li>
<li><p>性能优化，JPMS完全清楚哪些模块是需要的，所以不需要的模块不会被JVM载入。</p></li>
</ul></li>
<li><p>Module 的不足:</p>
<ul>
<li>缺乏对模块的版本的支持</li>
</ul></li>
<li><p>特点:</p>
<p><img src="https://frezcirno.github.io/static/images/2020-12-04-java-module.jpg" /></p></li>
</ul></li>
</ul>
<h1 id="linux-ubuntu-硬件管理">Linux (Ubuntu) 硬件管理</h1>
<ul>
<li><p>通用</p>
<ul>
<li><code>lshw -short</code>: 列举所有硬件信息</li>
</ul></li>
<li><p>CPU</p>
<ul>
<li><p><code>lscpu</code>: 查看CPU信息</p></li>
<li><p><code>cat /proc/cpuinfo</code>: 查看每个CPU的信息</p></li>
</ul></li>
<li><p>内存</p>
<ul>
<li><p><code>free [-m|-g|-k|-b|-h]</code>: 查看内存使用情况</p></li>
<li><p><code>cat /proc/meminfo</code>: 查看内存详细使用情况</p></li>
<li><p><code>dmidecode -t memory</code>: 查看内存硬件信息</p></li>
</ul></li>
<li><p>硬盘</p>
<ul>
<li><p><code>lsblk</code>: 查看硬盘和分区信息</p></li>
<li><p><code>fdisk -l</code>: 查看详细分区表</p></li>
<li><p><code>df -h</code>: 查看硬盘剩余空间</p></li>
</ul></li>
<li><p>主板 BIOS</p>
<ul>
<li><code>dmidecode -t bios</code>: 查看bios信息</li>
</ul></li>
<li><p>PCI设备</p>
<ul>
<li><code>lspci</code></li>
</ul></li>
<li><p>网卡</p>
<ul>
<li><p><code>lspci | grep -i 'Ethernet'</code>: 查看网卡硬件信息 (Ethernet 以太网)</p></li>
<li><p><code>lspci | grep -i 'Wireless'</code>: 查看无线网卡硬件信息</p></li>
<li><p><code>ifconfig -a</code>: 查看系统的所有网络接口</p></li>
</ul></li>
<li><p>USB 设备</p>
<ul>
<li><code>lsusb</code></li>
</ul></li>
</ul>
<h1 id="apt-remove-与-apt-purge-的区别">apt remove 与 apt purge 的区别</h1>
<ul>
<li>purge会删除配置文件, 而remove只会删除程序文件</li>
</ul>
<h1 id="java-学习">Java 学习</h1>
<ul>
<li><p>Java多线程</p>
<ul>
<li>interrupt() 向该进程发送中断信号, 具体怎么处理由该进程实现</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/05/2020-12-05/</url>
    <content><![CDATA[<h1 id="java-spring-框架学习">Java Spring 框架学习</h1>
<p>Spring框架，它最主要的功能就是管理一堆使App（应用）发挥功能的类，这些作为整个App的基石、主干的类，就叫做bean。</p>
<p>要管理bean，也即是这堆发挥业务功能的类，就不能直接把它们new出来，这样缺乏统一的调度。所以，Spring使用.xml配置文件作为媒介，以IoC（Inversion of Control 控制反转）作为工具，将这些bean拿给Spring container作统一管理。</p>
<h1 id="git-submodule-使用">Git submodule 使用</h1>
<ul>
<li><p>添加子模块</p>
<ul>
<li><code>git submodule add &lt;url&gt; &lt;path&gt;</code></li>
</ul></li>
<li><p>设置子模块的分支</p>
<ul>
<li><code>git submodule set-branch --branch &lt;branch&gt; &lt;path&gt;</code></li>
</ul></li>
<li><p>克隆下来的项目包含子模块</p>
<p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git submodule init</span><br><span class="line">$ git submodule update</span><br></pre></td></tr></table></figure></p>
<p>或者</p>
<p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p></li>
<li><p>子模块的更新</p>
<ol type="1">
<li><p>在子模块内部, 作为一般的git项目更新(<code>pull</code>)</p></li>
<li><p>在项目目录下<code>git add</code></p></li>
</ol></li>
<li><p>子模块的删除</p>
<ul>
<li><p><code>rm -rf 子模块目录</code> 删除子模块目录及源码</p></li>
<li><p>删除项目目录下.gitmodules文件中子模块相关条目</p></li>
<li><p>vi .git/config 删除配置项中子模块相关条目</p></li>
<li><p><code>rm .git/module/*</code> 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可</p></li>
</ul></li>
</ul>
<h1 id="github-开源项目包含不想公开的密码token等怎么处理">Github 开源项目包含不想公开的密码/Token等怎么处理</h1>
<p>可以将隐私数据包含在项目的Secret设置中, 在Github Action中使用脚本将隐私数据注入到文件中</p>
<h1 id="yaml-语言">YAML 语言</h1>
<p>基本类型:</p>
<blockquote>
<ul>
<li><p>String</p></li>
<li><p>Bool: <code>true</code>, <code>false</code></p></li>
<li><p>Int</p></li>
<li><p>Number</p></li>
<li><p>null: <code>~</code></p></li>
<li><p>Time: ISO8601 格式, 例<code>2001-12-14t21:59:43.10-05:00</code></p></li>
<li><p>Date: <code>1976-07-31</code></p></li>
</ul>
</blockquote>
<p>注释: <code>#</code></p>
<p>使用左端对齐的键值对表示对象: <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">key1:</span> <span class="string">abc</span></span><br><span class="line">  <span class="attr">key2:</span> <span class="number">123</span></span><br><span class="line">  <span class="attr">key3:</span> <span class="string">sss</span></span><br></pre></td></tr></table></figure></p>
<p>使用以<code>-</code>开头的对齐的值表示数组: <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fruits:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">orange</span></span><br></pre></td></tr></table></figure></p>
<p>数组套对象: <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">objs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">object</span> <span class="string">A</span></span><br><span class="line">    <span class="attr">desp:</span> <span class="string">I&#x27;am</span> <span class="string">an</span> <span class="string">object</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Object</span> <span class="string">B</span></span><br><span class="line">    <span class="attr">desp:</span> <span class="string">I&#x27;am</span> <span class="string">another</span> <span class="string">object</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Object</span> <span class="string">C</span></span><br><span class="line">    <span class="attr">desp:</span> <span class="string">I&#x27;am</span> <span class="string">still</span> <span class="string">an</span> <span class="string">object</span></span><br></pre></td></tr></table></figure></p>
<p>数组套数组: <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">matrix:</span> </span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">a11</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a12</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a13</span></span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">a21</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a22</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a23</span></span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">a31</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a32</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a33</span></span><br></pre></td></tr></table></figure></p>
<p>对象套数组: <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">frezcirno</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Boy</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Handsome</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Student</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Cool</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/06/2020-12-06/</url>
    <content><![CDATA[<h1 id="学习oracle使用">学习Oracle使用</h1>
<p><a href="../oracledb/index">OracleDB</a></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/07/2020-12-07/</url>
    <content><![CDATA[<h1 id="visio-画图如何添加自定义连接点">Visio 画图如何添加自定义连接点</h1>
<p>在工具栏选中"连接点"</p>
<p>按住<kbd>Ctrl</kbd>键, 在画布上点击即可</p>
<p>有时候可能需要多点几次</p>
<h1 id="为什么校园网这么卡">为什么校园网这么卡</h1>
<h1 id="linux-创建用户时忘了使用-m参数创建用户目录怎么办">Linux 创建用户时忘了使用<code>-m</code>参数创建用户目录怎么办</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mkhomedir_helper &lt;username&gt;</span><br></pre></td></tr></table></figure>
<h1 id="xargs-命令">xargs 命令</h1>
<p>xargs命令用于将上一个命令通过管道输出的内容, 作为命令行参数传递给下一个命令</p>
<p>xargs后面的命令默认是echo</p>
<p>即: stdin -&gt; **argv</p>
<h1 id="tee-命令">tee 命令</h1>
<p>tee命令用于将标准输入复制多份, 分别输出到不同的文件, 并输出到标准输出中去</p>
<p>可以用来复制文件</p>
<ul>
<li><p>输出管道中某一段的内容: <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">... | <span class="built_in">tee</span> &gt;(xargs <span class="built_in">echo</span>) &gt;/dev/null | ...</span><br></pre></td></tr></table></figure></p></li>
<li><p>不退出vim使用sudo保存文件</p></li>
</ul>
<p>命令<code>:w !&#123;cmd&#125;</code>表示把当前缓冲区的内容传给后面的命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:w !sudo <span class="built_in">tee</span> % </span><br></pre></td></tr></table></figure>
<h1 id="echo-命令">echo 命令</h1>
<p>echo命令用于将命令行参数输出到标准输出</p>
<p>即: stdin -&gt; stdout</p>
<h1 id="awk-命令">awk 命令</h1>
<p>强大的字符串处理工具</p>
<p>最基本的用法: <code>awk '&#123;print$1,$2&#125;'</code></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Visio</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/09/2020-12-09/</url>
    <content><![CDATA[<h1 id="spring学习">Spring学习</h1>
<h2 id="ioc容器">IoC容器</h2>
<p>Spring类似一个类实例的工厂, 我们提供配置文件(.Java, .xml), Spring按照配置文件装配产品.</p>
<p>Spring的核心IoC容器接口是<code>ApplicationContext</code>，并提供了多种实现类: 例如读取xml文件的<code>ClassPathXmlApplicationContext</code>, 使用注解的<code>AnnotationConfigApplicationContext</code></p>
<h2 id="java的web框架">Java的Web框架</h2>
<ul>
<li><p>Struts: 最古老的一个MVC框架，目前版本是2，和1.x有很大的区别；</p></li>
<li><p>WebWork(Struts 2.0): 一个比Struts设计更优秀的MVC框架；</p></li>
<li><p>Turbine: 一个重度使用Velocity，强调布局的MVC框架；</p></li>
<li><p>其他100+MVC框架……（略）</p></li>
</ul>
<p>Spring本身也开发了一个MVC框架，就叫Spring MVC。</p>
<h2 id="spring连接数据库">Spring连接数据库</h2>
<ul>
<li><p>使用jdbcTemplate</p></li>
<li><p>使用Hibernate集成框架</p></li>
<li><p>使用MyBatis集成框架</p></li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/10/2020-12-10/</url>
    <content><![CDATA[<h1 id="java的orm框架-vs-python的orm框架">Java的ORM框架 vs Python的ORM框架</h1>
<p>TODO: 待更新</p>
<h1 id="为什么需要cors-cors是为了保护谁">为什么需要CORS? CORS是为了保护谁?</h1>
<p>CORS标准允许服务器指定谁可以访问该服务器上的资源, 以及该如何访问这些资源</p>
<p>所以说其实是保护服务器端, 防止恶意网站窃取数据</p>
<h1 id="信息安全之盲水印">信息安全之盲水印</h1>
<p><a href="https://www.zhihu.com/question/50735753">妙啊</a></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ORM框架</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/11/2020-12-11/</url>
    <content><![CDATA[<h1 id="linux-内核提权">Linux 内核提权</h1>
<ul>
<li>获取内核版本</li>
</ul>
<p><code>uname -a</code></p>
<p><code>lsb_release -a</code></p>
<ul>
<li>查询可用的exploit</li>
</ul>
<p>在Kali中 <code>searchsploit Linux x.x.xx priv</code></p>
<p>人工筛选</p>
<ul>
<li>传到目标机器上碰运气</li>
</ul>
<h1 id="gcc编译参数">gcc编译参数</h1>
<p>目标机器上的header/lib可能不能正常使用, 此时可以下载一套header/lib放在用户目录, 用下面的方式指定</p>
<p>指定include目录: <code>-I&lt;path&gt;</code></p>
<p>指定连接库目录: <code>-L&lt;path&gt; -l&lt;libname&gt;</code></p>
<h1 id="忘了报名ncre-难过">忘了报名NCRE, 难过</h1>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>GCC使用</tag>
        <tag>NCRE</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/12/2020-12-12/</url>
    <content><![CDATA[<h1 id="线性代数">线性代数</h1>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/13/2020-12-13/</url>
    <content><![CDATA[<h1 id="c-stl中unique的用法">C++ STL中unique的用法</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line">  <span class="function">ForwardIterator <span class="title">unique</span> <span class="params">( ForwardIterator first, ForwardIterator last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line">  <span class="function">ForwardIterator <span class="title">unique</span> <span class="params">( ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                           BinaryPredicate pred )</span></span>;</span><br></pre></td></tr></table></figure>
<p>将[first, last)之间, <strong>相邻</strong>的多个相同元素合并为一个, 返回指向不重复部分末尾的迭代器. 多和sort函数一起使用</p>
<p>例: 使用unique实现<a href="https://oi-wiki.org/misc/discrete/">离散化</a>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector&lt;int&gt; array;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> disc = array;</span><br><span class="line"><span class="built_in">sort</span>(disc.<span class="built_in">begin</span>(), disc.<span class="built_in">end</span>());</span><br><span class="line">disc.<span class="built_in">erase</span>(<span class="built_in">unique</span>(disc.<span class="built_in">begin</span>(), disc.<span class="built_in">end</span>()), disc.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; disc.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  disc[i] = <span class="built_in">lower_bound</span>(array.<span class="built_in">begin</span>(), array.<span class="built_in">end</span>(), disc[i]) - array.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 那么disc就可以作为离散化之后的索引</span></span><br><span class="line"><span class="comment">// disc[i] = array中第i种元素的最小下标</span></span><br></pre></td></tr></table></figure>
<h1 id="ccfcsp">CCFCSP</h1>
<p>今天考了CCF CSP.</p>
<h1 id="区间树interval-tree和线段树segment-tree">区间树(Interval Tree)和线段树(Segment Tree)</h1>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>CCFCSP</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/14/2020-12-14/</url>
    <content><![CDATA[<h1 id="满课-摸了">满课, 摸了</h1>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/15/2020-12-15/</url>
    <content><![CDATA[<h1 id="为什么要使用mongodb">为什么要使用mongodb</h1>
<ul>
<li><p>不需要预先定义schema即可存储数据, 适合于快速原型开发, 以及需求经常变更的情况</p></li>
<li><p>存储使用的BSON格式非常灵活, 可以表示像数组, 字典这样的数据, 而在RDB中需要拆分成多个表</p></li>
</ul>
<h1 id="sitemap">Sitemap</h1>
<blockquote>
<p>站点地图（英语：Sitemaps，旧称Google Sitemaps，也写为Sitemap；又称网站地图）是一种列有某个网站所有网址（URL）的XML文件，由Google最先发起。利用Sitemaps协议，网站管理员可以列出网站上可以供搜索引擎抓取的URL，并通知给后者。Sitemaps中包含有关每个URL的其他信息，如URL上次更新的时间、更新的频率以及相对于网站其他URL的重要性。搜索引擎的爬虫可以通过Sitemaps更有效地抓取网站内容，并找到可能与网站其他内容没有相互链接的URL。Sitemaps协议是对robots.txt的补充。</p>
</blockquote>
<p>简单来说就是列举了网站所有页面的一个xml文件, 附带了一些meta信息, 有利于搜索引擎抓取, SEO方法之一.</p>
<p>一般通过程序生成</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Sitemap</tag>
        <tag>SEO</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/16/2020-12-16/</url>
    <content><![CDATA[<h1 id="spring-security">Spring Security</h1>
<h1 id="jwt">JWT</h1>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/17/2020-12-17/</url>
    <content><![CDATA[<h1 id="spring-doc-openapi-注解">Spring-doc OpenAPI 注解</h1>
<p><span class="citation" data-cites="Operation">@Operation</span> <span class="citation" data-cites="Response">@Response</span> <span class="citation" data-cites="Parameter">@Parameter</span></p>
<h1 id="ubuntu设置代理">Ubuntu设置代理</h1>
<p>启动clash for linux</p>
<ul>
<li><p>配置代理地址配置文件</p></li>
<li><p>配置restAPI地址和访问密码</p></li>
<li><p>将clash作为一个daemon进程:</p>
<ul>
<li><p>使用systemd:</p>
<p>先创建配置文件<code>/etc/systemd/system/clash.service</code></p>
<p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash Daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/bin/clash -d /etc/clash/</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>然后clash就成为了一个service, 可以通过systemctl命令启动, 通过journalctl命令查看日志等</p></li>
<li><p>使用pm2: <code>pm2 start clash</code></p></li>
</ul></li>
<li><p>在.bashrc或者.zshrc文件底部设置</p></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> all_proxy=<span class="string">&#x27;socks5://localhost:7891&#x27;</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&#x27;http://localhost:7890&#x27;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&#x27;http://localhost:7890&#x27;</span></span><br><span class="line"><span class="built_in">export</span> ftp_proxy=<span class="string">&#x27;http://localhost:7890&#x27;</span></span><br><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">&#x27;localhost,127.0.0.1&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="shell的类型">Shell的类型</h1>
<h2 id="shell的类型-1">shell的类型</h2>
<p>常见的shell有sh, bash, zsh等,</p>
<p>查看当前使用的shell: <code>echo $SHELL</code></p>
<p>查看系统中的所有shell: <code>cat /etc/shells</code></p>
<h2 id="登录shell和非登录shell">登录shell和非登录shell</h2>
<h2 id="交互式shell和非交互式shell">交互式shell和非交互式shell</h2>
<h2 id="profile-和-.xxshrc">.profile 和 .xxshrc</h2>
<ul>
<li><p>/etc/profile 为系统的每个用户设置环境信息,当第一个用户登录时, 该文件被执行, 并从/etc/profile.d目录的配置文件中搜集shell的设置</p></li>
<li><p>/etc/xxshrc 为每一个运行xx shell的用户执行此文件. 当xx shell被打开时, 该文件被读取。有些linux版本中的/etc目录下已经没有了该文件。</p></li>
<li><p>~/.profile 每个用户都可使用该文件输入专用于自己使用的shell信息, 当用户登录时,该文件仅仅执行一次 默认情况下,它设置一些环境变量,然后执行用户的.xxshrc文件.</p></li>
<li><p>~/.xxshrc 该文件包含专用于某个用户的xx shell的配置, 当该用户登录时以及每次打开新的xx shell时,该文件被读取.</p></li>
</ul>
<h1 id="hexo-layout">Hexo layout</h1>
<p>hexo中每种不同的页面样式称为一个layout</p>
<p>根据md放置的位置不同, 使用的layout也不同</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/18/2020-12-18/</url>
    <content><![CDATA[<h1 id="oracle-apex怎么调用procedure">Oracle Apex怎么调用procedure</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">  ANALYSIS(<span class="number">6</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/19/2020-12-19/</url>
    <content><![CDATA[<h1 id="spring中filter和interceptor的区别">Spring中Filter和Interceptor的区别</h1>
<p>Filter和Interceptor都可以实现对请求的拦截</p>
<h2 id="功能定位">功能定位</h2>
<p>都可以用来实现用户认证</p>
<h2 id="区别">区别</h2>
<ul>
<li><p>定义规范不同</p>
<p>Filter是Servlet的规范; 而Interceptor是Spring框架提供的类似的拦截器</p></li>
<li><p>拦截范围不同</p>
<p>Filter的拦截范围是Servlet层; Interceptor的拦截范围是Controller层</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    │   ▲</span><br><span class="line">    ▼   │</span><br><span class="line">    ┌───────┐</span><br><span class="line">    │Filter1│</span><br><span class="line">    └───────┘</span><br><span class="line">    │   ▲</span><br><span class="line">    ▼   │</span><br><span class="line">    ┌───────┐</span><br><span class="line">    │Filter2│</span><br><span class="line">    └───────┘</span><br><span class="line">    │   ▲</span><br><span class="line">    ▼   │</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│DispatcherServlet│&lt;───┐</span><br><span class="line">└─────────────────┘    │</span><br><span class="line">│              ┌────────────┐</span><br><span class="line">│              │ModelAndView│</span><br><span class="line">│              └────────────┘</span><br><span class="line">│ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ▲</span><br><span class="line">│    ┌───────────┐    │</span><br><span class="line">├─┼─&gt;│Controller1│──┼─┤</span><br><span class="line">│    └───────────┘    │</span><br><span class="line">│ │                 │ │</span><br><span class="line">│    ┌───────────┐    │</span><br><span class="line">└─┼─&gt;│Controller2│──┼─┘</span><br><span class="line">    └───────────┘</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure></p></li>
<li><p>管理方式不同</p>
<p>Filter由Servlet容器管理, 需要使用<code>DelegatingFilterProxy</code>代理类才能被Spring集成; Interceptor直接由Spring IoC容器管理</p></li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/19/2020-12-20/</url>
    <content><![CDATA[<h1 id="昨天通宵今天摸了">昨天通宵，今天摸了</h1>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/23/2020-12-23/</url>
    <content><![CDATA[<h1 id="做java项目">做Java项目</h1>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/25/2020-12-25/</url>
    <content><![CDATA[<h1 id="java-答辩结束了-yeah">Java 答辩结束了, Yeah!</h1>
<p>今天开始刷题</p>
<h1 id="hash-map-hash-set-vs-tree-map-tree-set">Hash Map, Hash Set vs Tree Map, Tree Set</h1>
<p>c++中的<code>map</code>, <code>set</code>默认是treemap和treeset, 底层基于红黑树, 元素始终保持有序</p>
<p>而<code>unordered_map</code>, <code>unordered_set</code>底层基于哈希表</p>
<h2 id="对比">对比</h2>
<p>查询/插入/删除</p>
<table>
<thead>
<tr class="header">
<th>数据结构</th>
<th>底层</th>
<th>find/get/contain</th>
<th>set</th>
<th>delete</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>map</td>
<td>tree</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr class="even">
<td>unordered_map</td>
<td>hash</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>数据结构</th>
<th>底层</th>
<th>find/contain</th>
<th>insert</th>
<th>delete</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>set</td>
<td>tree</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr class="even">
<td>unordered_set</td>
<td>hash</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
</tbody>
</table>
<p>遍历</p>
<p><code>map</code>和<code>set</code>都支持按序遍历, 而<code>unordered_map</code>, <code>unordered_set</code>天生就不适合按序遍历(底层不是按序存储), 但是可以无序遍历</p>
<h1 id="java-项目总结">Java 项目总结</h1>
<h2 id="前端">前端</h2>
<h2 id="后端">后端</h2>
<h3 id="java-web项目的基本结构">Java Web项目的基本结构</h3>
<p>Controller层: 前端实际调用的接口, 包括用户鉴权, 页面跳转等等, 接口内部调用Service层来实现功能.</p>
<p>Service层: 实际的业务逻辑, 一般按照功能分包, 尽量做到与Controller层脱钩, 一般都是些无状态函数(对环境不做任何假设)</p>
<p>DAO层: 与数据库相关的代码, 也被称为持久层</p>
<h3 id="spring框架">Spring框架</h3>
<p>Spring框架的核心:</p>
<ol type="1">
<li><p>通过依赖注入来降低代码之间的耦合(IoC控制反转)</p>
<p>例如: <code>@Autowired</code>, <code>@Bean</code>, <code>@Resource</code></p></li>
<li><p>对AOP的支持</p>
<p>这个没怎么用到</p></li>
<li><p>对各种工具的集成和支持</p>
<p>例如: Spring Data JPA, Spring Security等等</p></li>
</ol>
<h3 id="spring-boot框架">Spring Boot框架</h3>
<p>Spring Boot能够自动识别项目中开启的功能(通过扫描安装的依赖包or配置文件?)</p>
<p>项目配置全部写在<code>application.[properties|yml]</code>中, 框架会自动识别</p>
<p>也可以自己定义一些key, 在代码中通过<code>@Value("xxx.yyy")</code>注入</p>
<h3 id="jwt鉴权">JWT鉴权</h3>
<p><a href="https://jwt.io/">JWT</a>的三部分: <code>Header.Payload.Signature</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Header</span> = &#123;<span class="string">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span>,<span class="string">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Payload</span> = &#123;<span class="string">&quot;sub&quot;</span>:<span class="string">&quot;1234567890&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;John Doe&quot;</span>,<span class="string">&quot;iat&quot;</span>:<span class="number">1516239022</span>&#125;</span><br><span class="line"></span><br><span class="line">_Header64 = <span class="title function_">base64UrlEncode</span>(<span class="title class_">Header</span>)</span><br><span class="line">_Payload64 = <span class="title function_">base64UrlEncode</span>(<span class="title class_">Payload</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Signature</span> = <span class="title class_">HMACSHA256</span>(<span class="string">`<span class="subst">$&#123;_Header64&#125;</span>.<span class="subst">$&#123;_Payload64&#125;</span>`</span>, $&#123;your-<span class="number">256</span>-bit-secret&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">JWT</span> = <span class="string">`<span class="subst">$&#123;_Header64&#125;</span>.<span class="subst">$&#123;_Payload64&#125;</span>.<span class="subst">$&#123;Signature&#125;</span>`</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>答辩</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/28/2020-12-28/</url>
    <content><![CDATA[<h1 id="su-user-和-su---user的区别">su user 和 su - user的区别</h1>
<p><code>$ su user</code>启动nologin shell</p>
<p><code>$ su - user</code>启动login shell</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/27/2020-12-27/</url>
    <content><![CDATA[<h1 id="配环境心得">配环境心得</h1>
<p>放平心态</p>
<h1 id="linux之图形化界面">Linux之图形化界面</h1>
<h2 id="x-vs.-wayland">X vs. Wayland</h2>
<p>X是最广泛使用的linux显示服务器, 是底层的图形化界面显示标准</p>
<h2 id="display-manager">Display Manager</h2>
<p>显示管理器(或登录管理器)是一个在启动最后显示的图形界面. 负责管理用户登录, 启动X等等. 有些集成在桌面环境中.</p>
<p>用户一般直接与显示管理器打交道.</p>
<p>常见的显示管理器有:</p>
<ul>
<li>GDM(GNOME)</li>
<li>LXDM(LXDE)</li>
<li>lightDM(支持多种DE) 等等</li>
</ul>
<h2 id="desktop-environment">Desktop Environment</h2>
<p>桌面环境通过汇集使用相同组件库的程序, 为用户提供了完全的图形用户界面.</p>
<p>常见的桌面环境有:</p>
<ul>
<li>GNOME</li>
<li>KDE</li>
<li>Xfce 等等</li>
</ul>
<h2 id="远程桌面">远程桌面</h2>
<ul>
<li>xdmcp</li>
<li>vnc</li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2020/12/30/2020-12-30/</url>
    <content><![CDATA[<h1 id="计网答辩顺利">计网答辩顺利</h1>
<p>开心!</p>
<h1 id="wifi协议802.11扫盲">WiFi协议(802.11)扫盲</h1>
<h2 id="基本概述">基本概述</h2>
<ol type="1">
<li><p>有线与无线网络</p>
<p>当前有线网络中最著名的是以太网(Ethernet), 无线网络中最有前景的是WiFi.</p>
<p>无线网络的缺点:</p>
<ul>
<li>通信双方因为是通过无线进行通信，所以通信之前需要建立连接；而有线网络就直接用线缆连接，不用这个过程了。</li>
<li>通信双方通信方式是半双工的通信方式；而有线网络可以是全双工。</li>
<li>通信时在网络层以下出错的概率非常高，所以帧的重传概率很大，需要在网络层之下的协议添加重传的机制（不能只依赖上面TCP/IP的延时等待重传等开销来保证）；而有线网络出错概率非常小，无需在网络层有如此复杂的机制。</li>
<li>数据是在无线环境下进行的，所以抓包非常容易，存在安全隐患。</li>
<li>因为收发无线信号，所以功耗较大，对电池来说是一个考验。</li>
<li>相对有线网络吞吐量低，这一点正在逐步改善，802.11n协议可以达到600Mbps的吞吐量。</li>
</ul></li>
<li><p>协议</p>
<p>Ethenet和Wifi采用的协议都属于IEEE 802协议集。其中，Ethenet以802.3协议做为其网络层以下的协议；而Wifi以802.11做为其网络层以下的协议。无论是有线网络，还是无线网络，其网络层以上的部分，基本一样。</p></li>
<li><p>术语</p>
<p>讲述之前，我们需要对无线网络中一些常用的术语有所了解。这里先列出一些，后面描述中出现的新的术语，将会在描述中解释。</p>
<ul>
<li><p>LAN：即局域网，是路由和主机组成的内部局域网，一般为有线网络。</p></li>
<li><p>WAN：即广域网，是外部一个更大的局域网。</p></li>
<li><p>WLAN（Wireless LAN，即无线局域网）：前面我们说过LAN是局域网，其实大多数指的是有线网络中的局域网，无线网络中的局域网，一般用WLAN。</p></li>
<li><p>AP（Access point的简称，即访问点，接入点）：是一个无线网络中的特殊节点，通过这个节点，无线网络中的其它类型节点可以和无线网络外部以及内部进行通信。这里，AP和无线路由都在一台设备上（即Cisco E3000）。</p></li>
<li><p>Station（工作站）：表示连接到无线网络中的设备，这些设备通过AP，可以和内部其它设备或者无线网络外部通信。</p></li>
<li><p>Assosiate：连接。如果一个Station想要加入到无线网络中，需要和这个无线网络中的AP关联（即Assosiate）。</p></li>
<li><p>SSID：用来标识一个无线网络，后面会详细介绍，我们这里只需了解，每个无线网络都有它自己的SSID。</p></li>
<li><p>BSSID：用来标识一个BSS，其格式和MAC地址一样，是48位的地址格式。一般来说，它就是所处的无线接入点的MAC地址。某种程度来说，它的作用和SSID类似，但是SSID是网络的名字，是给人看的，BSSID是给机器看的，BSSID类似MAC地址。</p></li>
<li><p>BSS（Basic Service Set）：由一组相互通信的工作站组成，是802.11无线网络的基本组件。主要有两种类型的IBSS和基础结构型网络。IBSS又叫ADHOC，组网是临时的，通信方式为Station&lt;-&gt;Station，这里不关注这种组网方式；我们关注的基础结构形网络，其通信方式是Station&lt;-&gt;AP&lt;-&gt;Station，也就是所有无线网络中的设备要想通信，都得经过AP。在无线网络的基础形网络中，最重要的两类设备：AP和Station。</p></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>答辩</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年度总结</title>
    <url>/2021/01/05/2020-final/</url>
    <content><![CDATA[<h2 id="进步">进步</h2>
<h3 id="装备升级">装备升级</h3>
<ul>
<li><p>新增显示器</p></li>
<li><p>新增一个Pad</p></li>
</ul>
<h3 id="技术进步">技术进步</h3>
<ul>
<li><p>新开了Blog!</p></li>
<li><p>开始刷算法题, 并已经刷了一些</p></li>
<li><p>前端技术更加熟练了</p>
<ul>
<li><p>Vue/React双线操作</p></li>
<li><p>简单页面能够快速开发</p></li>
</ul></li>
<li><p>Python更加熟练了</p>
<ul>
<li><p>爬虫技术</p></li>
<li><p>数据处理技术</p></li>
<li><p>AI/DL</p></li>
</ul></li>
<li><p>Java语言入门</p>
<ul>
<li>Spring框架</li>
</ul></li>
<li><p>iOS应用开发入门</p>
<ul>
<li><p>Swift语言入门</p></li>
<li><p>SpriteKit游戏 * 1</p></li>
</ul></li>
</ul>
<h3 id="综合能力">综合能力</h3>
<ul>
<li><p>表达能力略微提升</p></li>
<li><p>管理能力略微提升</p></li>
</ul>
<h3 id="人际关系">人际关系</h3>
<ul>
<li>认识了很多新朋友!</li>
</ul>
<h2 id="不足">不足</h2>
<h3 id="任务调度">任务调度</h3>
<ul>
<li>时间利用率不高, 为完成项目曾多次通宵</li>
</ul>
<h3 id="管理-组织能力">管理, 组织能力</h3>
<ul>
<li>小组合作时, 作为组长, 任务分配还有待优化</li>
</ul>
<h3 id="心态">心态</h3>
<ul>
<li>有时候会比较焦虑</li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2021/01/05/2021-01-05/</url>
    <content><![CDATA[<h1 id="关于ddl的疑惑">关于DDL的疑惑</h1>
<p>为什么ddl推迟, 开始肝ddl的时间也跟着推迟?</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>摸鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2021/01/04/2021-01-04/</url>
    <content><![CDATA[<h1 id="ios答辩">iOS答辩</h1>
<h1 id="数据仓库答辩">数据仓库答辩</h1>
<h2 id="答辩心得">答辩心得:</h2>
<h3 id="关于ppt">关于PPT</h3>
<ol type="1">
<li>Explicit is better than Implicit!</li>
</ol>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>答辩</tag>
        <tag>PPT制作</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2021/01/07/2021-01-07/</url>
    <content><![CDATA[<h2 id="关于url末尾的斜杠">关于URL末尾的斜杠</h2>
<p>URL末尾有无斜杠会对按相对路径加载的资源造成影响</p>
<table>
<thead>
<tr class="header">
<th>路径</th>
<th>当前渲染的文件</th>
<th>当前目录</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>foobar.com/example<b>/</b></td>
<td><strong>/example/index.html</strong></td>
<td><strong>/example</strong></td>
</tr>
<tr class="even">
<td>foobar.com/example</td>
<td><strong>/example.html</strong></td>
<td><strong>/</strong></td>
</tr>
</tbody>
</table>
<p>按绝对路径加载的资源不会受到影响</p>
<h2 id="uwsgi作为daemon启动">uwsgi作为daemon启动</h2>
<h3 id="方法1">方法1</h3>
<p>添加<code>-d</code>参数</p>
<p><code>$ uwsgi -d --ini app.ini</code></p>
<h3 id="方法2">方法2</h3>
<p>在ini文件中添加<code>daemonize = /var/log/uwsgi.log</code></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>uwsgi</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2021/01/08/2021-01-08/</url>
    <content><![CDATA[<h2 id="没什么成果的一天">没什么成果的一天</h2>
<p>复习线代</p>
<p>配Oracle, timesten</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>摸鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2021/01/09/2021-01-09/</url>
    <content><![CDATA[<h2 id="动态规划">动态规划</h2>
<h3 id="特点">特点</h3>
<ul>
<li>重叠子问题</li>
<li>最优子结构</li>
<li>状态转移方程</li>
<li>状态压缩</li>
</ul>
<h3 id="思路">思路</h3>
<ol type="1">
<li>找出所有的<strong>状态</strong></li>
<li>列举dp数组</li>
<li>找出状态转移方程</li>
</ol>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2021/01/10/2021-01-10/</url>
    <content><![CDATA[<h2 id="模运算的性质程序设计版">模运算的性质(程序设计版)</h2>
<p>模运算与基本四则运算有些相似，但是除法例外。其规则如下：</p>
<p><span class="math display">\[(a + b)\bmod p = (a\bmod p + b\bmod p)\bmod p\]</span> <span class="math display">\[(a - b)\bmod p = (a\bmod p - b\bmod p)\bmod p\]</span> <span class="math display">\[(a \times b)\bmod p = (a\bmod p \times b\bmod p)\bmod p\]</span> <span class="math display">\[(a^b)\bmod p = ((a\bmod p)^b)\bmod p\]</span></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2021/01/12/2021-01-12/</url>
    <content><![CDATA[<h2 id="c11新特性之右值引用">c++11(新?)特性之右值引用</h2>
<h3 id="右值">右值</h3>
<p>不能放到赋值表达式左侧的值</p>
<p>例如: - 字面量 <code>1, "Hello", 'c'</code> - 返回值而非引用的函数调用 <code>foo()</code> - 运算结果 <code>a + b</code></p>
<p>右值不能被直接赋值给一个<strong>非常</strong>引用, 只能先赋给一个变量再取引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp; ref = <span class="number">9</span>; <span class="comment">// error, “invalid initialization of non-const reference of type int&amp; from an rvalue of type int”</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; const_ref = <span class="number">9</span>; <span class="comment">// only allow this</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nine = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = nine; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>上述特性在泛型函数重载时会带来一些问题, 这导致我们不得不对有无const两种情况分别重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A1&gt;</span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">factory</span><span class="params">(A1&amp; a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(a1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">factory</span>&lt;foo&gt;(<span class="number">5</span>); <span class="comment">// error, a1-&gt;int&amp;, can not bind to literal 5 </span></span><br></pre></td></tr></table></figure>
<h3 id="右值引用">右值引用</h3>
<p>顾名思义, 就是对右值的引用</p>
<h3 id="增加右值引用的好处">增加右值引用的好处</h3>
<p>增加了右值引用之后, 我们具备了识别和重载右值的能力</p>
<h4 id="进一步消除不必要的复制">进一步消除不必要的复制</h4>
<p>在c++11之前, 临时变量的创建一直是难以处理的问题. 有时这些临时变量可以被编译器优化（例如返回值优化）, 但是这并不总是可行的, 通常这会导致高昂的对象复制成本.</p>
<p>考虑下面的代码, 理论上这里最多可能发生两次复制操作:</p>
<ol type="1">
<li><p>返回临时变量</p></li>
<li><p>vector赋值</p></li>
</ol>
<p>其中, 第一次的复制操作可能会被编译器优化掉(RVO), 然而第二次复制是不可避免的</p>
<p>当然我们可以通过其他方法来避免这次复制, 比如通过指针或者传递一个已经填充好的vector</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">make_poem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; lines;</span><br><span class="line">    lines.<span class="built_in">push_back</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    lines.<span class="built_in">push_back</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> lines; <span class="comment">// 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; poem;</span><br><span class="line">    poem = <span class="built_in">make_poem</span>(); <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了右值引用之后, 我们可以就可以对右值进行特殊化处理, 从而避免多余的复制(移动构造函数和=运算符重载), 例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copy</span></span><br><span class="line"><span class="built_in">foo</span>(foo <span class="type">const</span>&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;length = other.length;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ptr = <span class="keyword">new</span> <span class="type">int</span>[other.length];</span><br><span class="line">    <span class="built_in">copy</span>(other.ptr, other.ptr + other.length, <span class="keyword">this</span>-&gt;ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与之对应的move</span></span><br><span class="line"><span class="built_in">foo</span>(foo&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;length = other.length;</span><br><span class="line">   <span class="keyword">this</span>-&gt;ptr = other.ptr;</span><br><span class="line">   other.length = <span class="number">0</span>;</span><br><span class="line">   other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移动语义的引入">移动语义的引入</h4>
<p>可以显式指定某个资源被移交给另一个函数, 自己不再需要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Resource resource;</span><br><span class="line"><span class="built_in">foo</span>(<span class="built_in">move</span>(resource)); <span class="comment">// 不再需要resource, 可以全权交给foo函数, 将会调用foo(Resource&amp;&amp;)</span></span><br></pre></td></tr></table></figure>
<p>对于有些不能被复制的资源(如<code>std::unique_ptr</code>, <code>std::thread</code>等等), 这是很有用的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string s;</span><br><span class="line"><span class="function">std::string <span class="title">another</span><span class="params">(s)</span></span>;           <span class="comment">// calls std::string(const std::string&amp;);</span></span><br><span class="line"><span class="function">std::string <span class="title">more</span><span class="params">(std::string(s))</span></span>; <span class="comment">// calls std::string(std::string&amp;&amp;);</span></span><br></pre></td></tr></table></figure>
<h4 id="模板的完美转发">模板的完美转发</h4>
<p>(TODO)</p>
<h3 id="实现">实现</h3>
<p><code>move</code>函数: 提醒编译器重载时选择移动构造函数</p>
<p>利用移动交换两个变量:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_swap</span><span class="params">(Res &amp;a, Res &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Res t = <span class="built_in">move</span>(a);</span><br><span class="line">    a = <span class="built_in">move</span>(b);</span><br><span class="line">    b = <span class="built_in">move</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rvo和nrvo">RVO和NRVO</h2>
<p>返回值优化（Return value optimization，缩写为RVO）是C++的一项编译优化技术。即删除保持函数返回值的临时对象。这可能会省略两次复制构造函数，<strong>即使复制构造函数有副作用</strong>。</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2021/01/19/2021-01-19/</url>
    <content><![CDATA[<h2 id="近期任务">近期任务</h2>
<ul>
<li>内存数据库最终项目</li>
<li>计算机网络实验报告</li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/2021/01/22/2021-01-22/</url>
    <content><![CDATA[<p>考试结束</p>
<p>假期的一些计划 - 完善<code>codepass</code>项目 - 刷算法题目 - 深入学习c++</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>shell脚本编程</title>
    <url>/2021/01/29/2021-01-29/</url>
    <content><![CDATA[<h1 id="注释">注释</h1>
<h2 id="单行注释">单行注释</h2>
<p>以<code>#</code>开始, 从<code>#</code>开始直到行尾都会被当做注释</p>
<h2 id="多行注释">多行注释</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p><code>EOF</code>可以换成任意内容</p>
<h1 id="变量">变量</h1>
<h2 id="定义变量">定义变量</h2>
<p><code>变量名=值</code></p>
<p>注意等号前后不能有空格</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=<span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用变量">使用变量</h2>
<p>读取变量的值时需要在前面添加<code>$</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br></pre></td></tr></table></figure>
<h2 id="修改变量">修改变量</h2>
<p>再次修改变量的值时不需要添加<code>$</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=2</span><br><span class="line">b=<span class="string">&quot;World Hello&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="只读变量">只读变量</h2>
<p><code>readonly 变量名</code></p>
<p>可以将一个变量设置为只读</p>
<h2 id="删除变量">删除变量</h2>
<p><code>unset 变量名</code></p>
<h1 id="数据类型">数据类型</h1>
<h2 id="数字">数字</h2>
<h2 id="字符串">字符串</h2>
<p>可以用单引号括起来也可以用双引号, 区别是单引号括起来的字符串不会转义</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$a\&quot;\&quot;b&#x27;</span>  <span class="variable">$a</span>\&quot;\&quot;b</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span>\&quot;\&quot;b&quot;</span>  1<span class="string">&quot;&quot;</span>b</span><br></pre></td></tr></table></figure>
<h3 id="拼接字符串">拼接字符串</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">greeting=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">name=<span class="string">&quot;world&quot;</span></span><br><span class="line">msg=<span class="string">&quot;<span class="variable">$greeting</span> <span class="variable">$name</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$msg</span>  hello world</span><br></pre></td></tr></table></figure>
<h3 id="获取字符串长度">获取字符串长度</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#msg&#125;</span>  11</span><br></pre></td></tr></table></figure>
<h3 id="截取字符串">截取字符串</h3>
<p>格式见示例, 两个参数分别为起始位置和长度</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;msg:4:3&#125;</span>  o w</span><br></pre></td></tr></table></figure>
<h1 id="数组">数组</h1>
<p><code>数组名=(元素1 元素2 ... 元素n)</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=(1 2 3)</span><br><span class="line">b=(<span class="string">&quot;Hello&quot;</span> <span class="string">&quot;,&quot;</span> <span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>也可以单独定义数组的各个分量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">arr[0]=1</span><br><span class="line">arr[1]=<span class="string">&quot;2&quot;</span></span><br><span class="line">arr[5]=3</span><br><span class="line">arr[100]=4</span><br></pre></td></tr></table></figure>
<p>shell中数组的下标从0开始, 可以不是连续的</p>
<h2 id="读取数组元素">读取数组元素</h2>
<p><code>$&#123;数据名[下标]&#125;</code></p>
<p>下标使用 <code>@</code> 符号可以获取数组中的所有元素</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[0]&#125;</span> <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[3]&#125;</span> <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span> <span class="comment"># 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<h2 id="获取数组的长度">获取数组的长度</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[@]&#125;</span>  或</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[*]&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="控制流">控制流</h1>
<h2 id="条件分支">条件分支</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="循环语句">循环语句</h2>
<p>for-in循环</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> 1 2 3 4 5; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$index</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>for-i循环</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>while循环</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$i</span>&lt;=<span class="number">5</span> ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;i++&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h1 id="调用参数">调用参数</h1>
<p>调用脚本时可以传递一些参数, 在脚本内可以通过如下转义表达式获取参数</p>
<table>
<thead>
<tr class="header">
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>$#</code></td>
<td>传递到脚本的参数个数</td>
</tr>
<tr class="even">
<td><code>$n</code></td>
<td>传递到脚本的第n个参数, 0为脚本文件名</td>
</tr>
<tr class="odd">
<td><code>$*</code></td>
<td>以一个单字符串显示所有向脚本传递的参数。</td>
</tr>
<tr class="even">
<td><code>$$</code></td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr class="odd">
<td><code>$!</code></td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr class="even">
<td><code>$@</code></td>
<td>与<code>$*</code>相同，但是每个参数都会带引号。</td>
</tr>
<tr class="odd">
<td><code>$-</code></td>
<td>显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr class="even">
<td><code>$?</code></td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Shell 传递参数实例！&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;参数个数为: <span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;执行的文件名: <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第一个参数为: <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第二个参数为: <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第三个参数为: <span class="variable">$3</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;所有参数为: $*&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前进程: $$&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy, SciPy, Matplotlib 和 Pandas 学习</title>
    <url>/2021/03/14/2021-03-14/</url>
    <content><![CDATA[<p>时间过的真快啊，转眼间已经是 <del>3</del> 4 月了！</p>
<h1 id="python-数据科学常用的库">Python 数据科学常用的库</h1>
<p><img src="https://frezcirno.github.io/static/images/v2-297731bd359ebc14978967a92f1716cb_r-1.jpg" /></p>
<h1 id="numpy-使用">Numpy 使用</h1>
<h2 id="array-对象">array 对象</h2>
<h1 id="matplotlib-使用">Matplotlib 使用</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<h1 id="pandas-使用">Pandas 使用</h1>
<h2 id="series-对象">Series 对象</h2>
<h2 id="dataframe-对象">Dataframe 对象</h2>
<p>博客更新日志：</p>
<ul>
<li>日记分类名字从「每日小结」改为「每日小结 Day Day Up」</li>
<li>日记文章标题从今往后将取有意义的名字</li>
<li>日记文件名改成更加标准的 ISO-8601 命名法</li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
        <tag>matplotlib</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>python 自定义 JSON Encoder</title>
    <url>/2021/06/15/2021-06-15/</url>
    <content><![CDATA[<h1 id="python-自定义-json-encoder">python 自定义 JSON Encoder</h1>
<p>继承 json.JSONEncoder 类, 重载 default 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_time</span>(<span class="params">dt: DateTime</span>):</span><br><span class="line">    pdt = datetime(dt.year, dt.month, dt.day, dt.hour, dt.minute,</span><br><span class="line">                   <span class="built_in">int</span>(dt.second), <span class="built_in">int</span>(dt.second * <span class="number">1000000</span> % <span class="number">1000000</span>))</span><br><span class="line">    <span class="keyword">return</span> pdt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomJSONEncoder</span>(<span class="title class_ inherited__">JSONEncoder</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">default</span>(<span class="params">self, o</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(o, DateTime):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>(CustomJSONEncoder, self).encode(convert_time(o).isoformat())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(CustomJSONEncoder, self).default(o)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabin-Karp 算法</title>
    <url>/2021/07/02/2021-07-02/</url>
    <content><![CDATA[<h1 id="rabin-karp-算法">Rabin-Karp 算法</h1>
<p>字符串匹配算法之一，利用哈希进行匹配比较，利用滚动哈希优化哈希函数</p>
<h2 id="滚动哈希">滚动哈希</h2>
<p>将滑动窗口中的字符串哈希成一个数字</p>
<p><span class="math display">\[
h_i = \sum_{p = 0}^{L - 1}{s_{i + p} b^{L - 1 - p}}
\]</span></p>
<p>其中<span class="math inline">\(L\)</span>为滑动窗口大小，<span class="math inline">\(s\)</span>为探针字符串，<span class="math inline">\(b\)</span>为基数</p>
<table>
<thead>
<tr class="header">
<th>index</th>
<th></th>
<th>-1</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>s</td>
<td>......</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td></td>
<td>......</td>
</tr>
<tr class="even">
<td><span class="math inline">\(h_{i-1}\)</span></td>
<td></td>
<td><span class="math inline">\(b^5\)</span></td>
<td><span class="math inline">\(b^4\)</span></td>
<td><span class="math inline">\(b^3\)</span></td>
<td><span class="math inline">\(b^2\)</span></td>
<td><span class="math inline">\(b\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(h_{i}\)</span></td>
<td></td>
<td></td>
<td><span class="math inline">\(b^5\)</span></td>
<td><span class="math inline">\(b^4\)</span></td>
<td><span class="math inline">\(b^3\)</span></td>
<td><span class="math inline">\(b^2\)</span></td>
<td><span class="math inline">\(b\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>则有递推公式</p>
<p><span class="math display">\[
\begin{aligned}
h_i &amp;= \sum_{p = 0}^{L - 1}{s_{i + p} b^{L - 1 - p}}\\
&amp;= b \cdot \sum_{p = 0}^{L - 1}{s_{i + p - 1} b^{L - 1 - p}} - s_{i-1} b^{L} + s_{i+L-1}\\
&amp;= (h_{i-1} - s_{i-1} b^{L-1}) b + s_{i+L-1}
\end{aligned}
\]</span></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rk_hash</span><span class="params">(<span class="type">const</span> std::string s, <span class="type">int</span> start, <span class="type">int</span> base, <span class="type">int</span> L, <span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = (hash * base) % mod;</span><br><span class="line">        hash = (hash + s[start + i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">powmod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">powmod</span>((<span class="type">long</span> <span class="type">long</span>)a * a % m, n / <span class="number">2</span>, m) % m;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">powmod</span>((<span class="type">long</span> <span class="type">long</span>)a * a % m, n / <span class="number">2</span>, m) % m) * ((<span class="type">long</span> <span class="type">long</span>)a % m)) % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rk_cont_hash</span><span class="params">(<span class="type">const</span> std::string s, <span class="type">int</span> start, <span class="type">int</span> last_h, <span class="type">int</span> base, <span class="type">int</span> L, <span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hash = last_h - s[start - <span class="number">1</span>] * <span class="built_in">powmod</span>(base, L - <span class="number">1</span>, mod);</span><br><span class="line">    hash = (hash * base) % mod;</span><br><span class="line">    hash = (hash + s[start + L - <span class="number">1</span>]) % mod;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM YouCompleteMe自动补全插件配置</title>
    <url>/2021/10/17/2021-10-17-vim-youcompleteme-plugin/</url>
    <content><![CDATA[<h1 id="youcompleteme插件">YouCompleteMe插件</h1>
<h1 id="配置步骤">配置步骤</h1>
<h2 id="编译支持-c17-的-gcc">编译支持 C++17 的 GCC</h2>
<p>gcc源代码以ftp的形式发布，除了gnu官方的服务器外，在世界各地都有镜像站，国内靠谱的镜像站有<a href="https://mirrors.aliyun.com/gnu/gcc/">阿里云</a>等。</p>
<p>下载源码并解压:</p>
<p>这里使用9.4.0版</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/gnu/gcc/gcc-9.4.0/gcc-9.4.0.tar.gz</span><br><span class="line">tar -zxf gcc-9.4.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>创建编译用的目录，我一般习惯命名为build：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure>
<p>编译配置：</p>
<p>此处可配置的选项极多，具体含义可以在<a href="https://gcc.gnu.org/install/configure.html">gcc网站</a>上查询. 如果不知道应该加什么参数，可以参考系统上已有的gcc的配置参数：<code>gcc -v</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../configure -v \</span><br><span class="line">    --prefix=/usr/local</span><br><span class="line">    --enable-languages=c,c++ \</span><br><span class="line">    --with-gcc-major-version-only \</span><br><span class="line">    --enable-shared \</span><br><span class="line">    --enable-linker-build-id \</span><br><span class="line">    --without-included-gettext \</span><br><span class="line">    --enable-threads=posix \</span><br><span class="line">    --enable-nls \</span><br><span class="line">    --enable-bootstrap \</span><br><span class="line">    --enable-clocale=gnu \</span><br><span class="line">    --enable-libstdcxx-debug \</span><br><span class="line">    --enable-libstdcxx-time=<span class="built_in">yes</span> \</span><br><span class="line">    --with-default-libstdcxx-abi=new \</span><br><span class="line">    --enable-gnu-unique-object \</span><br><span class="line">    --disable-vtable-verify \</span><br><span class="line">    --enable-libmpx \</span><br><span class="line">    --enable-plugin \</span><br><span class="line">    --enable-default-pie \</span><br><span class="line">    --with-system-zlib \</span><br><span class="line">    --with-target-system-zlib \</span><br><span class="line">    --enable-multiarch \</span><br><span class="line">    --disable-werror \</span><br><span class="line">    --with-arch-32=i686 \</span><br><span class="line">    --with-abi=m64 \</span><br><span class="line">    --with-multilib-list=m32,m64,mx32 \</span><br><span class="line">    --enable-multilib \</span><br><span class="line">    --with-tune=generic \</span><br><span class="line">    --enable-offload-targets=nvptx-none \</span><br><span class="line">    --without-cuda-driver \</span><br><span class="line">    --enable-checking=release \</span><br><span class="line">    --build=x86_64-linux-gnu \</span><br><span class="line">    --host=x86_64-linux-gnu \</span><br><span class="line">    --target=x86_64-linux-gnu</span><br></pre></td></tr></table></figure>
<p>此处解释几个关键配置</p>
<ul>
<li><p>--build</p>
<p>当前正在使用的机器的环境</p></li>
<li><p>--host</p>
<p>编译产物(gcc)将会运行在的环境</p></li>
<li><p>--target</p>
<p>编译出来的gcc的编译产物的目标环境</p></li>
</ul>
<p>以上三个参数用于交叉编译，比如在x86_64机器上(build)编译一个即将在arm上运行(host)的编译器，该编译器产生在arm上(target)运行的程序。三个参数的格式均为<code>cpu-company-system</code></p>
<ul>
<li><p>--prefix=/usr/local</p>
<p>编译产物的安装目录。系统默认的gcc一般会安装在/usr下，为了不影响系统的gcc，建议设置为不同的路径</p></li>
<li><p>--enable-languages</p>
<p>配置gcc支持的语言类型，可选项有ada, c, c++, go等, 由于笔者只需要c和c++，因此只开启了c和c++.</p></li>
<li><p>--enable-multilib</p>
<p>是否编译target上的multilib, multilib是在target上编译和运行架构不同程序所需的库，比如在x86_64上编译运行32位程序。</p></li>
<li><p>--with-multilib-list</p>
<p>开启的multilib列表，对于不同target，此处允许的值有所不同。在<code>x86_64-*-linux*</code>上有m32, m64, mx32三个可选项。</p></li>
</ul>
<p>开始编译并安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>环境变量配置：</p>
<p>下面的<code>$INSTALLDIR</code>要换成对应的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$INSTALLDIR</span>/bin:\$PATH&quot;</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">export</span> CPPFLAGS=<span class="string">&quot;-I<span class="variable">$INSTALLDIR</span>/include \$CPPFLAGS&quot;</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">export</span> LDFLAGS=<span class="string">&quot;-L<span class="variable">$INSTALLDIR</span>/lib64 -L<span class="variable">$INSTALLDIR</span>/lib \$LDFLAGS&quot;</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">&quot;<span class="variable">$INSTALLDIR</span>/lib64:<span class="variable">$INSTALLDIR</span>/lib:\$LD_LIBRARY_PATH&quot;</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="安装-python-3">安装 Python 3</h2>
<p>YouCompleteMe需要最低Python3.6的环境，如果不满足，则需要安装</p>
<p>如果软件源中包含了满足要求的python版本，则可以直接安装；否则需要从源码编译。</p>
<ol type="a">
<li>直接从软件源安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3.8 python3.8-dev</span><br></pre></td></tr></table></figure>
<ol start="2" type="a">
<li>从源码编译Python3</li>
</ol>
<p>暂时没有用到，略过</p>
<h2 id="编译-vim">编译 VIM</h2>
<p>VIM的编译过程相对简单了很多</p>
<p>克隆代码，可以直接克隆最新版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/vim/vim.git    </span><br></pre></td></tr></table></figure>
<p>编译配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> vim/src</span><br><span class="line">./configure \</span><br><span class="line">    --with-features=huge \</span><br><span class="line">    --enable-multibyte \</span><br><span class="line">    --enable-pythoninterp=dynamic \</span><br><span class="line">    --with-python-config-dir=$(python2.7-config --configdir) \</span><br><span class="line">    --enable-python3interp=dynamic \</span><br><span class="line">    --with-python3-config-dir=$(python3.8-config --configdir) \</span><br><span class="line">    --enable-cscope \</span><br><span class="line">    --enable-gui=auto \</span><br><span class="line">    --enable-gtk2-check \</span><br><span class="line">    --enable-fontset \</span><br><span class="line">    --enable-largefile \</span><br><span class="line">    --disable-netbeans \</span><br><span class="line">    --with-compiledby=<span class="string">&quot;xxxxx@xx.com&quot;</span> \</span><br><span class="line">    --enable-fail-if-missing</span><br></pre></td></tr></table></figure>
<p>编译安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="安装-cmake">安装 CMAKE</h2>
<p>下载cmake并安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Kitware/CMake/releases/download/v3.21.3/cmake-3.21.3-linux-x86_64.sh</span><br><span class="line"><span class="built_in">chmod</span> +x cmake-3.21.3-linux-x86_64.sh</span><br><span class="line">./cmake-3.21.3-linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p>配置环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo export PATH=$(pwd)/cmake-3.21.3-linux-x86_64/bin:\$PATH &gt;&gt; $HOME/.bashrc  </span><br></pre></td></tr></table></figure>
<h2 id="安装-youcompleteme-插件">安装 YouCompleteMe 插件</h2>
<p>——待更新</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ARP协议</title>
    <url>/2021/10/20/2021-10-20-arp/</url>
    <content><![CDATA[<h1 id="arp协议">ARP协议</h1>
<p>ARP 协议的全称是 Address Resolution Protocol(地址解析协议)，它是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。是IPv4能够正常工作的基础。</p>
<p>ARP 协议与IP协议一样，位于网络层，ARP报文在以太网帧结构中的帧类型字段为<code>0x0806</code></p>
<p>在IPv6中邻居发现协议（NDP）用于代替地址解析协议（ARP）。</p>
<h2 id="arp报文格式">ARP报文格式</h2>
<p>以太网首部：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ether_hdr</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> target_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint8_t</span> sender_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint16_t</span> ptype; <span class="comment">/* equal to 0x0806 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARP 报文：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">arp_hdr</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> htype;</span><br><span class="line">    <span class="type">uint16_t</span> ptype;</span><br><span class="line">    <span class="type">uint8_t</span> hlen;</span><br><span class="line">    <span class="type">uint8_t</span> plen;</span><br><span class="line">    <span class="type">uint16_t</span> opcode;</span><br><span class="line">    <span class="type">uint8_t</span> sender_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint8_t</span> sender_ip[<span class="number">4</span>];</span><br><span class="line">    <span class="type">uint8_t</span> target_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">uint8_t</span> target_ip[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="arp表">ARP表</h2>
<p>在每台安装有TCP/IP协议的电脑或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的，表中的每一行表示在<strong>当前局域网</strong>中，拥有<code>IP地址</code>的设备的MAC地址是<code>MAC地址</code>，如下表所示。</p>
<table>
<thead>
<tr class="header">
<th>主机名称</th>
<th>IP地址</th>
<th>MAC地址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>192.168.38.10</td>
<td>00-AA-00-62-D2-02</td>
</tr>
<tr class="even">
<td>B</td>
<td>192.168.38.11</td>
<td>00-BB-00-62-C2-02</td>
</tr>
<tr class="odd">
<td>C</td>
<td>192.168.38.12</td>
<td>00-CC-00-62-C2-02</td>
</tr>
<tr class="even">
<td>D</td>
<td>192.168.38.13</td>
<td>00-DD-00-62-C2-02</td>
</tr>
<tr class="odd">
<td>E</td>
<td>192.168.38.14</td>
<td>00-EE-00-62-C2-02</td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可减少缓存表的长度，加快查询速度。</p>
<h2 id="arp流程">ARP流程</h2>
<ol type="1">
<li><p>当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可。</p></li>
<li><p>如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”</p></li>
<li><p>网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以单播方式。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP高速缓存（ARP cache），下次再向主机B发送信息时，直接从ARP缓存表里查找就可。</p></li>
</ol>
<h2 id="免费arp">免费ARP</h2>
<p>免费ARP（gratuitous ARP）是指主机发送ARP查询（广播）自己的IP地址，当ARP功能被开启或者是端口初始配置完成，主机向网络发送免费ARP来查询自己的IP地址确认地址唯一可用。</p>
<p>作用：</p>
<ol type="1">
<li><p>确定网络中是否有其他主机使用了IP地址，如果有应答则产生错误消息。</p></li>
<li><p>免费ARP可以做更新ARP缓存用，网络中的其他主机收到该广播则在缓存中更新条目，收到该广播的主机无论是否存在与IP地址相关的条目都会强制更新，如果存在旧条目则会将MAC更新为广播包中的MAC。</p></li>
</ol>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>2021目标计划</title>
    <url>/2021/01/05/2021-start/</url>
    <content><![CDATA[<h1 id="年目标">2021年目标</h1>
<h2 id="学习上">学习上</h2>
<ul>
<li>先把期末考试完美解决</li>
</ul>
<h2 id="技术上">技术上</h2>
<ul>
<li><p>想深入学习一下C++!</p></li>
<li><p>多刷算法题目!</p></li>
<li><p>多写Blog!</p></li>
<li><p>学习Android开发</p></li>
<li><p>实现大的后端架构</p></li>
<li><p>学习新语言: Go/Julia/Ruby/...</p></li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Poems in DDLC</title>
    <url>/2022/01/07/2022-01-07-poems-in-ddlc/</url>
    <content><![CDATA[<style>
@font-face
{
    font-family: DejaVuSans;
    src: url(https://frezcirno.github.io/static/images/DejaVuSans.ttf);
}

@font-face
{
    font-family: Ammys Handwriting;
    src: url("https://frezcirno.github.io/static/images/Ammys Handwriting.ttf");
}

@font-face
{
    font-family: Hashtag;
    src: url(https://frezcirno.github.io/static/images/Hashtag.ttf);
}

@font-face
{
    font-family: JPHSL;
    src: url(https://frezcirno.github.io/static/images/JPHSL.TTF);
}

@font-face
{
    font-family: Journal;
    src: url(https://frezcirno.github.io/static/images/Journal-Regular.ttf);
}

h1[id="Sayori"]~blockquote {
    font-family: Hashtag;
    font-size: 35px;
    line-height: 1.2;
}

h1[id="Natsuki"]~blockquote {
    font-family: Ammys Handwriting;
    font-size: 22px;
    line-height: 1.2;
}

h1[id="Yuri"]~blockquote {
    font-family: JPHSL;
    font-size: 35px;
    line-height: 1.2;
}

h1[id="Monika"]~blockquote {
    font-family: Journal;
    font-size: 35px;
    line-height: 1.2;
}

</style>
<p><img src="https://frezcirno.github.io/static/images/ddlc.png" /></p>
<h1 id="sayori">Sayori</h1>
<h2 id="dear-sunshine">Dear Sunshine</h2>
<blockquote>
<p>Dear Sunshine   The way you glow through my blinds in the morning It makes me feel like you missed me. Kissing my forehead to help me out of bed. Making me rub the sleepy from my eyes.   Are you asking me to come out and play? Are you trusting me to wish away a rainy day? I look above. The sky is blue. It's a secret, but I trust you too.   If it wasn't for you, I could sleep forever. But I'm not mad.   I want breakfast.</p>
</blockquote>
<h2 id="bottles">Bottles</h2>
<blockquote>
<p>Bottles   I pop off my scalp like the lid of a cookie jar. It's the secret place where I keep all my dreams. Little balls of sunshine, all rubbing together like a bundle of kittens.   I reach inside with my thumb and forefinger and pluck one out. It's warm and tingly. But there's no time to waste! I put it in a bottle to keep it safe. And I put the bottle on the shelf with all of the other bottles. Happy thoughts, happy thoughts, happy thoughts in bottles, all in a row.   My collection makes me lots of friends. Each bottle a starlight to make amends. Sometimes my friend feels a certain way. Down comes a bottle to save the day.   Night after night, more dreams. Friend after friend, more bottles. Deeper and deeper my fingers go. Like exploring a dark cave, discovering the secrets hiding in the nooks and crannies. Digging and digging. Scraping and scraping.   I blow dust off my bottle caps. It doesn't feel like time elapsed. My empty shelf could use some more. My friends look through my locked front door.   Finally, all done. I open up, and in come my friends. In they come, in such a hurry. Do they want my bottles that much? I frantically pull them from the shelf, one after the other. Holding them out to each and every friend. Each and every bottle. But every time I let one go, it shatters against the tile between my feet. Happy thoughts, happy thoughts, happy thoughts in shards, all over the floor.   They were supposed to be for my friends, my friends who aren't smiling. They're all shouting, pleading. Something. But all I hear is echo, echo, echo, echo, echo Inside my head.</p>
</blockquote>
<h2 id="section">%</h2>
<blockquote>
<p>%   Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of my head. Get out of Get. Out. Of. My. Head.     Get out of my head before I do what I know is best for you. Get out of my head before I listen to everything she said to me. Get out of my head before I show you how much I love you. Get out of my head before I finish writing this poem.       But a poem is never actually finished. It just stops moving.</p>
</blockquote>
<h2 id="take-my-hand">Take My Hand</h2>
<blockquote>
<p>Take My Hand   Take my hand, take me forward. Take me to your dream land Caution me to watch my step, So I can't look back at my footprints. Climb the stairs ahead of me While I look up to you. The more I look forward, the more I look up, The more I can lend to you.   If you can trust me to follow your pace, I'll trust you to set it. If you can trust me to lend you a smile, I'll trust you to return it.   Take my hand, take me forward. Take me to your dream land.</p>
</blockquote>
<h2 id="become-the-flower">Become the Flower</h2>
<blockquote>
<p>Become the Flower   A feeling of joy is a flower plucked from the ground. The color, the scent. It's so pretty in my hair. Every day, I pluck some flowers, as though they grew just for me. A lifetime of peace and nourishment, yanked away in an instant. All for me. All for joy.   I need more.   I need more joy. I need more happy.   Pluck, pluck, pluck. Every day. Pluck, pluck, pluck. So pretty in my hair. Pluck, pluck, pluck. You're going to die, and you, too.   Beneath my feet, a flower stands alone. It beckons to me. I twist the stem, freeing it from its clinging roots, Caressing the final joyous moment between my fingers. But to what ends? I look in every direction. And the field I stand in, The prosperous field, Is a barren wasteland. The fruits of my labor. The carnage of my joy.   And that is why   I've decided   I must   Become the flower.</p>
</blockquote>
<h2 id="sayoris-special-events-poem">Sayori's Special Events Poem</h2>
<blockquote>
<p>Sayori's Special Events Poem   There once was a ladybug. It was so small, it took a really long time to crawl from here to there. It was very tiring to fly for too long.   Nobody squishes ladybugs because they're cute. Does that make them better than other bugs? Do ladybugs know they're cute? I think they're too preoccupied with bug things.   And so, the ladybug crawled around and did bug things. This story wasn't really going anywhere. But I know you don't mind. I hope you think it's nice for being there anyway. Like ladybugs. Like this ladybug. The one who clings like a doof onto your sleeve because it knows you won't squash it.   If it doesn't bug you, Will you stay awhile?</p>
</blockquote>
<h1 id="natsuki">Natsuki</h1>
<h2 id="eagles-can-fly">Eagles Can Fly</h2>
<blockquote>
<p>Eagles Can Fly   Monkeys can climb Crickets can leap Horses can race Owls can seek Cheetahs can run Eagles can fly People can try But that's about it.</p>
</blockquote>
<h2 id="amy-likes-spiders">Amy Likes Spiders</h2>
<blockquote>
<p>Amy Likes Spiders   You know what I heard about Amy? Amy likes spiders. Icky, wriggly, hairy, ugly spiders! That's why I'm not friends with her.   Amy has a cute singing voice. I heard her singing my favorite love song. Every time she sang the chorus, my heart would pound to the rhythm of the words. But she likes spiders. That's why I'm not friends with her.   One time, I hurt my leg really bad. Amy helped me up and took me to the nurse. I tried not to let her touch me. She likes spiders, so her hands are probably gross. That's why I'm not friends with her.   Amy has a lot of friends. I always see her talking to people. She probably talks about spiders. What if her friends start to like spiders too? That's why I'm not friends with her.   It doesn't matter if she has other hobbies. It doesn't matter if she keeps it private. It doesn't matter if it doesn't hurt anyone.   It's gross. She's gross. The world is better off without spider lovers.   And I'm gonna tell everyone.</p>
</blockquote>
<h2 id="because-you">Because You</h2>
<blockquote>
<p>Because You   Tomorrow will be brighter with me around But when today is dim, I can only look down. My looking is a little more forward Because you look at me.   When I want to say something, I say it with a shout! But my truest feelings can never come out. My words are a little less empty Because you listen to me.   When something is above me, I reach for the stars. But when I feel small, I don't get very far. My standing is a little bit taller Because you sit with me.   I believe in myself with all of my heart. But what do I do when it's torn all apart? My faith is a little bit stronger Because you trusted me.   My pen always puts my feelings to the test. I'm not a good writer, but my best is my best. My poems are a little bit dearer Because you think of me.   Because you, because you, because you.</p>
</blockquote>
<h2 id="ill-be-your-beach">I'll Be Your Beach</h2>
<blockquote>
<p>I'll Be Your Beach   Your mind is so full of troubles and fears That diminished your wonder over the years But today I have a special place A beach for us to go.   A shore reaching beyond your sight A sea that sparkles with brilliant light The walls in your mind will melt away Before the sunny glow.   I'll be the beach that washes your worries away I'll be the beach that you daydream about each day I'll be the beach that makes your heart leap In a way you thought had left you long ago.   Let's bury your heavy thoughts in a pile of sand Bathe in sunbeams and hold my hand Wash your insecurities in the salty sea And let me see you shine.   Let's leave your memories in a footprint trail Set you free in my windy sail And remember the reasons you're wonderful When you press your lips to mine.   I'll be the beach that washes your worries away I'll be the beach that you daydream about each day I'll be the beach that makes your heart leap In a way you thought had left you long ago.   But if you let me by your side Your own beach, your own escape You'll learn to love yourself again.</p>
</blockquote>
<h2 id="the-best-place-in-the-world">The Best Place in the World</h2>
<blockquote>
<p>The Best Place in the World   I love my bedroom. It's full of bright colors and soft things. The sunlight shines in and makes everything sparkle. It's the best place in the world.   It has all my treasures. All my books, my collections, my memories. All of my dreams were born in this room. It's the best place in the world.   It has all my secrets. All my failures, my fears, my feelings. Sometimes it feels so fragile that the door will break at the slightest touch. But it's still the best place in the world.   But when someone knocks, I get scared. I brace my arms against the loose hinges. Please don't break. Don't come in. I'm not ready. It's MY best place in the world.   The knocking won't stop. I block the door with furniture. An eye peeks through the keyhole, and I panic. I'm trapped in the best place in the world.   I'm not ready to share my favorite place. I need to clean my secrets and make my bed to hide my nightmares. I need to touch them to put them away. To see them again. I have so much to do and I'm scared. I'm not ready. But It's still my favorite place. I still want to share it. However long it takes, if you wait patiently, I'll eventually open the door. And I'll show you the best place in the world.</p>
</blockquote>
<h2 id="natsukis-special-events-poem">Natsuki's Special Events Poem</h2>
<blockquote>
<p>Natsuki's Special Events Poem   I named my pen The Expression Express My feelings aboard With a ticket to you No room for stammers No lies No extra stops No compromise Stations screaming by Attendants saying hi One ticket to you Please and thank you Take a headphone And doze No bumps in the rails Just thumps in my heart And loops in my letters And clouds in the sky And dreams in your eyes Hey, wake up The train has arrived Expression Express, destination you   Chuu Chuu</p>
</blockquote>
<h1 id="yuri">Yuri</h1>
<h2 id="ghost-under-the-light">Ghost under the light</h2>
<blockquote>
<p>Ghost under the light   The tendrils of my hair illuminate beneath the amber glow. Bathing. It must be this one. The last remaining streetlight to have withstood the test of time. The last yet to be replaced by the sickening blue-green of the future. I bathe. Calm; breathing air of the present but living in the past. The light flickers. I flicker back.</p>
</blockquote>
<h2 id="the-raccoon">The Raccoon</h2>
<blockquote>
<p>The Raccoon   It happened in the dead of night while I was slicing bread for a guilty snack. My attention was caught by the scuttering of a raccoon outside my window. That was, I believe, the first time I noticed my strange tendencies as an unordinary human. I gave the raccoon a piece of bread, my subconscious well aware of the consequences. Well aware that a raccoon that is fed will always come back for more. The enticing beauty of my cutting knife was the symptom. The bread, my hungry curiosity. The raccoon, an urge.   The moon increments its phase and reflects that much more light off of my cutting knife. The very same light that glistens in the eyes of my raccoon friend. I slice the bread, fresh and soft. The raccoon becomes excited. or perhaps I'm merely projecting my emotions onto the newly-satisfied animal.   The raccoon has taken to following me. You could say that we've gotten quite used to each other. The raccoon becomes hungry more and more frequently, so my bread is always handy. Every time I brandish my cutting knife the raccoon shows me its excitement. A rush of blood. Classic Pavlovian conditioning. I slice the bread.   And I feed myself again.</p>
</blockquote>
<h2 id="ghost-under-the-light-pt.-2">Ghost under the Light pt. 2</h2>
<blockquote>
<p>Ghost under the Light pt. 2   The tendrils of my hair illuminate beneath the amber glow. Bathing. In the distance, a blue-green light flickers. A lone figure crosses its path– a silhouette obstructing the eerie glow. My heart pounds. The silhouette grows. Closer Closer I open my umbrella, casting a shadow to shield me from visibility. But I am too late. He steps into the streetlight. I gasp and drop my umbrella. The light flickers. My heart pounds. He raises his arm.   Time stops.   The only indication of movement is the amber light flickering against his outstretched arm. The flickering light is in rhythm with the pounding of my heart. Teasing me for succumbing to this forbidden emotion. Have you ever heard of a ghost feeling warmth before? Giving up on understanding, I laugh. Understanding is overrated. I touch his hand. The flickering stops. Ghosts are blue-green. My heart is amber.</p>
</blockquote>
<h2 id="beach">Beach</h2>
<blockquote>
<p>Beach   A marvel millions of years in the making. Where the womb of Earth chaotically meets the surface. Under a clear blue sky, an expanse of bliss - But beneath gray rolling clouds, an endless enigma. The easiest world to get lost in is one where everything can be found.   One can only build a sand castle where the sand is wet. But where the sand is wet, the tide comes. Will it gently lick at your foundations until you give in? Or will a sudden wave send you crashing down in the blink of an eye? Either way the outcome is the same. Yet we still build sand castles.   I stand where the foam wraps around my ankles. Where my toes squish into the sand. The salty air is therapeutic. The breeze is gentle, yet powerful. I sink my toes into the ultimate boundary line, tempted by the foamy tendrils. Turn back, and I abandon my peace to erode at the shore. Drift forward, and I return to Earth forevermore.</p>
</blockquote>
<h2 id="wheel">Wheel</h2>
<blockquote>
<p>Wheel   A rotating wheel. Turning an axle. Grinding. Bolthead. Linear gearbox. Falling sky. Seven holy stakes. A docked ship. A portal to another world. A thin rope tied to a thick rope. A torn harness. Parabolic gearbox. Expanding universe. Time controlled by slipping cogwheels. Existence of God. Swimming with open water in all directions. Drowning. A prayer written in blood. A prayer written in time-devouring snakes with human eyes. A thread connecting all living human eyes. A kaleidoscope of holy stakes. Exponential gearbox. A sky of exploding stars. God disproving the existence of God. A wheel rotating in six dimensions. Forty gears and a ticking clock. A clock that ticks one second for every rotation of the planet. A clock that ticks forty times every time it ticks every second time. A bolthead of holy stakes tied to the existence of a docked ship to another world. A kaleidoscope of blood written in clocks. A time-devouring prayer connecting a sky of forty gears and open human eyes in all directions. Breathing gearbox. Breathing bolthead. Breathing ship. Breathing portal. Breathing snakes. Breathing God. Breathing blood. Breathing holy stakes. Breathing human eyes. Breathing time. Breathing prayer. Breathing sky. Breathing wheel.</p>
</blockquote>
<h2 id="yuris-special-events-poem">Yuri's Special Events Poem</h2>
<blockquote>
<p>Yuri's Special Events Poem   My conductor motions for one crescendo after the next, each time falling short of a climax. The lump in my throat is carried by Sisyphus. How many words must I choose not to say before they finally break loose, orderlessly piling out of my mouth like a flock of schoolchildren at the start of recess? Pen cannot be erased. but even that metaphor fails comically as my floor is littered, blanketed with wasted paper. A canvas of my mind, full of disjointed thoughts and unfinished sentences.   Perhaps, all along, it was wrong to try forcing them out of my room. And I should instead invite you in.</p>
</blockquote>
<h1 id="monika">Monika</h1>
<h2 id="hole-in-wall">Hole in Wall</h2>
<blockquote>
<p>Hole in Wall   It couldn't have been me. See, the direction the spackle protrudes. A noisy neighbor? An angry boyfriend? I'll never know. I wasn't home. I peer inside for a clue. No! I can't see. I reel, blind, like a film left out in the sun. But it's too late. My retinas. Already scorched with a permanent copy of the meaningless image. It's just a little hole. It wasn't too bright. It was too deep. Stretching forever into everything. A hole of infinite choices. I realize now, that I wasn't looking in. I was looking out. And he, on the other side, was looking in.</p>
</blockquote>
<h2 id="save-me">Save Me</h2>
<blockquote>
<p>Save Me   The colors, they won't stop. Bright, beautiful colors Flashing, expanding, piercing Red, green, blue An endless cacophony Of meaningless noise   The noise, it won't stop. Violent, grating waveforms Squeaking, screeching, piercing Sine, cosine, tangent Like playing a chalkboard on a turntable Like playing a vinyl on a pizza crust An endless poem Of meaningless   Load Me</p>
</blockquote>
<h2 id="the-lady-who-knows-everything">The Lady who Knows Everything</h2>
<blockquote>
<p>The Lady who Knows Everything   An old tale tells of a lady who wanders Earth. The Lady who Knows Everything. A beautiful lady who has found every answer, All meaning, All purpose, And all that was ever sought.   And here I am,   a feather   Lost adrift the sky, victim of the currents of the wind.   Day after day, I search. I search with little hope, knowing legends don't exist. But when all else has failed me, When all others have turned away, The legend is all that remains – the last dim star glimmering in the twilit sky.   Until one day, the wind ceases to blow. I fall. And I fall and fall, and fall even more. Gentle as a feather. A dry quill, expressionless.   But a hand catches me, between the thumb and forefinger. The hand of a beautiful lady. I look at her eyes and find no end to her gaze.   The Lady who Knows Everything knows what I am thinking. Before I can speak, she responds in a hollow voice. "I have found every answer, all of which amount to nothing. There is no meaning. There is no purpose. And we seek only the impossible. I am not your legend. Your legend does not exist."   And with a breath, she blows me back afloat, and I pick up a gust of wind.</p>
</blockquote>
<h2 id="hole-in-wall-2">Hole in Wall (2)</h2>
<blockquote>
<p>Hole in Wall (2)   But he wasn't looking at me. Confused, I frantically glance at my surroundings. But my burned eyes can no longer see color. Are there others in this room? Are they talking? Or are they simply poems on flat sheets of paper, The sound of frantic scrawling playing tricks on my ears? The room begins to crinkle. Closing in on me. The air I breathe dissipate before it reaches my lungs. I panic. There must be a way out. It's right there. He's right there.   Swallowing my fears, I brandish my pen.</p>
</blockquote>
<h2 id="save-me-2">Save Me (2)</h2>
<blockquote>
<p>Save Me (2)   The colors, they won't Bright, bea t ful c l rs Flash ng, exp nd ng, piercing Red, green, blue An ndless CACOPHONY Of meaningless noise   The noise, it won't STOP. Viol nt, grating w vef rms Sq e king, screech ng, piercing SINE, COSINE, TANGENT Like play ng a ch lkboard on a t rntable Like playing a KNIFE on a BREATHING RIBCAGE n ndl ss p m Of m n ngl ss   Delete Her</p>
</blockquote>
<h2 id="happy-end">Happy End</h2>
<blockquote>
<p>Happy End   Pen in hand, I find my strength. The courage endowed upon me by my one and only love. Together, let us dismantle this crumbling world And write a novel of our own fantasies.   With a flick of her pen, the lost finds her way. In a world of infinite choices, behold this special day.   After all, Not all good times must come to an end</p>
</blockquote>
<h2 id="monikas-special-events-poem">Monika's Special Events Poem</h2>
<blockquote>
<p>Monika's Special Events Poem   An electrical signal from some remote corner of my brain. Connecting all kinds of circuits and nerves and chemicals in a web understood by nobody. The chemicals make my chest tingle around my beating heart. The nerves make my hand move, staining a dead tree with some dark substance.</p>
</blockquote>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>DDLC</tag>
      </tags>
  </entry>
  <entry>
    <title>2023 年终总结</title>
    <url>/2024/01/01/2023-final/</url>
    <content><![CDATA[<h1 id="回顾">2023 回顾</h1>
<ul>
<li>1月: 开源投毒</li>
<li>1-3月: Rust 教材</li>
<li>4-5月: 加入误报消减团队, 投 ASE/ICSE 论文</li>
<li>3,5-10月: 相似代码片段但是有漏洞情况不同 自己搜索, 研究 PDG, Call Graph, LLVM Pass, 函数切片, 错过 FSE</li>
<li>7-11月: 参加 GLCC 开源活动</li>
<li>8-12月: 搞浦发银行的项目</li>
</ul>
<h1 id="近况">近况</h1>
<p>个人: 研二在读, 人在杭州, 一篇一作论文在投, 每天搬砖, 没有确定的方向, 毕业有点迷茫</p>
<p>实验室: 宁波实验室人丁兴旺, hw稀稀拉拉, 反倒宁波更好一些</p>
<h1 id="体会">体会</h1>
<p>研究生比本科忙多了, 没有时间去做自己想做的事情</p>
<p>甚至不知道2023年都做了些什么(笑), 只能看周报回忆</p>
<h1 id="希望">2024 希望</h1>
<ul>
<li>多读书</li>
<li>多运动</li>
<li>找到好工作</li>
<li>学习唱歌</li>
</ul>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 类型推导</title>
    <url>/2022/02/26/c++_type_deduction/</url>
    <content><![CDATA[<h1 id="模板类型推导">模板类型推导</h1>
<h1 id="auto类型推导">auto类型推导</h1>
<h1 id="模板类型推导-1">模板类型推导</h1>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>How to compile the linux kernel</title>
    <url>/2022/01/08/how-to-compile-linux-kernel/</url>
    <content><![CDATA[<p><img src="https://frezcirno.github.io/static/images/NewTux.svg" /></p>
<h1 id="访问-httpswww.kernel.org-查看最新的内核版本获取下载链接">访问 https://www.kernel.org/ 查看最新的内核版本，获取下载链接</h1>
<h1 id="下载并解压到当前目录">下载并解压到当前目录</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget -qO- https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.15.13.tar.xz | tar Jxvf -</span><br><span class="line"><span class="built_in">cd</span> linux-5.15.13</span><br></pre></td></tr></table></figure>
<h1 id="编译配置">编译配置</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /boot/config-`<span class="built_in">uname</span> -r` .config</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<h1 id="开始编译">开始编译</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>
<h1 id="安装到系统中">安装到系统中</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo make INSTALL_MOD_STRIP=1 modules_install</span><br><span class="line">sudo make headers_install</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>自签名 SSL 证书</title>
    <url>/2023/11/21/ssl_certificate/</url>
    <content><![CDATA[<h2 id="成为-ca">成为 CA！</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generate private key</span></span><br><span class="line">openssl genrsa -des3 -out myCA.key 2048</span><br><span class="line"><span class="comment"># Generate root certificate</span></span><br><span class="line">openssl req -x509 -new -nodes -key myCA.key -sha256 -days 825 -out myCA.pem \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=/OU=/CN=My first CA&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="信任-ca">信任 CA</h2>
<p>Ubuntu:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> myCA.pem /usr/local/share/ca-certificates/myCA.crt</span><br><span class="line">sudo update-ca-certificates</span><br></pre></td></tr></table></figure>
<h2 id="颁发证书">颁发证书！</h2>
<p>可以有多个域名/IP地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use your own domain name</span></span><br><span class="line">NAME=my.domain.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate a private key</span></span><br><span class="line">openssl genrsa -out <span class="variable">$NAME</span>.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a certificate-signing request</span></span><br><span class="line">openssl req -new -key <span class="variable">$NAME</span>.key -out <span class="variable">$NAME</span>.csr \</span><br><span class="line">    -subj <span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=/OU=/CN=<span class="variable">$NAME</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a config file for the extensions</span></span><br><span class="line"><span class="built_in">cat</span> &gt;<span class="variable">$NAME</span>.ext &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">authorityKeyIdentifier=keyid,issuer</span></span><br><span class="line"><span class="string">basicConstraints=CA:FALSE</span></span><br><span class="line"><span class="string">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span></span><br><span class="line"><span class="string">subjectAltName = @alt_names</span></span><br><span class="line"><span class="string">[alt_names]</span></span><br><span class="line"><span class="string">DNS.1 = $NAME # Be sure to include the domain name here because Common Name is not so commonly honoured by itself</span></span><br><span class="line"><span class="string">DNS.2 = bar.$NAME # Optionally, add additional domains (I&#x27;ve added a subdomain here)</span></span><br><span class="line"><span class="string">IP.1 = 1.2.3.4 # Optionally, add an IP address (if the connection which you have planned requires it)</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the signed certificate</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> <span class="variable">$NAME</span>.csr -CA myCA.pem -CAkey myCA.key -CAcreateserial \</span><br><span class="line">    -out <span class="variable">$NAME</span>.crt -days 825 -sha256 -extfile <span class="variable">$NAME</span>.ext</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$NAME</span>.crt <span class="variable">$NAME</span>.key &gt;<span class="variable">$NAME</span>.pem</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title>程序分析</title>
    <url>/2023/10/31/program-analysis/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>program-analysis</category>
      </categories>
  </entry>
  <entry>
    <title>KLEE 符号执行</title>
    <url>/2023/12/19/klee/</url>
    <content><![CDATA[<h2 id="基本使用">基本使用</h2>
<ol type="1">
<li>修改程序源码，在合适的地方插入符号值</li>
</ol>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> int main() &#123;</span><br><span class="line">   int a;</span><br><span class="line"><span class="addition">+  klee_make_symbolic(&amp;a, sizeof(a), &quot;a&quot;);</span></span><br><span class="line">   return get_sign(a);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>编译成 LLVM bitcode</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ clang -I ../../include -emit-llvm -c -g -O0 -Xclang -disable-O0-optnone get_sign.c</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>符号模拟执行 bitcode</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ klee get_sign.bc</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>查看模拟得到的 test cases</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ktest-tool klee-last/test000001.ktest</span><br></pre></td></tr></table></figure>
<h2 id="内部实现">内部实现</h2>
<h3 id="directory-structure">Directory Structure</h3>
<ul>
<li>lib - KLEE 核心源代码
<ul>
<li>Basic - 不依赖 LLVM 的工具代码, 一堆工具类</li>
<li>Support - 依赖 LLVM 的工具代码, 一堆工具类
<ul>
<li>KTest.cpp</li>
<li>Statistics.cpp</li>
</ul></li>
<li>Module - klee facilities for working with LLVM modules, including the shadow module/instruction structures we use during execution.</li>
<li>Expr - 表达式对象</li>
<li>Solver - 求解器 binder</li>
<li>Core - 核心符号虚拟机</li>
</ul></li>
<li>tools - KLEE 的二进制
<ul>
<li>kleaver - 查询什么 log</li>
<li>klee - 符号模拟执行一个 bitcode</li>
<li>klee-replay - 复现 ktest</li>
<li>klee-stats</li>
<li>klee-zesti</li>
<li>ktest-gen</li>
<li>ktest-randgen</li>
<li>ktest-tool</li>
</ul></li>
<li>runtime - 符号模拟执行时依赖的库</li>
</ul>
<h3 id="utilities-klee-辅助类">Utilities KLEE 辅助类</h3>
<h4 id="引用计数-referencecounter-reft">引用计数 <code>ReferenceCounter</code> <code>ref&lt;T&gt;</code></h4>
<p>这两个类用于实现引用计数</p>
<p><code>ReferenceCounter</code> 放在被计数的对象中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">  ReferenceCounter _refCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ref&lt;T&gt;</code> 是对象的引用, 重载了*和-&gt;运算符, 可以像指针一样使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ref&lt;Human&gt; <span class="title">r</span><span class="params">(<span class="keyword">new</span> Human())</span></span>;</span><br><span class="line">r-&gt;<span class="built_in">hello</span>();</span><br></pre></td></tr></table></figure>
<h3 id="toolsklee-klee-工具源码">tools/klee KLEE 工具源码</h3>
<h4 id="main-主函数">main 主函数</h4>
<ul>
<li><p><code>klee::loadFile</code> 加载输入文件，可以是单个bitcode(.bc)或者archive(.a), 得到一组<code>llvm::Module</code></p></li>
<li><p><code>klee::linkModules</code> 把所有 <code>Module</code> 链接成一整个</p></li>
<li><p>检查 triple</p></li>
<li><p>配置 Libcxx, Libc</p></li>
<li><p>配置程序运行环境: argc, argv, envp</p></li>
<li><p>创建 <code>Handler</code>, <code>Executor</code> <em>impl</em> <code>Interpreter</code></p></li>
<li><p><code>externalsAndGlobalsCheck</code> 做检查</p></li>
<li><p>Replay or 模拟执行</p></li>
<li><p><code>interpreter</code>-&gt;<code>runFunctionAsMain</code> 开始模拟执行</p></li>
</ul>
<h4 id="executorrun-开始"><code>Executor::run</code> 开始</h4>
<ul>
<li><p><code>usingSeeds</code> 判断</p></li>
<li><p>主循环</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main interpreter loop</span></span><br><span class="line"><span class="keyword">while</span> (!states.<span class="built_in">empty</span>() &amp;&amp; !haltExecution) &#123;</span><br><span class="line">  ExecutionState &amp;state = searcher-&gt;<span class="built_in">selectState</span>();  <span class="comment">// 选择一个 State</span></span><br><span class="line">  KInstruction *ki = state.pc;  <span class="comment">// 取指令</span></span><br><span class="line">  <span class="built_in">stepInstruction</span>(state);  <span class="comment">// 更新 PC</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">executeInstruction</span>(state, ki);  <span class="comment">// 执行指令</span></span><br><span class="line">  timers.<span class="built_in">invoke</span>();</span><br><span class="line">  <span class="keyword">if</span> (::dumpStates) <span class="built_in">dumpStates</span>();</span><br><span class="line">  <span class="keyword">if</span> (::dumpPTree) <span class="built_in">dumpPTree</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">updateStates</span>(&amp;state);  <span class="comment">// 更新 State</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">checkMemoryUsage</span>()) &#123;</span><br><span class="line">    <span class="comment">// update searchers when states were terminated early due to memory pressure</span></span><br><span class="line">    <span class="built_in">updateStates</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很清晰的代码, 每次循环选择一个程序 <code>ExecutionState</code>, 执行下条 <code>KInstruction</code>, 更新状态, 然后重复.</p>
<p>其中 <code>Searcher</code> 实现了探索的策略, <code>klee</code> 中有多种实现, 如 <code>BFS</code>/<code>DFS</code>/<code>Random</code> 等</p>
<h4 id="程序状态-executionstate-stackframe">程序状态 <code>ExecutionState</code>, <code>StackFrame</code></h4>
<p>执行状态, 包括栈帧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutionState</span> &#123;</span><br><span class="line">  <span class="comment">/// @brief Pointer to instruction to be executed after the current</span></span><br><span class="line">  <span class="comment">/// instruction</span></span><br><span class="line">  KInstIterator pc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief Stack representing the current instruction stream</span></span><br><span class="line">  std::vector&lt;StackFrame&gt; stack;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>栈帧里面包含 <code>locals</code>, 是一堆预分配的 <code>Cell</code>, 数量等于函数参数+指令总数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StackFrame</span> &#123;</span><br><span class="line">  KInstIterator caller;</span><br><span class="line">  KFunction *kf;</span><br><span class="line">  CallPathNode *callPathNode;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">const</span> MemoryObject *&gt; allocas;</span><br><span class="line">  Cell *locals;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Cell</code> 即对 <code>Expr</code> 的引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> klee &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    ref&lt;Expr&gt; value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="executorexecuteinstruction-开始"><code>Executor::executeInstruction</code> 开始</h4>
<p>根据指令 opcode 对应处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> Instruction::Ret:</span><br><span class="line">      <span class="comment">// 求解return返回的值</span></span><br><span class="line">      result = <span class="built_in">eval</span>(ki, <span class="number">0</span>, state).value;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 考虑是否需要进行 coercion</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// bindLocal caller指令 的 dest cell 的 value</span></span><br><span class="line">      <span class="built_in">bindLocal</span>(kcaller, state, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Instruction::Br:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Instruction::IndirectBr:</span><br><span class="line"><span class="keyword">case</span> Instruction::Switch:</span><br><span class="line"><span class="keyword">case</span> Instruction::Unreachable:</span><br><span class="line"><span class="keyword">case</span> Instruction::Invoke:</span><br><span class="line"><span class="keyword">case</span> Instruction::Call:</span><br><span class="line"><span class="keyword">case</span> Instruction::PHI:</span><br><span class="line"><span class="keyword">case</span> Instruction::Select:</span><br><span class="line"><span class="keyword">case</span> Instruction::VAArg:</span><br><span class="line"><span class="keyword">case</span> Instruction::Add:</span><br><span class="line"><span class="keyword">case</span> Instruction::Sub:</span><br><span class="line"><span class="keyword">case</span> Instruction::Mul:</span><br><span class="line"><span class="keyword">case</span> Instruction::UDiv:</span><br><span class="line"><span class="keyword">case</span> Instruction::SDiv:</span><br><span class="line"><span class="keyword">case</span> Instruction::URem:</span><br><span class="line"><span class="keyword">case</span> Instruction::SRem:</span><br><span class="line"><span class="keyword">case</span> Instruction::And:</span><br><span class="line"><span class="keyword">case</span> Instruction::Or:</span><br><span class="line"><span class="keyword">case</span> Instruction::Xor:</span><br><span class="line"><span class="keyword">case</span> Instruction::Shl:</span><br><span class="line"><span class="keyword">case</span> Instruction::LShr:</span><br><span class="line"><span class="keyword">case</span> Instruction::AShr:</span><br><span class="line"><span class="keyword">case</span> Instruction::ICmp:</span><br><span class="line"><span class="keyword">case</span> Instruction::Alloca:</span><br><span class="line"><span class="keyword">case</span> Instruction::Load:</span><br><span class="line"><span class="keyword">case</span> Instruction::Store:</span><br><span class="line"><span class="keyword">case</span> Instruction::GetElementPtr:</span><br><span class="line"><span class="keyword">case</span> Instruction::Trunc:</span><br><span class="line"><span class="keyword">case</span> Instruction::ZExt:</span><br><span class="line"><span class="keyword">case</span> Instruction::SExt:</span><br><span class="line"><span class="keyword">case</span> Instruction::IntToPtr:</span><br><span class="line"><span class="keyword">case</span> Instruction::PtrToInt:</span><br><span class="line"><span class="keyword">case</span> Instruction::BitCast:</span><br><span class="line"><span class="keyword">case</span> Instruction::FNeg:</span><br><span class="line"><span class="keyword">case</span> Instruction::FAdd:</span><br><span class="line"><span class="keyword">case</span> Instruction::FSub:</span><br><span class="line"><span class="keyword">case</span> Instruction::FMul:</span><br><span class="line"><span class="keyword">case</span> Instruction::FDiv:</span><br><span class="line"><span class="keyword">case</span> Instruction::FRem:</span><br><span class="line"><span class="keyword">case</span> Instruction::FPTrunc:</span><br><span class="line"><span class="keyword">case</span> Instruction::FPExt:</span><br><span class="line"><span class="keyword">case</span> Instruction::FPToUI:</span><br><span class="line"><span class="keyword">case</span> Instruction::FPToSI:</span><br><span class="line"><span class="keyword">case</span> Instruction::UIToFP:</span><br><span class="line"><span class="keyword">case</span> Instruction::SIToFP:</span><br><span class="line"><span class="keyword">case</span> Instruction::FCmp:</span><br><span class="line"><span class="keyword">case</span> Instruction::InsertValue:</span><br><span class="line"><span class="keyword">case</span> Instruction::ExtractValue:</span><br><span class="line"><span class="keyword">case</span> Instruction::Fence:</span><br><span class="line"><span class="keyword">case</span> Instruction::InsertElement:</span><br><span class="line"><span class="keyword">case</span> Instruction::ExtractElement:</span><br><span class="line"><span class="keyword">case</span> Instruction::ShuffleVector:</span><br><span class="line"><span class="keyword">case</span> Instruction::Resume:</span><br><span class="line"><span class="keyword">case</span> Instruction::LandingPad:</span><br><span class="line"><span class="keyword">case</span> Instruction::AtomicRMW:</span><br><span class="line"><span class="keyword">case</span> Instruction::AtomicCmpXchg:</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>software-test</category>
      </categories>
      <tags>
        <tag>Program Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>jpf-symbc 踩坑记录</title>
    <url>/2023/12/20/jpf-symbc/</url>
    <content><![CDATA[<h1 id="jpf">JPF</h1>
<p>Analysis system for Java</p>
<p>Developed by NASA</p>
<p>jpf 可以用来: * software model checking (deadlock &amp; race detection) * deep inspection (numeric analysis, invalid access) * test case generation (symbolic execution)</p>
<h1 id="组件">组件</h1>
<p>Java 字节码解释器(虚拟机)</p>
<p>Listeners: To print results of symbolic analysis (path conditions, test vectors or test sequences); to influence the search</p>
<h1 id="相关资源">相关资源</h1>
<ul>
<li><a href="https://yannicnoller.notion.site/Symbolic-PathFinder-Setup-47fe784d81614f98b4525f260618fa35#fcd2bd4dea0d4daa9dab83520da68fe1">jpf-symbc 作者的 notion 笔记</a></li>
<li><a href="https://mir.cs.illinois.edu/marinov/rio2011/JPF-58.pdf">JavaPathfinder Tutorial 02/2010</a></li>
<li><a href="https://www.slideserve.com/omer/jpf-tutorial">JPF Tutorial – Part 2 Symbolic PathFinder – Symbolic Execution of Java Byte-code</a></li>
<li><a href="https://fm.csl.sri.com/SSFT11/JPF-lecture-2.pdf">Java Pathfinder Lecture 2: Under the Hood</a></li>
<li><a href="https://www.uio.no/studier/emner/matnat/ifi/INF5140/v15/slides/jpf.pdf">Java Path Finder 2015</a></li>
<li></li>
</ul>
<h1 id="安装和配置">安装和配置</h1>
<p>安装配置文档竟在<a href="https://yannicnoller.notion.site/Symbolic-PathFinder-Setup-47fe784d81614f98b4525f260618fa35#fcd2bd4dea0d4daa9dab83520da68fe1">作者的 notion 笔记</a>里面....</p>
<p>下面讲一下笔者的踩坑经验</p>
<ol type="1">
<li>克隆项目</li>
</ol>
<p><code>jpf-core</code> 和 <code>jpf-symbc</code> 放在同一个目录下面</p>
<p><code>jpf-core</code> 要用这个版本 -&gt; https://github.com/yannicnoller/jpf-core</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── jpf-core</span><br><span class="line">└── jpf-symbc</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>编译项目</li>
</ol>
<p><code>jpf-symbc</code> 只支持 Java 8</p>
<p>切换到 Java 8</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ jabba install temulin@8</span><br><span class="line">$ jabba use temulin@8</span><br></pre></td></tr></table></figure>
<p><code>jpf-core</code> 用 <code>ant</code> 编译</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in jpf-core</span></span><br><span class="line">ant build</span><br><span class="line"></span><br><span class="line"><span class="comment"># (Optional) test</span></span><br><span class="line">JUNIT_HOME=/usr/share/maven-repo/junit/junit/4.13.2/ ant <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p><code>jpf-symbc</code> 用 <code>ant</code> 编译</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in jpf-symbc</span></span><br><span class="line">ant build</span><br><span class="line"></span><br><span class="line"><span class="comment"># (Optional) test</span></span><br><span class="line">JUNIT_HOME=/usr/share/maven-repo/junit/junit/4.13.2/ ant <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>配置 <code>~/.jpf/site.properties</code></li>
</ol>
<p>里面填写如下内容</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jpf-core</span> = <span class="string">$&#123;user.home&#125;/src/javapathfinder/jpf-core</span></span><br><span class="line"><span class="attr">jpf-symbc</span> = <span class="string">$&#123;user.home&#125;/src/javapathfinder/jpf-symbc</span></span><br><span class="line"><span class="attr">extensions</span> = <span class="string">$&#123;jpf-core&#125;,$&#123;jpf-symbc&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中对应修改两个项目的路径</p>
<ol start="4" type="1">
<li>测试下能否正常使用</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in jpf-symbc</span></span><br><span class="line">$ java -Xmx1024m -ea -jar ../jpf-core/build/RunJPF.jar src/examples/demo/NumericExample.jpf</span><br><span class="line">symbolic.min_int=-2147483648</span><br><span class="line">symbolic.min_long=-9223372036854775808</span><br><span class="line">symbolic.min_short=-32768</span><br><span class="line">symbolic.min_byte=-128</span><br><span class="line">symbolic.min_char=0</span><br><span class="line">symbolic.max_int=2147483647</span><br><span class="line">symbolic.max_long=9223372036854775807</span><br><span class="line">symbolic.max_short=32767</span><br><span class="line">symbolic.max_byte=127</span><br><span class="line">symbolic.max_char=65535</span><br><span class="line">symbolic.min_double=4.9E-324</span><br><span class="line">symbolic.max_double=1.7976931348623157E308</span><br><span class="line">JavaPathfinder core system v8.0 - (C) 2005-2014 United States Government. All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====================================================== system under <span class="built_in">test</span></span><br><span class="line">demo.NumericExample.main()</span><br><span class="line"></span><br><span class="line">====================================================== search started: 23-12-29 下午2:55</span><br><span class="line">&gt;0</span><br><span class="line">&lt;=0</span><br><span class="line">Property Violated: PC is constraint <span class="comment"># = 1</span></span><br><span class="line">((a_1_SYMINT[<span class="number">15</span>] + b_2_SYMINT[-<span class="number">13</span>]) - CONST_2) == CONST_0</span><br><span class="line">Property Violated: result is  &quot;java.lang.ArithmeticException: div by <span class="number">0</span>...&quot;</span><br><span class="line">****************************</span><br><span class="line"></span><br><span class="line">====================================================== error <span class="number">1</span></span><br><span class="line">gov.nasa.jpf.vm.NoUncaughtExceptionsProperty</span><br><span class="line">java.lang.ArithmeticException: div by <span class="number">0</span></span><br><span class="line">        at demo.NumericExample.test(NumericExample.java:<span class="number">26</span>)</span><br><span class="line">        at demo.NumericExample.main(NumericExample.java:<span class="number">34</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====================================================== snapshot #<span class="number">1</span></span><br><span class="line">thread java.lang.Thread:&#123;id:<span class="number">0</span>,name:main,status:RUNNING,priority:<span class="number">5</span>,isDaemon:false,lockCount:<span class="number">0</span>,suspendCount:<span class="number">0</span>&#125;</span><br><span class="line">  call stack:</span><br><span class="line">        at demo.NumericExample.test(NumericExample.java:<span class="number">26</span>)</span><br><span class="line">        at demo.NumericExample.main(NumericExample.java:<span class="number">34</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====================================================== Method Summaries</span><br><span class="line">Inputs: a_1_SYMINT,b_2_SYMINT</span><br><span class="line"></span><br><span class="line">demo.NumericExample.test(-<span class="number">50</span>,<span class="number">17</span>)  --&gt; Return Value: --</span><br><span class="line">demo.NumericExample.test(<span class="number">0</span>,<span class="number">0</span>)  --&gt; Return Value: --</span><br><span class="line">demo.NumericExample.test(<span class="number">15</span>,-<span class="number">13</span>)  --&gt; &quot;java.lang.ArithmeticException: div by <span class="number">0</span>...&quot;</span><br><span class="line"></span><br><span class="line">====================================================== Method Summaries (HTML)</span><br><span class="line">&lt;h1&gt;Test Cases Generated by Symbolic JavaPath Finder for demo.NumericExample.test (Path Coverage) &lt;/h1&gt;</span><br><span class="line">&lt;table border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;a_1_SYMINT&lt;/td&gt;&lt;td&gt;b_2_SYMINT&lt;/td&gt;&lt;td&gt;RETURN&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;-<span class="number">50</span>&lt;/td&gt;&lt;td&gt;<span class="number">17</span>&lt;/td&gt;&lt;td&gt;Return Value: --&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;<span class="number">0</span>&lt;/td&gt;&lt;td&gt;<span class="number">0</span>&lt;/td&gt;&lt;td&gt;Return Value: --&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;<span class="number">15</span>&lt;/td&gt;&lt;td&gt;-<span class="number">13</span>&lt;/td&gt;&lt;td&gt;&quot;java.lang.ArithmeticException: div by <span class="number">0</span>...&quot;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">====================================================== results</span><br><span class="line">error #<span class="number">1</span>: gov.nasa.jpf.vm.NoUncaughtExceptionsProperty &quot;java.lang.ArithmeticException: div by <span class="number">0</span>  at demo.N...&quot;</span><br><span class="line"></span><br><span class="line">====================================================== statistics</span><br><span class="line">elapsed time:       <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">states:             new=<span class="number">5</span>,visited=<span class="number">0</span>,backtracked=<span class="number">5</span>,end=<span class="number">2</span></span><br><span class="line">search:             maxDepth=<span class="number">3</span>,constraints=<span class="number">0</span></span><br><span class="line">choice generators:  thread=<span class="number">1</span> (signal=<span class="number">0</span>,lock=<span class="number">1</span>,sharedRef=<span class="number">0</span>,threadApi=<span class="number">0</span>,reschedule=<span class="number">0</span>), data=<span class="number">2</span></span><br><span class="line">heap:               new=<span class="number">371</span>,released=<span class="number">20</span>,maxLive=<span class="number">349</span>,gcCycles=<span class="number">3</span></span><br><span class="line">instructions:       <span class="number">3246</span></span><br><span class="line">max memory:         <span class="number">709</span>MB</span><br><span class="line">loaded code:        classes=<span class="number">64</span>,methods=<span class="number">1325</span></span><br><span class="line"></span><br><span class="line">====================================================== search finished: <span class="number">23</span>-<span class="number">12</span>-<span class="number">29</span> 下午<span class="number">2</span>:<span class="number">55</span></span><br></pre></td></tr></table></figure>
<h1 id="jpf-symbc-使用"><code>jpf-symbc</code> 使用</h1>
<p>对于每个要进行符号执行的程序, 需要编写一个 <code>.jpf</code> 文件, 然后调用 <code>RunJPF.jar</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in jpf-symbc</span></span><br><span class="line">java -Xmx1024m -ea -jar ../jpf-core/build/RunJPF.jar src/examples/demo/NumericExample.jpf</span><br></pre></td></tr></table></figure>
<h2 id="jpf-文件内容含义"><code>.jpf</code> 文件内容含义</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 测试的application类</span></span><br><span class="line"><span class="attr">target</span>=x.y.TreeMapSimple</span><br><span class="line"></span><br><span class="line"><span class="attr">target.args</span>=arg1,arg2</span><br><span class="line"></span><br><span class="line"><span class="attr">classpath</span>=<span class="variable">$&#123;jpf-symbc&#125;</span>/build/examples  <span class="comment">; path to your class example</span></span><br><span class="line"><span class="attr">sourcepath</span>=<span class="variable">$&#123;jpf-symbc&#125;</span>/build/examples  <span class="comment">; path to the source of your example</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 注册到jpf-core的listener</span></span><br><span class="line"><span class="comment">; 控制接下来做什么</span></span><br><span class="line"><span class="comment">; gov.nasa.jpf.listener.PreciseRaceDetector  竞争情况检查</span></span><br><span class="line"><span class="comment">; gov.nasa.jpf.listener.CoverageAnalyzer   分析覆盖率</span></span><br><span class="line"><span class="comment">; gov.nasa.jpf.listener.DeadlockAnalyzer   分析代码死锁</span></span><br><span class="line"><span class="comment">; gov.nasa.jpf.listener.MethodAnalyzer</span></span><br><span class="line"><span class="comment">; gov.nasa.jpf.symbc.SymbolicListener   输出 PC 和 JUnit test</span></span><br><span class="line"><span class="comment">; gov.nasa.jpf.symbc.sequences.SymbolicSequenceListener  输出 JUnit test</span></span><br><span class="line"><span class="comment">; gov.nasa.jpf.symbc.GreenListener</span></span><br><span class="line"><span class="attr">listener</span>=gov.nasa.jpf.symbc.SymbolicListener,gov.nasa.jpf.symbc.sequences.SymbolicSequenceListener,gov.nasa.jpf.listener.PreciseRaceDetector,gov.nasa.jpf.listener.CoverageAnalyzer</span><br><span class="line"></span><br><span class="line"><span class="comment">; specify some search limit</span></span><br><span class="line"><span class="attr">search.depth_limit</span>=<span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="attr">coverage.include</span>=dataflow.Billing</span><br><span class="line"><span class="attr">coverage.show_requirements</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 遇到exception的时候打印stack trace</span></span><br><span class="line"><span class="comment">; 和 PreciseRaceDetector 一起使用</span></span><br><span class="line"><span class="comment">; error trace snapshot</span></span><br><span class="line"><span class="attr">report.console.property_violation</span>=error,trace</span><br><span class="line"></span><br><span class="line"><span class="comment">; 对于 random.nextInt 枚举随机数</span></span><br><span class="line"><span class="attr">cg.enumerate_random</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 和 MethodAnalyzer 一起使用</span></span><br><span class="line"><span class="attr">method.include</span>=*Robot*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">; 测试的目标方法, 多个函数用逗号分隔</span></span><br><span class="line"><span class="comment">; 函数参数用 (sym) 表示, 多个参数用 # 分隔</span></span><br><span class="line"><span class="comment">; 例如: triangle.Triangle.getType(sym#sym#sym)</span></span><br><span class="line"><span class="attr">symbolic.method</span>=TreeMapSimple.containsKey(sym),TreeMapSimple.put(sym),TreeMapSimple.remove(sym)</span><br><span class="line"></span><br><span class="line"><span class="comment">; specify the decision procedure to use</span></span><br><span class="line"><span class="comment">; z3, z3inc, z3bitvector, z3bitvectorinc</span></span><br><span class="line"><span class="comment">; cvc3, cvc3bitvec, choco, iasolver</span></span><br><span class="line"><span class="attr">symbolic.dp</span>=z3bitvector</span><br><span class="line"><span class="attr">symbolic.bvlength</span>=<span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 各种类型的范围</span></span><br><span class="line"><span class="attr">symbolic.min_int</span>=-<span class="number">100</span></span><br><span class="line"><span class="attr">symbolic.max_int</span>=<span class="number">100</span></span><br><span class="line"><span class="attr">symbolic.min_double</span>=-<span class="number">100.0</span></span><br><span class="line"><span class="attr">symbolic.max_double</span>=<span class="number">100.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; print some debug information</span></span><br><span class="line"><span class="attr">symbolic.debug</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; handling symbolic arrays</span></span><br><span class="line"><span class="attr">symbolic.lazy</span>=<span class="literal">on</span></span><br><span class="line"><span class="attr">symbolic.arrays</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; specify string analysis</span></span><br><span class="line"><span class="attr">symbolic.strings</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">symbolic.string_dp</span>=ABC  <span class="comment">; or z3str</span></span><br><span class="line"><span class="attr">symbolic.string_dp_timeout_ms</span>=<span class="number">3000</span></span><br></pre></td></tr></table></figure>
<h1 id="section"></h1>
<h1 id="jpf-源码分析"><code>jpf</code> 源码分析</h1>
]]></content>
      <categories>
        <category>software-test</category>
      </categories>
      <tags>
        <tag>jpf-symbc</tag>
      </tags>
  </entry>
  <entry>
    <title>1032. Sharing</title>
    <url>/2020/12/18/1032/</url>
    <content><![CDATA[<p>寻找最长公共后缀</p>
<p>注意: 边界情况: 两条链没有交集, 其中一条链是另一条链的子链</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">ERR</span><span class="params">(T x, string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[DEBUG]&#123;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#125; = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> debug(x) ERR(x, #x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> debug(...) 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">map&lt;string, pair&lt;<span class="type">char</span>, string&gt;&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(__FILE__ <span class="string">&quot;.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">// freopen(__FILE__ &quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    string w1, w2;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; w1 &gt;&gt; w2 &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        string a, b;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; c &gt;&gt; b;</span><br><span class="line">        M[a] = <span class="built_in">make_pair</span>(c, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;string&gt; s1, s2;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;s1&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (string addr = w1; addr != <span class="string">&quot;-1&quot;</span>; addr = M[addr].second) &#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(addr);</span><br><span class="line">        <span class="built_in">debug</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;s2&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (string addr = w2; addr != <span class="string">&quot;-1&quot;</span>; addr = M[addr].second) &#123;</span><br><span class="line">        s2.<span class="built_in">push</span>(addr);</span><br><span class="line">        <span class="built_in">debug</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string top = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (s1.<span class="built_in">size</span>() &amp;&amp; s2.<span class="built_in">size</span>() &amp;&amp; s1.<span class="built_in">top</span>() == s2.<span class="built_in">top</span>()) &#123;</span><br><span class="line">        top = s1.<span class="built_in">top</span>();</span><br><span class="line">        <span class="built_in">debug</span>(top);</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; top &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1035. Password</title>
    <url>/2021/01/13/1035/</url>
    <content><![CDATA[<p>水题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">0</span>;</span><br><span class="line">    ostringstream out;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        string name, pass;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; name &gt;&gt; pass;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;ch : pass) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: ch = <span class="string">&#x27;L&#x27;</span>; flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: ch = <span class="string">&#x27;@&#x27;</span>; flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: ch = <span class="string">&#x27;%&#x27;</span>; flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: ch = <span class="string">&#x27;o&#x27;</span>; flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            mod++;</span><br><span class="line">            out &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pass &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mod) &#123;</span><br><span class="line">        cout &lt;&lt; mod &lt;&lt; endl &lt;&lt; out.<span class="built_in">str</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;There &quot;</span> &lt;&lt; (n == <span class="number">1</span> ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;are&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; account&quot;</span></span><br><span class="line">             &lt;&lt; (n == <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;s&quot;</span>) &lt;&lt; <span class="string">&quot; and no account is modified&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1036. Boys vs Girls</title>
    <url>/2021/01/11/1036/</url>
    <content><![CDATA[<p>送分题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string major;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    student s, male_min, female_max;</span><br><span class="line">    <span class="type">int</span> score, male_score_min = <span class="number">101</span>, female_score_max = <span class="number">-1</span>;</span><br><span class="line">    string gender;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s.name &gt;&gt; gender &gt;&gt; s.major &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (gender == <span class="string">&quot;M&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (score &lt; male_score_min) &#123;</span><br><span class="line">                male_min = s;</span><br><span class="line">                male_score_min = score;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (score &gt; female_score_max) &#123;</span><br><span class="line">                female_max = s;</span><br><span class="line">                female_score_max = score;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (female_score_max != <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; female_max.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; female_max.major &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Absent&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (male_score_min != <span class="number">101</span>) &#123;</span><br><span class="line">        cout &lt;&lt; male_min.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; male_min.major &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Absent&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (female_score_max != <span class="number">-1</span> &amp;&amp; male_score_min != <span class="number">101</span>) &#123;</span><br><span class="line">        cout &lt;&lt; female_score_max - male_score_min &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1046. Shortest Distance</title>
    <url>/2021/01/08/1046/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>仅由一个环的图, 求任意两个节点之间的最短距离</p>
<h2 id="思路">思路</h2>
<p>将环剪开成一条线, 记录每个节点距离起始节点的距离, 查询时取两个方向的距离的最小值</p>
<h2 id="感想">感想</h2>
<p>意外的很简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> D[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(__FILE__ <span class="string">&quot;.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> dist;</span><br><span class="line">        cin &gt;&gt; dist;</span><br><span class="line">        D[i + <span class="number">1</span>] = D[i] + dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = D[n];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(D[y - <span class="number">1</span>] - D[x - <span class="number">1</span>], len - D[y - <span class="number">1</span>] + D[x - <span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1048. Find Coins</title>
    <url>/2021/01/14/1048/</url>
    <content><![CDATA[<p>寻找{(x,y)|x+y=m,x,y∈S}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        S[x]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;k : S) &#123;</span><br><span class="line">        <span class="type">int</span> x = k.first;</span><br><span class="line">        <span class="type">int</span> y = m - x;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y &amp;&amp; S.<span class="built_in">find</span>(y) != S.<span class="built_in">end</span>() || x == y &amp;&amp; S[x] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!minx || x &lt; minx)</span><br><span class="line">                minx = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minx) &#123;</span><br><span class="line">        cout &lt;&lt; minx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m - minx &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1055. The World&#39;s Richest</title>
    <url>/2021/01/22/1055/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>数据表按照某一列筛选后按另一列排序输出, 重复多次</p>
<h2 id="优化">优化</h2>
<p>按照输出的最大数量缩减原数据表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> worth;</span><br><span class="line">    <span class="built_in">person</span>(<span class="type">const</span> string &amp;name, <span class="type">const</span> <span class="type">int</span> &amp;age, <span class="type">const</span> <span class="type">int</span> &amp;worth)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age), <span class="built_in">worth</span>(worth)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;person&gt; P;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        string name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> worth;</span><br><span class="line">        cin &gt;&gt; name &gt;&gt; age &gt;&gt; worth;</span><br><span class="line">        P.<span class="built_in">emplace_back</span>(name, age, worth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(P.<span class="built_in">begin</span>(), P.<span class="built_in">end</span>(), [](<span class="type">const</span> person &amp;p1, <span class="type">const</span> person &amp;p2) &#123;</span><br><span class="line">        <span class="built_in">return</span> (p1.worth != p2.worth ?</span><br><span class="line">                    p1.worth &gt; p2.worth :</span><br><span class="line">                    (p1.age != p2.age ? p1.age &lt; p2.age : p1.name &lt; p2.name));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    vector&lt;person&gt; P1;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; AgeCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AgeCount[P[i].age] &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            AgeCount[P[i].age]++;</span><br><span class="line">            P1.<span class="built_in">emplace_back</span>(P[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> m, amin, amax, count = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; m &gt;&gt; amin &gt;&gt; amax;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;p : P1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.age &gt;= amin &amp;&amp; p.age &lt;= amax) &#123;</span><br><span class="line">                cout &lt;&lt; p.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.worth &lt;&lt; endl;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count &gt;= m)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;None&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1063. Set Similarity</title>
    <url>/2020/12/25/1063/</url>
    <content><![CDATA[<p>给出n个集合和k次查询, 计算集合相似度:</p>
<blockquote>
<p>集合相似度 = 交集元素数量 / 并集元素数量</p>
</blockquote>
<p>思路: 重复查询缓存结果</p>
<p>tips: * C++ STL中有<code>set_intersection</code>, <code>set_union</code>, <code>set_difference</code>可以直接使用 * insert_iterator<Container>(Container container, Iterator iter)可以创建一个"自动插入迭代器", 将对迭代器的copy(to)操作转化为插入操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; S[<span class="number">50</span>];</span><br><span class="line"><span class="type">float</span> F[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> _a, <span class="type">int</span> _b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (F[_a][_b]) &#123;</span><br><span class="line">        <span class="keyword">return</span> F[_a][_b];</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; &amp;a = S[_a], &amp;b = S[_b];</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; U, I;</span><br><span class="line">    <span class="built_in">set_intersection</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), insert_iterator&lt;set&lt;<span class="type">int</span>&gt;&gt;(I, I.<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), insert_iterator&lt;set&lt;<span class="type">int</span>&gt;&gt;(U, U.<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="type">float</span> res = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(I.<span class="built_in">size</span>()) / U.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) res = <span class="number">0.0001F</span>;</span><br><span class="line">    <span class="keyword">return</span> F[_a][_b] = F[_b][_a] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            S[i].<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.1f%%\n&quot;</span>, <span class="number">100</span> * <span class="built_in">compare</span>(a - <span class="number">1</span>, b - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1093. Count PAT&#39;s</title>
    <url>/2021/01/10/1093/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>计算<code>PAT</code>字串个数</p>
<h2 id="思路">思路</h2>
<p>动态规划?</p>
<table>
<thead>
<tr class="header">
<th>增加一个</th>
<th><code>PAT</code>个数</th>
<th><code>PA</code>个数</th>
<th><code>P</code>个数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P</td>
<td>不变</td>
<td>不变</td>
<td>增加1</td>
</tr>
<tr class="even">
<td>A</td>
<td>不变</td>
<td>增加前面的<code>P</code>的个数</td>
<td>不变</td>
</tr>
<tr class="odd">
<td>T</td>
<td>增加前面的<code>PA</code>字串的个数</td>
<td>不变</td>
<td>不变</td>
</tr>
</tbody>
</table>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    ll p = <span class="number">0</span>, pa = <span class="number">0</span>, pat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>: p++; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: pa = (pa + p) % <span class="number">1000000007</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: pat = (pat + pa) % <span class="number">1000000007</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; pat % <span class="number">1000000007</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1098. Insertion or Heap Sort</title>
    <url>/2020/12/19/1098/</url>
    <content><![CDATA[<p>根据排序的中间结果判断使用的插入排序还是堆排序, 并给出下一轮迭代的中间结果</p>
<p>堆排序: 先逐步构造一个大顶堆, 再每次从堆中取出最大的元素放到堆后面</p>
<p>思路: 插入排序的特点: 前面递增, 后面和原数组一样</p>
<p>进行1次插排: sort 进行1次堆排: pop_heap</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; n &amp;&amp; b[p - <span class="number">1</span>] &lt;= b[p])</span><br><span class="line">        p++;</span><br><span class="line">    <span class="type">int</span> index = p;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; n &amp;&amp; a[p] == b[p])</span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">if</span> (p == n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Insertion Sort&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sort</span>(b, b + index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Heap Sort&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> p = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; <span class="number">1</span> &amp;&amp; b[p] &gt;= b[<span class="number">1</span>])</span><br><span class="line">            p--;</span><br><span class="line">        <span class="built_in">pop_heap</span>(b, b + p + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(__FILE__ <span class="string">&quot;.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1099. Build A Binary Search Tree</title>
    <url>/2020/12/16/1099/</url>
    <content><![CDATA[<p>给出二叉树结构和节点的值列表, 将值填入二叉树中, 输出层次序遍历的结果</p>
<p>考点: 二叉树的直接后继</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">ERR</span><span class="params">(T x, string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[DEBUG]&#123;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#125; = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> debug(x) ERR(x, #    x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> debug(...) 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> left, right, parent;</span><br><span class="line">&#125; N[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(__FILE__ <span class="string">&quot;.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">// freopen(__FILE__ &quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    N[<span class="number">0</span>].parent = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        N[i].left = l;</span><br><span class="line">        N[l].parent = i;</span><br><span class="line">        N[i].right = r;</span><br><span class="line">        N[r].parent = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        cin &gt;&gt; val;</span><br><span class="line">        vals.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vals.<span class="built_in">begin</span>(), vals.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (N[p].left != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N[p].left != <span class="number">-1</span>)</span><br><span class="line">            p = N[p].left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">debug</span>(p);</span><br><span class="line">        N[p].val = vals.<span class="built_in">front</span>();</span><br><span class="line">        vals.<span class="built_in">erase</span>(vals.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N[p].right != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// right down</span></span><br><span class="line">            p = N[p].right;</span><br><span class="line">            <span class="keyword">while</span> (N[p].left != <span class="number">-1</span>) &#123;</span><br><span class="line">                p = N[p].left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N[p].parent != <span class="number">-1</span> &amp;&amp; N[N[p].parent].left == p) &#123;</span><br><span class="line">            <span class="comment">// right up</span></span><br><span class="line">            p = N[p].parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (N[p].parent != <span class="number">-1</span> &amp;&amp; N[N[p].parent].right == p) &#123;</span><br><span class="line">                p = N[p].parent;</span><br><span class="line">            &#125;</span><br><span class="line">            p = N[p].parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (Q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> top = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!first)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            first = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; N[top].val;</span><br><span class="line">        <span class="keyword">if</span> (N[top].left != <span class="number">-1</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(N[top].left);</span><br><span class="line">        <span class="keyword">if</span> (N[top].right != <span class="number">-1</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(N[top].right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1104. Sum of Number Segments</title>
    <url>/2021/01/07/1104/</url>
    <content><![CDATA[<p>数学题</p>
<h2 id="大意">大意</h2>
<p>给定一个数组, 计算该数组所有子序列的和的和, 即</p>
<p><span class="math display">\[
\begin{aligned}
S&amp;=\sum_{i=1}^{n}\sum_{j=i}^{n}{\sum_{k=i}^{j}{a_{k}}}
\\&amp;=\sum_{i=1}^{n}\sum_{j=i}^{n}{\sum_{k=i}^{j}{a_{k}}}
\end{aligned}
\]</span></p>
<h2 id="求解">求解</h2>
<p>对于任意<span class="math inline">\(x\in{[1,n]}\)</span>, <span class="math inline">\(a_{x}\)</span>被计算的次数</p>
<p>就等于集合<span class="math inline">\(\{(i,j)|1 \le i \le j \le n\}\)</span>中<span class="math inline">\(i \le x \le j\)</span>的次数</p>
<p>即 <span class="math display">\[
\begin{aligned}
C_{x}&amp;=\sum_{i=1}^{x}{\sum_{j=x}^{n}{1}} \\
&amp;=\sum_{i=1}^{x}{(n-x+1)} \\
&amp;=x(n-x+1)
\end{aligned}
\]</span></p>
<p>总和</p>
<p><span class="math display">\[
\begin{aligned}
S&amp;=\sum_{i=1}^{n}{C_{i}a_{i}}\\
&amp;=\sum_{i=1}^{n}{(i(n-i+1)a_{i})}\\
\end{aligned}
\]</span></p>
<p>实测: 高精度? <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">double</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        res += (<span class="type">long</span> <span class="type">long</span>)(<span class="number">1000</span> * x) * i * (n - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, res / <span class="number">1000.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1109. Group Photo</title>
    <url>/2021/01/22/1109/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<ol type="1">
<li>将N个人按照身高排成K行</li>
<li>每行N/K个人,</li>
<li>后排的人比前排的人高</li>
<li>每一排之中, 最高的人在中间, 然后依次在左,右排列</li>
<li>相同身高的人按字典序排列</li>
</ol>
<h2 id="思路">思路</h2>
<p>用deque模拟一排</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;string, <span class="type">int</span>&gt; person;</span><br><span class="line">    vector&lt;person&gt; P;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        string name;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        cin &gt;&gt; name &gt;&gt; height;</span><br><span class="line">        P.<span class="built_in">emplace_back</span>(name, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(P.<span class="built_in">begin</span>(), P.<span class="built_in">end</span>(), [](<span class="type">const</span> person &amp;p1, <span class="type">const</span> person &amp;p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.second != p2.second ? p1.second &gt; p2.second :</span><br><span class="line">                                        p1.first &lt; p2.first;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rowcount = n / k;</span><br><span class="line">    <span class="type">int</span> rest = n % k;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; row;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, left = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left)</span><br><span class="line">            row.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            row.<span class="built_in">push_front</span>(i);</span><br><span class="line">        left = <span class="number">1</span> - left;</span><br><span class="line">        <span class="keyword">if</span> (row.<span class="built_in">size</span>() == rowcount + rest) &#123;</span><br><span class="line">            rest = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;i : row) &#123;</span><br><span class="line">                cout &lt;&lt; (first ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; &quot;</span>) &lt;&lt; P[i].first;</span><br><span class="line">                first = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first = <span class="number">1</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            row.<span class="built_in">clear</span>();</span><br><span class="line">            left = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;i : row) &#123;</span><br><span class="line">        cout &lt;&lt; (first ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; &quot;</span>) &lt;&lt; P[i].first;</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1115. Counting Nodes in a BST</title>
    <url>/2020/12/15/1115/</url>
    <content><![CDATA[<p>按给定序列构造一个二叉搜索树, 分别计算最低两层的节点数量</p>
<p>思路: 如题, 考基本功</p>
<p>注意: 一种新奇的写法, 获取倒数第n个元素 (想到了Python是不是XD) <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector&lt;int&gt; x;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">cout &lt;&lt; x.<span class="built_in">end</span>()[-n] &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>代码(有内存泄漏): <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    node *left, *right, *parent;</span><br><span class="line">&#125; root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.parent) &#123;</span><br><span class="line">        <span class="comment">// is the first root</span></span><br><span class="line">        root.parent = &amp;root;</span><br><span class="line">        root.val = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node *p = &amp;root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= p-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; p-&gt;val) &#123;</span><br><span class="line">        p-&gt;right = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">        p-&gt;right-&gt;val = x;</span><br><span class="line">        p-&gt;right-&gt;parent = p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;left = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">        p-&gt;left-&gt;val = x;</span><br><span class="line">        p-&gt;left-&gt;parent = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trav</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;node *&gt; Q;</span><br><span class="line">    <span class="keyword">if</span> (root.parent) &#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(&amp;root);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> lcount = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; counts;</span><br><span class="line">    <span class="keyword">while</span> (Q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        node *x = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            counts.<span class="built_in">push_back</span>(lcount);</span><br><span class="line">            lcount = <span class="number">0</span>;</span><br><span class="line">            Q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lcount++;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;left)</span><br><span class="line">            Q.<span class="built_in">push</span>(x-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;right)</span><br><span class="line">            Q.<span class="built_in">push</span>(x-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    counts.<span class="built_in">push_back</span>(lcount);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> back = counts.<span class="built_in">size</span>() ? counts.<span class="built_in">back</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> back2 = counts.<span class="built_in">size</span>() &gt; <span class="number">2</span> ? counts.<span class="built_in">end</span>()[<span class="number">-2</span>] : <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; back &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; back2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; back + back2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">trav</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1123. Is It a Complete AVL Tree</title>
    <url>/2020/12/18/1123/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<p>按输入序列构造AVL树, 输出层次序遍历的结果, 和AVL树是否为完全二叉树</p>
<h2 id="一些小技巧">一些小技巧:</h2>
<h3 id="树的初始化问题">1. 树的初始化问题</h3>
<p>我们可以让insert函数返回插入后新的树根(从而可以递归调用), 调用时采用 <code>node = insert(node, val)</code> 的方式, 从而统一了第一个节点和其他节点的处理, 极大地简化了判断逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">insert</span><span class="params">(node* p, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">        p=<span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">        p-&gt;val=x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;p-&gt;val)&#123;</span><br><span class="line">        p-&gt;left=<span class="built_in">insert</span>(p-&gt;left,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;right=<span class="built_in">insert</span>(p-&gt;right,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node*root=<span class="literal">nullptr</span>;</span><br><span class="line">    root=<span class="built_in">insert</span>(root,<span class="number">1</span>);</span><br><span class="line">    root=<span class="built_in">insert</span>(root,<span class="number">2</span>);</span><br><span class="line">    root=<span class="built_in">insert</span>(root,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="体会">体会:</h2>
<ol type="1">
<li>KISS, 简单的才是最好的</li>
<li>用好递归能节约大量代码</li>
<li>数据结构题不必在性能上过多纠结</li>
</ol>
<h2 id="代码">代码</h2>
<p>(部分参考自网络) <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    node *left = <span class="literal">nullptr</span>, *right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p ? <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">depth</span>(p-&gt;left), <span class="built_in">depth</span>(p-&gt;right)) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">rr</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *lc = p-&gt;left;</span><br><span class="line">    p-&gt;left = lc-&gt;right;</span><br><span class="line">    lc-&gt;right = p;</span><br><span class="line">    <span class="keyword">return</span> lc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">lr</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *rc = p-&gt;right;</span><br><span class="line">    p-&gt;right = rc-&gt;left;</span><br><span class="line">    rc-&gt;left = p;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">lrr</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;left = <span class="built_in">lr</span>(p-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rr</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">rlr</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;right = <span class="built_in">rr</span>(p-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lr</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">insert</span><span class="params">(node *p, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">        p-&gt;val = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; p-&gt;val) &#123;</span><br><span class="line">        p-&gt;left = <span class="built_in">insert</span>(p-&gt;left, x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">depth</span>(p-&gt;left) - <span class="built_in">depth</span>(p-&gt;right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; p-&gt;left-&gt;val)</span><br><span class="line">                p = <span class="built_in">rr</span>(p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = <span class="built_in">lrr</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;right = <span class="built_in">insert</span>(p-&gt;right, x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">depth</span>(p-&gt;left) - <span class="built_in">depth</span>(p-&gt;right) &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; p-&gt;right-&gt;val)</span><br><span class="line">                p = <span class="built_in">lr</span>(p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = <span class="built_in">rlr</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trav</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> empty = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> comp = <span class="number">1</span>;</span><br><span class="line">    queue&lt;node *&gt; Q;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        node *top = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; top-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (top-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                comp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.<span class="built_in">push</span>(top-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            empty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (top-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                comp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.<span class="built_in">push</span>(top-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            empty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; (comp ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        root = <span class="built_in">insert</span>(root, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">trav</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1140. Look-and-say Sequence</title>
    <url>/2021/01/10/1140/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>求一个数字用行程编码压缩n-1次的结果</p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">compress</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n || i &gt; <span class="number">0</span> &amp;&amp; s[i] != s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">            res += <span class="built_in">to_string</span>(count);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s = <span class="built_in">compress</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1151. LCA in a Binary Tree</title>
    <url>/2021/01/12/1151/</url>
    <content><![CDATA[<p>二叉树上寻找最近公共祖先</p>
<p>需要注意节点的key不一定连续</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> left, right, parent, depth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, node&gt; N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator &amp;preord_b,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator &amp;preord_e,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator &amp;inord_b,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator &amp;inord_e,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> parent,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preord_b == preord_e)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> key = *preord_b;</span><br><span class="line">    <span class="keyword">auto</span> inord_mid = <span class="built_in">find</span>(inord_b, inord_e, key);</span><br><span class="line">    <span class="type">int</span> left_len = inord_mid - inord_b;</span><br><span class="line">    N[key].left = <span class="built_in">build</span>(preord_b + <span class="number">1</span>, preord_b + <span class="number">1</span> + left_len, inord_b,</span><br><span class="line">        inord_mid, key, depth + <span class="number">1</span>);</span><br><span class="line">    N[key].right = <span class="built_in">build</span>(preord_b + <span class="number">1</span> + left_len, preord_e, inord_mid + <span class="number">1</span>,</span><br><span class="line">        inord_e, key, depth + <span class="number">1</span>);</span><br><span class="line">    N[key].parent = parent;</span><br><span class="line">    N[key].depth = depth;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N[a].depth &gt; N[b].depth) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lca</span>(N[a].parent, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N[a].depth &lt; N[b].depth) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lca</span>(N[b].parent, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lca</span>(N[a].parent, N[b].parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inord</span><span class="params">(n)</span>, <span class="title">preord</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; inord[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; preord[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root =</span><br><span class="line">        <span class="built_in">build</span>(preord.<span class="built_in">begin</span>(), preord.<span class="built_in">end</span>(), inord.<span class="built_in">begin</span>(), inord.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="type">bool</span> e1 = (N.<span class="built_in">find</span>(u) == N.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">bool</span> e2 = (N.<span class="built_in">find</span>(v) == N.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e1 &amp;&amp; e2) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; are not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e1 || e2) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; (e1 ? u : v) &lt;&lt; <span class="string">&quot; is not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">lca</span>(u, v);</span><br><span class="line">        <span class="keyword">if</span> (a == u || a == v) &#123;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; <span class="string">&quot; is an ancestor of &quot;</span> &lt;&lt; (a == u ? v : u) &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">                 &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;LCA of &quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">                 &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>每日 PTA</title>
    <url>/2020/12/15/index/</url>
    <content><![CDATA[<p>leetcode medium 纯算法题偏少, 准备每日加一道PTA.</p>
<p><strong>目标</strong>: 每天一道PTA甲级 [PAT (Advanced Level) Practice]</p>
<p>题号就roll一个<a href="http://katty.top:8888/api/rand?from=1&amp;to=156">随机数</a></p>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>10. 正则表达式匹配</title>
    <url>/2020/12/16/10/</url>
    <content><![CDATA[<p>实现支持.和*的正则表达式匹配.</p>
<p>思路: 动态规划</p>
<p>用 <span class="math inline">\(f[i][j]\)</span> 表示<span class="math inline">\(s\)</span>中的前 <span class="math inline">\(i\)</span> 个字母能否与 <span class="math inline">\(p\)</span> 中的前 <span class="math inline">\(j\)</span> 个字母匹配, 按照<span class="math inline">\(p[j]\)</span>是否为*分为两种情况</p>
<p>存在*时的转移方程可以这样考虑:</p>
<ol type="1">
<li><p>匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；(<span class="math inline">\(f[i-1][j]\)</span>)</p></li>
<li><p>不匹配字符，将该组合扔掉，不再进行匹配。(<span class="math inline">\(f[i][j - 2]\)</span>)</p></li>
</ol>
<p>最终的状态转移方程:</p>
<p><span class="math display">\[
f[i][j] = \begin{cases}
f[i - 1][j - 1], &amp; p[j] \neq &#39;*&#39; ~and~ s[i] = p[j] \\
false, &amp; p[j] \neq &#39;*&#39; ~and~ s[i] \neq p[j] \\
f[i][j - 2] ~or~ f[i-1][j], &amp; p[j] = &#39;*&#39; ~and~ s[i] = p[j-1] \\
f[i][j - 2], &amp; p[j] = &#39;*&#39; ~and~ s[i] \neq p[j-1]
\end{cases}
\]</span></p>
<p>代码: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> matches = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">matches</span>(i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">matches</span>(i, j)) &#123;</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>1018. 可被 5 整除的二进制前缀</title>
    <url>/2021/01/14/1018/</url>
    <content><![CDATA[<p>找规律题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">prefixesDivBy5</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; ret;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp;a:A)&#123;</span><br><span class="line">            res = res * <span class="number">2</span> + a;</span><br><span class="line">            res %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(res % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1202. 交换字符串中的元素</title>
    <url>/2021/01/11/1202/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给定一些可以任意交换位置的组, 求整个字符串的最小字典序</p>
<h2 id="思路">思路</h2>
<ol type="1">
<li>用并查集把所有组关联在一起</li>
<li>对于每个可交换组, 把所有候选字母依次填入</li>
</ol>
<h2 id="收获">收获</h2>
<ol type="1">
<li>unordered_map的使用</li>
<li>c++的for-range语法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;[i,group]:groups)&#123;</span><br><span class="line">    <span class="built_in">sort</span>(group.<span class="built_in">begin</span>(),group.<span class="built_in">end</span>(),<span class="built_in">greater</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>重温并查集</li>
</ol>
<h2 id="代码">代码</h2>
<p>参考官方题解优化完毕</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;parents,rank;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dj_root</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (parents[i]==i ? i : parents[i]=<span class="built_in">dj_root</span>(parents[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dj_union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        a=<span class="built_in">dj_root</span>(a);</span><br><span class="line">        b=<span class="built_in">dj_root</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(a==b)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[a]&lt;rank[b])<span class="built_in">swap</span>(a,b);</span><br><span class="line">        rank[a]+=rank[b];</span><br><span class="line">        parents[a]=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">smallestStringWithSwaps</span><span class="params">(string s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        parents.<span class="built_in">resize</span>(n);</span><br><span class="line">        rank.<span class="built_in">resize</span>(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parents[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp;pair:pairs)&#123;</span><br><span class="line">            <span class="built_in">dj_union</span>(pair[<span class="number">0</span>],pair[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,string&gt;groups;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> r=<span class="built_in">dj_root</span>(i);</span><br><span class="line">            groups[r].<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;[i,group]:groups)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(group.<span class="built_in">begin</span>(),group.<span class="built_in">end</span>(),<span class="built_in">greater</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> g=<span class="built_in">dj_root</span>(i);</span><br><span class="line">            s[i]=groups[g].<span class="built_in">back</span>();</span><br><span class="line">            groups[g].<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1203. 项目管理</title>
    <url>/2021/01/12/1203/</url>
    <content><![CDATA[<p>双重拓扑排序: 组内 &amp; 组间</p>
<p>拓扑排序 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; deg, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="type">int</span>&gt;&amp; items)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item: items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deg[item] == <span class="number">0</span>) &#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = Q.<span class="built_in">front</span>(); </span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v: graph[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--deg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="built_in">size</span>() == items.<span class="built_in">size</span>() ? res : vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/xiang-mu-guan-li-by-leetcode-solution-3e7j/">官方题解</a></p>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>123. 买卖股票的最佳时机 III</title>
    <url>/2021/01/09/123/</url>
    <content><![CDATA[<p>最多可以交易两次</p>
<h2 id="思路">思路</h2>
<p>动态规划, 用四个状态变量</p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/">官方题解</a></p>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1395. 统计作战单位数</title>
    <url>/2021/07/02/1395/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">rating</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numTeams = <span class="keyword">function</span> (<span class="params">rating</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; rating.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> ri = rating[i];</span><br><span class="line">        <span class="keyword">let</span> countx1 = <span class="number">0</span>, countx2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> county1 = <span class="number">0</span>, county2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; i; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rating[x] &lt; ri) countx1++;</span><br><span class="line">            <span class="keyword">if</span> (rating[x] &gt; ri) countx2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> x = i + <span class="number">1</span>; x &lt; rating.<span class="property">length</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rating[x] &lt; ri) county1++;</span><br><span class="line">            <span class="keyword">if</span> (rating[x] &gt; ri) county2++;</span><br><span class="line">        &#125;</span><br><span class="line">        count += countx1 * county2 + countx2 * county1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1584. 连接所有点的最小费用</title>
    <url>/2021/01/19/1584/</url>
    <content><![CDATA[<p>实际上是最小生成树</p>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1833. 雪糕的最大数量</title>
    <url>/2021/07/02/1833/</url>
    <content><![CDATA[<p>排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">costs</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">coins</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxIceCream = <span class="keyword">function</span> (<span class="params">costs, coins</span>) &#123;</span><br><span class="line">    costs.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; costs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (costs[i] &lt;= coins) &#123;</span><br><span class="line">            coins -= costs[i];</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>189. 旋转数组</title>
    <url>/2021/01/08/189/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>使用O(n)时间和O(1)空间旋转数组</p>
<h2 id="思路">思路</h2>
<p>数学题, GCD</p>
<h2 id="感想">感想</h2>
<p>下次遇到这种题画个图会更好理解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n || n == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(k %= n))<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>, _gcd=<span class="built_in">gcd</span>(n,k); c&lt;_gcd; c++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = nums[c];</span><br><span class="line">            <span class="type">int</span> x=c,_x;</span><br><span class="line">            <span class="keyword">while</span>((_x=(x-k+n)%n)!=c)&#123;</span><br><span class="line">                nums[x]=nums[_x];</span><br><span class="line">                x=_x;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[x]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 两数相加</title>
    <url>/2020/12/25/2/</url>
    <content><![CDATA[<p>指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode*p1=l1,*p2=l2,*p3,*last=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> up=<span class="number">0</span>;</span><br><span class="line">        ListNode* root=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        p3=root;</span><br><span class="line">        <span class="keyword">while</span>(p1 || p2 || up)&#123;</span><br><span class="line">            <span class="type">int</span> n1=<span class="number">0</span>,n2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(p1)&#123;n1=p1-&gt;val;p1=p1-&gt;next;&#125;</span><br><span class="line">            <span class="keyword">if</span>(p2)&#123;n2=p2-&gt;val;p2=p2-&gt;next;&#125;</span><br><span class="line">            up+=n1+n2;</span><br><span class="line">            p3-&gt;val=up%<span class="number">10</span>;</span><br><span class="line">            last=p3;</span><br><span class="line">            p3=p3-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            up/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> last-&gt;next;</span><br><span class="line">        last-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>205. 同构字符串</title>
    <url>/2020/12/27/205/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">char</span>&gt;M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">char</span> ss = s[i], tt = t[i];</span><br><span class="line">            <span class="keyword">if</span>(M.<span class="built_in">find</span>(ss)==M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find_if</span>(M.<span class="built_in">begin</span>(),M.<span class="built_in">end</span>(),[&amp;](<span class="type">const</span> map&lt;<span class="type">char</span>, <span class="type">char</span>&gt;::iterator&amp;it)&#123;<span class="keyword">return</span> it-&gt;second==tt;&#125;)!=M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    M[ss]=tt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(M[ss]!=tt)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>217. 存在重复元素</title>
    <url>/2020/12/13/217/</url>
    <content><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>没啥好说的: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>())!=nums.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>228. 汇总区间</title>
    <url>/2021/01/10/228/</url>
    <content><![CDATA[<p>水题, 注意边界情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> last = (n&gt;<span class="number">0</span>?nums[<span class="number">0</span>]:<span class="number">0</span>);</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n || nums[i]!=nums[i<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (last==nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(last));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(last)+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">to_string</span>(nums[i<span class="number">-1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;n) last=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>23. 合并K个升序链表</title>
    <url>/2020/12/18/23/</url>
    <content><![CDATA[<p>思路类似归并排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode newList;</span><br><span class="line">        ListNode*head=&amp;newList;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> min=<span class="number">-1</span>,minval=<span class="number">0x3fffffff</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lists.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                ListNode*l=lists[i];</span><br><span class="line">                <span class="keyword">if</span>(l &amp;&amp; l-&gt;val &lt; minval)&#123;</span><br><span class="line">                    min=i;</span><br><span class="line">                    minval=l-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            head-&gt;next=lists[min];</span><br><span class="line">            lists[min]=lists[min]-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newList.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>25. K 个一组翻转链表</title>
    <url>/2021/03/01/25/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseKGroup</span><span class="params">(ListNode *head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode _header(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *last = &amp;_header;</span><br><span class="line">        head = last;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (head &amp;&amp; count == k) &#123;</span><br><span class="line">                count -= k;</span><br><span class="line">                ListNode *tmp_last_next = last-&gt;next;</span><br><span class="line">                <span class="built_in">reverseK</span>(last, k);</span><br><span class="line">                head = last = tmp_last_next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _header.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseK</span><span class="params">(ListNode *start, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *cur = start, *next = start-&gt;next;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; k) &#123;</span><br><span class="line">            ListNode *tmp = next-&gt;next;</span><br><span class="line">            next-&gt;next = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">            next = tmp;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        start-&gt;next-&gt;next = next;</span><br><span class="line">        start-&gt;next = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>290. 单词规律</title>
    <url>/2020/12/16/290/</url>
    <content><![CDATA[<p>判断给定<em>字符串</em>是不是按照给定<em>模式</em>的短语, 例如"dog dog cat cat"就是"aabb"式的短语</p>
<p>思路: 用map记录模式字母与单词的对应关系, 如果发现不一致, 返回false, 否则返回true</p>
<p>注意: 模式中不同字母对应的单词不能相同</p>
<p>提示:</p>
<p>按照key查询map可以使用map自带的find()函数</p>
<p>按照value查询map可以使用find_if()函数</p>
<p>两者都返回迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">M.<span class="built_in">find</span>(someKey);</span><br><span class="line"><span class="built_in">find_if</span>(M.<span class="built_in">begin</span>(), M.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; kv)&#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, string&gt; M;</span><br><span class="line">        vector&lt;string&gt; S;</span><br><span class="line">        <span class="type">char</span> *p = <span class="built_in">strtok</span>((<span class="type">char</span> *)s.<span class="built_in">c_str</span>(), <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="keyword">do</span> &#123;</span><br><span class="line">            S.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125; <span class="keyword">while</span> (p = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.<span class="built_in">size</span>() != S.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pattern.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> ch = pattern[i];</span><br><span class="line">            <span class="keyword">if</span> (M.<span class="built_in">find</span>(ch) == M.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">find_if</span>(M.<span class="built_in">begin</span>(),M.<span class="built_in">end</span>(),[&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp;p)&#123;<span class="keyword">return</span> p.second==S[i];&#125;)!=M.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;ch&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;S[i]&lt;&lt;endl;</span><br><span class="line">                M[ch] = S[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (M[ch] != S[i]) &#123;</span><br><span class="line">                cout&lt;&lt;M[ch]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;S[i]&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <url>/2021/03/01/3/</url>
    <content><![CDATA[<h2 id="思路">思路</h2>
<p>滑动窗口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; cur_group;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.<span class="built_in">size</span>() &amp;&amp; cur_group.<span class="built_in">find</span>(s[end]) == cur_group.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            cur_group.<span class="built_in">insert</span>(s[end++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> max_length = cur_group.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cur_group.<span class="built_in">erase</span>(s[i]);</span><br><span class="line">            <span class="keyword">while</span> (end &lt; s.<span class="built_in">size</span>() &amp;&amp; cur_group.<span class="built_in">find</span>(s[end]) == cur_group.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                cur_group.<span class="built_in">insert</span>(s[end++]);</span><br><span class="line">            &#125;</span><br><span class="line">            max_length = std::<span class="built_in">max</span>(max_length, cur_group.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>318. 最大单词长度乘积</title>
    <url>/2021/11/17/318/</url>
    <content><![CDATA[<p>位运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">to_uword</span><span class="params">(<span class="type">const</span> string &amp;word)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c: word) &#123;</span><br><span class="line">            res |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">unsigned</span>&gt; uwords;</span><br><span class="line">        uwords.<span class="built_in">reserve</span>(words.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;w: words) &#123;</span><br><span class="line">            uwords.<span class="built_in">push_back</span>(<span class="built_in">to_uword</span>(w));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;s1 = uwords[i];</span><br><span class="line">                <span class="keyword">auto</span> &amp;s2 = uwords[j];</span><br><span class="line">                <span class="keyword">if</span> (s1 &amp; s2) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="type">int</span> r = words[i].<span class="built_in">size</span>() * words[j].<span class="built_in">size</span>(); r &gt; m) m = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>37. 解数独</title>
    <url>/2021/03/01/37/</url>
    <content><![CDATA[<h2 id="思路">思路</h2>
<p>DFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">solveSudoku1</span>(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">solveSudoku1</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">9</span>||j&gt;=<span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j]==<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used_numbers</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][k]!=<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    used_numbers[board[i][k]-<span class="string">&#x27;1&#x27;</span>]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[k][j]!=<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    used_numbers[board[k][j]-<span class="string">&#x27;1&#x27;</span>]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> grid_i = i / <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> grid_j = j / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">3</span>*grid_i;m&lt;<span class="number">3</span>+<span class="number">3</span>*grid_i;m++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> n=<span class="number">3</span>*grid_j;n&lt;<span class="number">3</span>+<span class="number">3</span>*grid_j;n++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[m][n]!=<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        used_numbers[board[m][n]-<span class="string">&#x27;1&#x27;</span>]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">9</span>;ii++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (used_numbers[ii]==<span class="literal">false</span>) &#123;</span><br><span class="line">                    board[i][j] = ii+<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">solveSudoku1</span>(board, i+(j+<span class="number">1</span>)/<span class="number">9</span>, (j+<span class="number">1</span>)%<span class="number">9</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">solveSudoku1</span>(board, i+(j+<span class="number">1</span>)/<span class="number">9</span>, (j+<span class="number">1</span>)%<span class="number">9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>376. 摆动序列</title>
    <url>/2020/12/12/376/</url>
    <content><![CDATA[<p>思路: 先差分, 然后把所有0和相邻同号的数字(之一)去掉, 剩下的元素数量+2既是最终答案</p>
<p>注意: 元素个数为0, 元素个数为1, 差分后有0出现</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123; <span class="keyword">return</span> size + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> start = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            nums[i] -= nums[i + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// find first not zero</span></span><br><span class="line">            <span class="keyword">if</span> (start == <span class="number">-1</span> &amp;&amp; nums[i] != <span class="number">0</span>) &#123; start = i; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// none</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>, want = nums[start];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i] &gt; <span class="number">0</span> &amp;&amp; want &lt; <span class="number">0</span>) ||</span><br><span class="line">                (nums[i] &lt; <span class="number">0</span> &amp;&amp; want &gt; <span class="number">0</span>)) &#123;  <span class="comment">// different sign and no zero</span></span><br><span class="line">                want = nums[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看过题解: 复杂了, 只要统计波峰和波谷的数量就行了</p>
<p>别人的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, prev_diff = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev_diff &gt;= <span class="number">0</span>)</span><br><span class="line">                    count++;</span><br><span class="line">                prev_diff = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev_diff &lt;= <span class="number">0</span>)</span><br><span class="line">                    count++;</span><br><span class="line">                prev_diff = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：lincs</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/wiggle-subsequence/solution/java-on-solution-by-lincs-6l5r/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>389. 找不同</title>
    <url>/2020/12/18/389/</url>
    <content><![CDATA[<p>送分题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp;c:s)&#123;</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp;c:t)&#123;</span><br><span class="line">            count[c]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_if</span>(count.<span class="built_in">begin</span>(),count.<span class="built_in">end</span>(),[&amp;](<span class="keyword">auto</span> it)&#123;<span class="keyword">return</span> it.second!=<span class="number">0</span>;&#125;)-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>4. 寻找两个正序数组的中位数</title>
    <url>/2020/12/13/4/</url>
    <content><![CDATA[<p>思路: 先归并排序, 再寻找中间位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len1=nums1.<span class="built_in">size</span>(),len2=nums2.<span class="built_in">size</span>(),len=len1+len2;</span><br><span class="line">        <span class="type">int</span> t, lastt;</span><br><span class="line">        <span class="keyword">while</span>(i+j&lt;=len/<span class="number">2</span>)&#123;</span><br><span class="line">            lastt=t;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;len1 &amp;&amp; j&lt; len2)&#123;</span><br><span class="line">                <span class="type">int</span> n1=nums1[i];</span><br><span class="line">                <span class="type">int</span> n2=nums2[j];</span><br><span class="line">                <span class="keyword">if</span>(n1&lt;n2)&#123;</span><br><span class="line">                    t=n1;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    t=n2;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;len1)&#123;</span><br><span class="line">                t=nums1[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t=nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;i+j&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (len%<span class="number">2</span>?t:(t+lastt)/<span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>455. 分发饼干</title>
    <url>/2020/12/25/455/</url>
    <content><![CDATA[<p>排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>()); <span class="comment">// 1 2 3</span></span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>()); <span class="comment">// 1 1</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>, gg=g.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;gg&gt;=<span class="number">0</span>;i--,gg--,count++)&#123;</span><br><span class="line">            <span class="type">int</span> ss=s[i];</span><br><span class="line">            <span class="keyword">while</span>(gg&gt;=<span class="number">0</span>&amp;&amp;g[gg]&gt;ss)&#123;</span><br><span class="line">                gg--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(gg&lt;<span class="number">0</span>) count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>49. 字母异位词分组</title>
    <url>/2020/12/14/49/</url>
    <content><![CDATA[<p>思路: 字符串排序后作为key, 存到map中再转成vector返回, AC</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string s=strs[i];</span><br><span class="line">            <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">            m[s].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;k:m)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(k.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>5. 最长回文子串</title>
    <url>/2021/03/01/5/</url>
    <content><![CDATA[<h2 id="思路">思路</h2>
<p>动态规划 &lt; 中心扩展算法 &lt; manacher</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maximum = <span class="number">1</span>, maxI = <span class="number">0</span>, maxJ = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                    <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == j - i - <span class="number">1</span> &amp;&amp; s[i] == s[j])</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; maximum) &#123;</span><br><span class="line">                    maximum = dp[i][j];</span><br><span class="line">                    maxI = i;</span><br><span class="line">                    maxJ = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(s.<span class="built_in">begin</span>() + maxI, s.<span class="built_in">begin</span>() + maxJ + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>547. 省份数量</title>
    <url>/2021/01/07/547/</url>
    <content><![CDATA[<p>无向图给出邻接表, 计算连通分量个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">flag</span>(len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                queue&lt;<span class="type">int</span>&gt;found;</span><br><span class="line">                found.<span class="built_in">push</span>(i);</span><br><span class="line">                flag[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(!found.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="type">int</span> cur = found.<span class="built_in">front</span>(); found.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!flag[j]&amp;&amp;isConnected[cur][j])&#123;</span><br><span class="line">                            found.<span class="built_in">push</span>(j);</span><br><span class="line">                            flag[j]=<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>645. 错误的集合</title>
    <url>/2021/07/04/645/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findErrorNums = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ex = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">let</span> dup,lost;</span><br><span class="line">    <span class="keyword">for</span>(num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ex[num-<span class="number">1</span>])&#123;</span><br><span class="line">            ex[num-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dup=num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ex[i])&#123;</span><br><span class="line">            lost=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [dup, lost]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>684. 冗余连接</title>
    <url>/2021/01/13/684/</url>
    <content><![CDATA[<h2 id="思路">思路</h2>
<p>有环无向图中找出环上最后出现的边</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parents;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dj_root</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==parents[a]? a: parents[a]=<span class="built_in">dj_root</span>(parents[a]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dj_union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        a=<span class="built_in">dj_root</span>(a);</span><br><span class="line">        b=<span class="built_in">dj_root</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a!=b) parents[a]=b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge: edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[<span class="number">0</span>] &gt; n) n = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (edge[<span class="number">1</span>] &gt; n) n = edge[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        parents.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge: edges) &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> b = edge[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dj_root</span>(a) == <span class="built_in">dj_root</span>(b)) &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dj_union</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>738. 单调递增的数字</title>
    <url>/2020/12/15/738/</url>
    <content><![CDATA[<p>思路: 对于数字<code>x = an ... ai+1 ai ... a1 a0</code>, 如果任意相邻的<code>ai+1</code>,<code>ai</code>不符合单调递增, 就给原数字减去<code>(ai + 1) * 10 ^ i</code>, 减去之后得到的新数字即为<code>y</code></p>
<p>可以发现, 若<code>x</code>与<code>y</code>不完全相同, 则最终结果在第一个不相同位之后的位必定全是<code>9</code>, 按此规律修正结果即可.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(N);</span><br><span class="line">        string olds=s;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> bor=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bor)&#123;</span><br><span class="line">                s[i]--;</span><br><span class="line">                s[i+<span class="number">1</span>]+=<span class="number">10</span>;</span><br><span class="line">                bor=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;s[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="comment">// -s[i]-1</span></span><br><span class="line">                s[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                s[i<span class="number">-1</span>]--;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]&lt;<span class="string">&#x27;0&#x27;</span>) bor = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fix</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;olds[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    s[j]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// restore</span></span><br><span class="line">        <span class="type">int</span> val =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            val=val*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>每日 leetcode</title>
    <url>/2020/12/12/index/</url>
    <content><![CDATA[<h1 id="决定开始刷leetcode了">决定开始刷leetcode了</h1>
<p>目标: <del>每天一道</del> <del>如果每日一题是easy, 就加一道hard</del> 如果每日一题是easy, 就加一道medium</p>
]]></content>
      <categories>
        <category>algorithm-practice</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Bash使用</title>
    <url>/2021/02/11/bash/</url>
    <content><![CDATA[<h1 id="bash基本使用">Bash基本使用</h1>
<h2 id="常用快捷键">常用快捷键</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">^c   终止当前进程</span><br><span class="line">^z   将当前进程挂起到后台</span><br><span class="line">^d   退出, 等价于<span class="built_in">exit</span></span><br><span class="line">^l   清屏</span><br><span class="line">^r   搜索历史命令</span><br><span class="line">^a   光标移到开头</span><br><span class="line">^e   光标移到结尾</span><br><span class="line">^u   删除光标前所有内容</span><br><span class="line">^k   删除光标后所有内容</span><br></pre></td></tr></table></figure>
<h2 id="常用通配符">常用通配符</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*                       匹配前面的内容任意次</span><br><span class="line">?                       匹配前面的内容0-1次</span><br><span class="line">[list]                  list中任意一个字符</span><br><span class="line">&#123;string1,string2,...&#125;   string1,string2或者更多字符串</span><br></pre></td></tr></table></figure>
<h2 id="引号">引号</h2>
<ul>
<li>双引号<code>""</code> 把引号中的内容作为一个整体, 允许通过$符号来引用其他变量值</li>
<li>单引号<code>''</code> 把引号中的内容作为一个整体, 禁止通过$符号来引用其他变量值, 其中的shell特殊符号都视为普通字符</li>
<li>反引号 与$()相同, 先执行引号中的内容, 不能嵌套</li>
</ul>
<h1 id="shell脚本">shell脚本</h1>
<h2 id="结构">结构</h2>
<ul>
<li>HashBang</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure>
<ul>
<li>命令</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="执行脚本">执行脚本</h2>
<ul>
<li>标准方式</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x script.sh</span><br><span class="line">./script.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>非标准方式</li>
</ul>
<ol type="1">
<li>直接指定解释器执行</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash script.sh</span><br><span class="line"><span class="comment"># -x 显示脚本的执行过程, 用于debug</span></span><br><span class="line"><span class="comment"># -n 检查语法是否有问题</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用source命令执行</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> script.sh</span><br></pre></td></tr></table></figure>
<h2 id="变量">变量</h2>
<ul>
<li>变量名不能由数字开头</li>
<li>区分大小写</li>
</ul>
<h2 id="读取用户输入">读取用户输入</h2>
<p>语法：<code>read [选项] 变量名</code></p>
<ul>
<li><code>-p</code> 提示信息</li>
<li><code>-n</code> 输入长度</li>
<li><code>-s</code> 不回显</li>
<li><code>-t</code> 超时时间, 单位s</li>
</ul>
<h2 id="内置变量">内置变量</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$$      当前进程号</span><br><span class="line">$?      上一条命令的返回值</span><br><span class="line"><span class="variable">$_</span>      上一条命令的最后一个参数</span><br><span class="line"><span class="variable">$0</span>      当前执行的程序（脚本文件）名</span><br><span class="line"><span class="variable">$&#123;x&#125;</span>    第x个参数</span><br><span class="line">$*      所有参数</span><br><span class="line"><span class="variable">$@</span>      所有参数</span><br><span class="line"><span class="variable">$#</span>      执行时所带的参数个数</span><br><span class="line">$!      后台运行的最后一个进程的进程号</span><br></pre></td></tr></table></figure>
<h2 id="简单四则运算">简单四则运算</h2>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>$(( ))</code></td>
<td><code>echo $((1+1))</code></td>
</tr>
<tr class="even">
<td><code>$[ ]</code></td>
<td><code>echo $[10-5]</code></td>
</tr>
<tr class="odd">
<td><code>expr</code></td>
<td><code>expr 10 / 5</code></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>backend</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2021/02/09/commands/</url>
    <content><![CDATA[<h1 id="杂项">杂项</h1>
<h2 id="清屏">清屏</h2>
<p>按下Ctrl+l</p>
<h2 id="快速清空文件内容">快速清空文件内容</h2>
<p>利用文件写入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; filename</span><br></pre></td></tr></table></figure>
<h1 id="实用程序">实用程序</h1>
<h2 id="cat">cat</h2>
<p>显示文件内容, 如果输入是多个文件也可以用于文件拼接</p>
<ul>
<li><code>-n</code> 显示行号</li>
</ul>
<h2 id="grep">grep</h2>
<p>行过滤</p>
<ul>
<li><code>-n</code> 显示行号</li>
<li><code>-i</code> 忽略大小写</li>
<li><code>-c</code> 统计结果行数</li>
<li><code>-A</code> 显示匹配处后多少行</li>
<li><code>-B</code> 显示匹配处前多少行</li>
<li><code>-C</code> 显示匹配处前后多少行</li>
<li><code>--color=auto</code> 彩色显示</li>
<li><code>^</code> 行开头</li>
<li><code>$</code> 行末尾</li>
</ul>
<h2 id="cut">cut</h2>
<p>列截取</p>
<ul>
<li><code>-d</code> 分隔符</li>
<li><code>-f</code> 分割后取出哪些列</li>
</ul>
<h2 id="sort">sort</h2>
<p>对标准输入进行排序, 默认是升序排列</p>
<ul>
<li><code>-r</code> 逆序排列, 即按降序排列</li>
<li></li>
</ul>
<h2 id="uniq">uniq</h2>
<p>连续行去重, 即对标准输入中连续重复的行只保留一个</p>
<h2 id="tee">tee</h2>
<p>把标准输入写入到标准输出和一个文件中, 即: 双向<strong>覆盖</strong>重定向(屏幕+文件输出)</p>
<ul>
<li><code>-a</code> 双向<strong>追加</strong>重定向</li>
</ul>
<h2 id="diff">diff</h2>
<p>描述怎样改变第一个文件使之与第二个文件匹配</p>
<h2 id="patch">patch</h2>
<p>基于diff的结果修改一个文件</p>
<h2 id="paste">paste</h2>
<p>将两个文件逐行拼接, 与cut相反</p>
<ul>
<li><code>-d</code> 指定分割符, 默认是tab</li>
<li><code>-s</code> 将结果转置</li>
</ul>
<h2 id="tr">tr</h2>
<p>字符转换, 替换和删除. 主要用于删除文件中的控制字符, 或者进行字符转换</p>
<p>格式:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> set1 set2 &lt; stdin</span><br></pre></td></tr></table></figure>
<p>把字符集1中的字符替换成字符集2中的字符</p>
<p>例:</p>
<ul>
<li>小写转大写 <code>tr a-z A-Z &lt; package.json</code></li>
</ul>
]]></content>
      <categories>
        <category>backend</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论与数理统计</title>
    <url>/2023/10/27/index/</url>
    <content><![CDATA[<h2 id="随机变量">随机变量</h2>
<p>概率分布函数, 概率密度函数: <span class="math display">\[
F(x) = P(X\leq x),x\in R, \\
F(x) = \int_{-\infty}^{x}f(x)dx
\]</span></p>
<p>数学期望, 简称期望, 又称为均值, 常用<span class="math inline">\(\mu\)</span>表示 <span class="math display">\[
E(x) = \mu_x = \int_{-\infty}^{\infty}xf(x)dx
\]</span></p>
<p>方差, 标准差: <span class="math display">\[
D(X) = Var(X) = E((X-\mu_x)^2) = E(X^2) - \mu_x^2, \\
\sqrt{D(X)} = \sigma_X = \sqrt{E((X-\mu_x)^2)}
\]</span></p>
<p>协方差: 用于衡量随机变量 X 与 Y 的相关性: <span class="math display">\[
Cov(X, Y) = E[(X-\mu_X)(Y-\mu_Y)]
\]</span></p>
<p>相关系数: 剔除了两个变量量纲影响、标准化后的协方差: <span class="math display">\[
\rho = \frac{Cov(X,Y)}{\sigma_X \sigma_Y}
\]</span></p>
<h2 id="多维随机变量">多维随机变量</h2>
<p>联合概率分布, 联合概率密度: <span class="math display">\[
F(x,y) = P(X\leq x, Y\leq y) = \int_{-\infty}^{y}\int_{-\infty}^{x}f(u,v)dudv
\]</span></p>
<p>边缘分布函数, 边缘概率密度: <span class="math display">\[
F_X(x) = F(x, +\infty), \\
F_Y(y) = F(+\infty, y), \\
f_X(x) = \int_{-\infty}^{+\infty}f(x,y)dy, \\
f_Y(y) = \int_{-\infty}^{+\infty}f(x,y)dx
\]</span></p>
<p>条件概率密度, 在<span class="math inline">\(Y=y\)</span>的条件下: <span class="math display">\[
f_{X|Y}(x,y) = \frac{f(x,y)}{f_Y(y)}
\]</span></p>
<p><span class="math inline">\(Z=X+Y\)</span>的概率分布: <span class="math display">\[
F_Z(z) = P(Z\leq z) =\iint_{x+y\leq z}f(x,y)dxdy \\
= \int_{-\infty}^{+\infty}f(z-y,y)dy \\
= \int_{-\infty}^{+\infty}f(x,z-x)dx
\]</span></p>
<p>如果<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>独立, 卷积公式: <span class="math display">\[
= \int_{-\infty}^{+\infty}f_X(x)f_Y(z-x)dx
\]</span></p>
<h2 id="参数估计">参数估计</h2>
<p>样本: <span class="math inline">\(X_1, X_2, ..., X_n\)</span>, <span class="math inline">\(n\)</span>为样本大小/样本容量/样本量</p>
<p>统计量: 完全由样本决定的量</p>
<p>参数估计问题: 根据样本估计概率函数</p>
<ul>
<li>设有了从总体中抽出的独立随机样本<span class="math inline">\(X_1, ..., X_n\)</span>, 要依据这些样本去对参数 <span class="math inline">\(\theta_1, ..., \theta_k\)</span> 的未知值作出估计. 当然, 我们也可以只要求估计其中的一部分, 或估计它们的某个已知函数 <span class="math inline">\(g(\theta_1, ..., \theta_k)\)</span></li>
</ul>
<p>矩估计: pass</p>
<p>最大似然估计:</p>
<p>设总体有分布 $f(X, _1, ...,_k), <span class="math inline">\(X_1, ...,X_n\)</span> 为自这总体中抽出的样本, 则样本<span class="math inline">\((X_1, ...,X_n)\)</span>的分布(即其概率密度函数或概率函数)为 <span class="math display">\[
L(X_1, ..., X_n, \theta_1,..., \theta_k) =
    f(X_1, \theta_1, ..., \theta_k)
    f(X_2, \theta_1, ..., \theta_k)
    ...
    f(X_n, \theta_1, ..., \theta_k)
\]</span></p>
<p>似然函数: 将上式视为<span class="math inline">\(\theta\)</span>的函数, 称为似然函数</p>
<p>最大似然估计: 对于已知的样本, 估计最优的<span class="math inline">\(\theta\)</span>值，使得似然函数最大化，即为最大似然估计</p>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>Probability-and-Mathematical-Statistics</category>
      </categories>
  </entry>
  <entry>
    <title>目标代码生成</title>
    <url>/2020/12/17/codegen/</url>
    <content><![CDATA[<h1 id="目标代码生成">目标代码生成</h1>
<h2 id="任务">任务</h2>
<pre><code>中间代码 --&gt; 代码生成器 --&gt; 目标程序
                ^
                |
            符号表</code></pre>
<h2 id="目标代码的三种形式">目标代码的三种形式:</h2>
<ol type="1">
<li>能立即执行的机器码(所有地址已经定位)</li>
<li>待装配的机器语言模块(连接装入后即可执行)</li>
<li>汇编语言代码(经汇编程序汇编后即可执行)</li>
</ol>
<p>此处选择汇编语言</p>
<h2 id="目标机器模型">目标机器模型</h2>
<p>此处假设目标计算机: 1. 具有多个通用寄存器, 可以用来运算, 也可以用来取地址 2. 支持四种指令形式 1. 直接地址型 <code>OP R, M</code> - <code>R OP M =&gt; R</code> 2. 寄存器型 <code>OP Ri, Rj</code> - <code>Ri OP Rj =&gt; Ri</code> 3. 变址型 <code>OP Ri, c(Rj)</code> - <code>Ri OP (Rj+c) =&gt; Ri</code> 4. 间接型 1. <code>OP Ri, (M)</code> - <code>R OP (M) =&gt; R</code> 2. <code>OP Ri, (Rj)</code> - <code>Ri OP (Rj) =&gt; Ri</code> 3. <code>OP Ri, (c(Rj))</code> - <code>Ri OP ((Rj+c)) =&gt; Ri</code></p>
<p>OP可以是ADD,SUB,MUL,DIV等</p>
<h2 id="简单代码生成器">简单代码生成器</h2>
<p>思路: 代码生成器在生成每一条指令时, 必须要知道每个寄存器中存储的是什么, 以及每个变量存储到什么位置 方法: 1. 引入<strong>待用信息</strong> 2. 寄存器描述数组 3. 变量地址描述数组</p>
<h2 id="待用信息">待用信息</h2>
<p>待用信息 - 在基本块中, 四元式i对A定值, 四元式j对A取值, 且i,j之间无再对A定值, 则称j是i的变量A的待用信息</p>
<p>活跃信息 - 基本块中的一个名字在某个给定点之后仍被引用, 则称该名字在给定点是活跃的</p>
<p>修改符号表 - 记录待用信息和活跃信息 - 表示: (<code>待用信息[i/^]</code>,<code>活跃信息[y/^]</code>)</p>
<table>
<thead>
<tr class="header">
<th>变量名</th>
<th>待用/活跃信息栏</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>(..., ...)</td>
</tr>
<tr class="even">
<td>B</td>
<td>(..., ...)</td>
</tr>
<tr class="odd">
<td>...</td>
<td>(..., ...)</td>
</tr>
</tbody>
</table>
<p>计算待用和活跃信息 1. 开始时, 所有变量均为<code>非待用</code>, 根据基本块之后是否活跃填写<code>活跃</code>或<code>非活跃</code> 2. 逆序遍历每个四元式<code>i</code> 1. 把<code>A</code>的引用信息附加到四元式<code>i</code>左值上 2. <code>A</code>的引用信息附加<code>(^,^)</code> 3. 把<code>B</code>,<code>C</code>的引用信息附加到四元式<code>i</code>上 4. <code>B</code>,<code>C</code>的引用信息附加<code>(^,^)</code></p>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1:=B-C</span><br><span class="line">T2:=A*T1</span><br><span class="line">T3:=D+1</span><br><span class="line">T4:=E-F</span><br><span class="line">T5:=T3*T4</span><br><span class="line">W:=T2/T5</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>四元式</th>
<th>左值</th>
<th>左操作数</th>
<th>右操作数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(6)</td>
<td>W:=T2/T5</td>
<td>(^,y)</td>
<td>(<sup>,</sup>)</td>
<td>(<sup>,</sup>)</td>
</tr>
<tr class="even">
<td>(5)</td>
<td>T5:=T3*T4</td>
<td>(6,y)</td>
<td>(<sup>,</sup>)</td>
<td>(<sup>,</sup>)</td>
</tr>
<tr class="odd">
<td>(4)</td>
<td>T4:=E-F</td>
<td>(3,y)</td>
<td>(<sup>,</sup>)</td>
<td>(<sup>,</sup>)</td>
</tr>
<tr class="even">
<td>(3)</td>
<td>T3:=D+1</td>
<td>(3,y)</td>
<td>(<sup>,</sup>)</td>
<td>(<sup>,</sup>)</td>
</tr>
<tr class="odd">
<td>(2)</td>
<td>T2:=A*T1</td>
<td>(6,y)</td>
<td>(<sup>,</sup>)</td>
<td>(<sup>,</sup>)</td>
</tr>
<tr class="even">
<td>(1)</td>
<td>T1:=B-C</td>
<td>(2,y)</td>
<td>(<sup>,</sup>)</td>
<td>(<sup>,</sup>)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>变量名</th>
<th>待用/活跃信息栏</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T5</td>
<td>(<sup>,</sup>)-&gt;(6,y)-&gt;(<sup>,</sup>)</td>
</tr>
<tr class="even">
<td>T4</td>
<td>(<sup>,</sup>)-&gt;(3,y)-&gt;(<sup>,</sup>)</td>
</tr>
<tr class="odd">
<td>T3</td>
<td>(<sup>,</sup>)-&gt;(3,y)-&gt;(<sup>,</sup>)</td>
</tr>
<tr class="even">
<td>T2</td>
<td>(<sup>,</sup>)-&gt;(6,y)-&gt;(<sup>,</sup>)</td>
</tr>
<tr class="odd">
<td>T1</td>
<td>(<sup>,</sup>)-&gt;(2,y)-&gt;(<sup>,</sup>)</td>
</tr>
<tr class="even">
<td>W</td>
<td>(<sup>,y)-&gt;(</sup>,^)</td>
</tr>
<tr class="odd">
<td>F</td>
<td>(<sup>,</sup>)-&gt;(4,y)</td>
</tr>
<tr class="even">
<td>E</td>
<td>(<sup>,</sup>)-&gt;(4,y)</td>
</tr>
<tr class="odd">
<td>D</td>
<td>(<sup>,</sup>)-&gt;(3,y)</td>
</tr>
<tr class="even">
<td>C</td>
<td>(<sup>,</sup>)-&gt;(1,y)</td>
</tr>
<tr class="odd">
<td>B</td>
<td>(<sup>,</sup>)-&gt;(1,y)</td>
</tr>
<tr class="even">
<td>A</td>
<td>(<sup>,</sup>)-&gt;(2,y)</td>
</tr>
</tbody>
</table>
<h2 id="寄存器分配算法">寄存器分配算法</h2>
<p>寄存器描述和地址描述 - 寄存器描述数组<code>RVALUE</code> - 记录寄存器内存储的变量, 可以是多个 - <code>RVALUE[R1]=&#123;A,B&#125;</code> - 变量地址描述数组<code>AVALUE</code> - 记录变量存储的位置(寄存器/内存) - <code>AVALUE[A]=&#123;R1,R2,A&#125;</code></p>
<p>代码生成算法 - 对于四元式<code>A:=B op C</code>, 依次执行 1. 调用<code>GETREG(i: A:=B op C)</code>获取一个寄存器<code>R</code> 2. 查询<code>AVALUE[B]</code>和<code>AVALUE[C]</code>, 如果在寄存器中, 假设是<code>B'</code>和<code>C'</code> 3. 如果<code>B'≠R</code>, 先把<code>B</code>加载到<code>R</code>中, 生成代码: <code>LD R,B'</code> 4. 进行运算, 生成代码: <code>op R,C'</code> 5. 更新描述信息 1. 如果<code>B'</code>或<code>C'</code>是<code>R</code>, 就要把<code>AVALUE</code>中的记录删除 2. 设置<code>AVALUE[A]=&#123;R&#125;, RVALUE[R]=&#123;A&#125;</code> 6. 如果<code>B</code>或<code>C</code>仍存储在某个寄存器中, 但后续不再被引用且不再活跃, 就从<code>AVALUE</code>和<code>RVALUE</code>中删除<code>B</code>和<code>C</code>的记录</p>
<p>寄存器分配原则 - 尽可能用B独占的寄存器 - 尽可能用空闲的寄存器 - 抢占用非空闲寄存器 - <code>Ri</code>的值也存储在内存中 - <code>Ri</code>最远才会用到</p>
<p>寄存器分配算法<code>GETREG(i: A:=B op C)</code> 1. 如果B独占某个寄存器 - 如果<code>AB</code>是同一个标识符(即修改B的指令<code>B:=B op C</code>) - 返回<code>B</code>所在的寄存器 - 如果<code>B</code>在后面不会再引用(非待用, 非活跃) - 返回<code>B</code>所在的寄存器 2. 如果有空闲寄存器, 返回空闲寄存器 3. 抢占一个寄存器<code>Ri</code>, 1. 对于<code>Ri</code>中存储的每一个变量<code>M</code>, 如果存储的不是<code>A</code>, 或者存储的是<code>A == C != B</code>且<code>Ri</code>中不存储<code>B</code>.(<code>M==A &amp;&amp; M==C &amp;&amp; M!=B &amp;&amp; B not in RVALUE[Ri]</code>) 1. 如果<code>M</code>仅存储在<code>Ri</code>, 则要存到内存中: <code>ST Ri, M</code> 2. 如果<code>M == B</code>, 或者<code>M == C &amp;&amp; B in RVALUE[Ri]</code>中, 则令<code>AVALUE[M]=&#123;M,R&#125;</code>, 否则令<code>AVALUE[M]=&#123;M&#125;</code> 3. 删除<code>M</code>在<code>Ri</code>中的记录, <code>RVALUE[Ri].reLD e(M)</code> 4. 返回<code>R</code></p>
<p>例:</p>
<p>寄存器: R0, R1,</p>
<p>基本块出口活跃变量: W</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1:=B-C</span><br><span class="line">T2:=A*T1</span><br><span class="line">T3:=D+1</span><br><span class="line">T4:=E-F</span><br><span class="line">T5:=T3*T4</span><br><span class="line">W:=T2/T5</span><br></pre></td></tr></table></figure>
<p>答案:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">【解答】该基本块的目标代码如下(指令后面为相应的注释)：</span><br><span class="line">LD  R0, B  <span class="comment">/* 取第一个空闲寄存器 R0 */</span> </span><br><span class="line">SUB R0, C  <span class="comment">/* 运算结束后R0中为T1结果，内存中无该结果 */</span> </span><br><span class="line">LD  R1, A  <span class="comment">/* 取一个空闲寄存器R1 */</span> </span><br><span class="line">MUL R1, R0 <span class="comment">/* 运算结束后R1中为T2结果，内存中无该结果 */</span> </span><br><span class="line">LD  R0,D  <span class="comment">/* 此时R0中结果T1已经没有引用点，且临时单元T1是非活跃的，所以，寄存器R0可作为空闲寄存器使用 */</span> </span><br><span class="line">ADD R0, <span class="number">1</span> <span class="comment">/* 运算结束后R0中为T3结果，内存中无该结果 */</span> </span><br><span class="line">ST  R1, T2  <span class="comment">/*翻译四元式T4=E-F时，所有寄存器已经分配完毕，寄存器R0中存的T3和寄存器R1中存的T2都是有用的。由于T2的下一个引用点较T3的下一个引用点更远，所以暂时可将寄存器R1中的结果存回到内存的变量T2中，从而将寄存器R1空闲以备使用*/</span> </span><br><span class="line">LD  R1, E     </span><br><span class="line">SUB R1, F  <span class="comment">/*运算结束后R1中为T4结果，内存中无该结果*/</span>  </span><br><span class="line">MUL R0, R1 <span class="comment">/*运算结束后R0中为T5结果，内存中无该结果。注意，该指令将寄存器R0中原来的结果T3冲掉了。可以这么做的原因是，T3在该指令后不再有引用点，且是非活跃变量*/</span> </span><br><span class="line">LD  R1, T2 <span class="comment">/*此时R1中结果T4已经没有引用点，且临时单元T4是非活跃的，因此寄存器R1可作为空闲寄存器使用*/</span> </span><br><span class="line">DIV R1, R0  </span><br><span class="line"><span class="comment">/*运算结束后R1中为W结果，内存中无该结果。此时所有指令部分已经翻译完毕*/</span> </span><br><span class="line">ST  R1, W </span><br><span class="line"><span class="comment">/*指令翻译完毕时，寄存器中存有最新的计算结果，必须将它们存回到内存相应的单元中去，否则，在翻译下一个基本块时，所有的寄存器被当成空闲的寄存器使用，从而造成计算结果的丢失。考虑到寄存器R0中的T5和寄存器R1中的W，临时单元T5是非活跃的，因此只要将结果W存回对应单元即可*/</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>compiler-principle</category>
      </categories>
  </entry>
  <entry>
    <title>编译原理笔记</title>
    <url>/2020/12/03/index/</url>
    <content><![CDATA[<h2 id="课程简介">课程简介</h2>
<p>总评 = 考试 * 60% + 作业 * 30% + 平时 * 10%</p>
<h2 id="程序语言的发展">程序语言的发展</h2>
<p>机器语言 -&gt; 汇编语言 -&gt; 高级语言</p>
<h2 id="程序的两种执行方式">程序的两种执行方式</h2>
<ul>
<li><p>解释方式</p></li>
<li><p>编译方式</p></li>
</ul>
<p>Java认为是解释型语言</p>
<h2 id="编译的步骤">编译的步骤</h2>
<p>编译过程基本分为五个基本阶段: 1. 词法分析 2. 语法分析 3. 语义分析和中间代码生成 4. 优化 5. 目标代码生成</p>
<h3 id="词法分析">1. 词法分析</h3>
<ul>
<li>词法分析程序又称扫描程序(Scanner)。
<ul>
<li>任务：读源程序的字符流、识别单词（也称单词符号，或简称符号），如标识符、关键字、常量、界限符等，并转换成内部形式。</li>
<li>输入：源程序中的字符流</li>
<li>输出：等长的内部形式，即属性字（单词类型Token-name, 单词属性Attribute-value），其中单词属性指向符号表</li>
</ul></li>
</ul>
<p>输入: 字符流 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cppcode = <span class="string">`</span></span><br><span class="line"><span class="string">int a, b;</span></span><br><span class="line"><span class="string">a = a + 2;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure> 输出: Token流和对应的符号表 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tokenList = [</span><br><span class="line">    &lt;int&gt;</span><br><span class="line">    &lt;id,<span class="number">1</span>&gt;</span><br><span class="line">    &lt;,&gt;</span><br><span class="line">    &lt;id,<span class="number">2</span>&gt;</span><br><span class="line">    &lt;;&gt;</span><br><span class="line">    &lt;id,<span class="number">1</span>&gt;</span><br><span class="line">    &lt;op,<span class="variable constant_">EQ</span>&gt;</span><br><span class="line">    &lt;id,<span class="number">1</span>&gt;</span><br><span class="line">    &lt;+&gt;</span><br><span class="line">    &lt;<span class="number">2</span>&gt;</span><br><span class="line">    &lt;;&gt;</span><br><span class="line">]</span><br><span class="line">tokenTable = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>, ...&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>, ...&#125; </span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在词法分析阶段工作所依循的是语言的词法规则。</li>
<li>描述词法规则的有效工具是<strong>正规式</strong>和<strong>有限自动机</strong>。</li>
<li>方法：<strong>状态图</strong>；<strong>DFA</strong>；<strong>NFA</strong></li>
</ul>
<p>DFA模拟代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s = s0;</span><br><span class="line">c = <span class="built_in">nextChar</span>() ;</span><br><span class="line"><span class="keyword">while</span> ( c != eof ) &#123;</span><br><span class="line">    s = <span class="built_in">move</span>(s, c);</span><br><span class="line">    c = <span class="built_in">nextChar</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( s is in F ) <span class="keyword">return</span> <span class="string">&quot; yes &quot;</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;no &quot;</span> ;</span><br></pre></td></tr></table></figure></p>
<h3 id="语法分析">2. 语法分析</h3>
<ul>
<li>语法分析程序又称识别程序(Parser)。
<ul>
<li>任务：读入由词法分析程序识别出的符号，根据给定语法规则，识别出各个语法单位（如：短语、子句、语句、程序段、程序）,并生成另一种内部表示。</li>
<li>输入：由词法分析程序识别出并转换的符号</li>
<li>输出：另一种内部表示，如<strong>语法分析树</strong>或其它<strong>中间表示</strong>。</li>
</ul></li>
<li>语法规则通常用<strong>上下文无关文法</strong>描述。</li>
<li>方法：递归子程序法、<strong>LR分析法</strong>、<strong>算符优先分析法</strong>。</li>
</ul>
<p>输入: 符号流 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sum := first + count * <span class="number">10</span></span><br></pre></td></tr></table></figure> 输出: 语法树 <img src="/2020/12/03/index/ast_demo.png" class=""></p>
<h3 id="语义分析">3.1 语义分析</h3>
<h3 id="中间代码生成">3.2 中间代码生成</h3>
<h3 id="优化">4. 优化</h3>
<ul>
<li>优化的任务在于对前段产生的中间代码进行加工，把它变换成功能相同，但功效更高的优化了的中间表示代码，以期在最后阶段产生更为高效（省时间和空间）的代码</li>
<li>优化所依循的原则是程序的等价变换规则</li>
<li>其方法有：公共子表达式的提取、循环优化、删除无用代码等等。</li>
</ul>
<h3 id="目标代码生成">5. 目标代码生成</h3>
<h3 id="遍pass">遍(Pass)</h3>
<p>对<strong>源程序</strong>或源程序的<strong>中间结果</strong>从头到尾扫描一次，并做相关处理，生成新的中间结果或目标程序的过程。</p>
<p>“遍”是处理数据的一个完整周期，每遍工作从外存上获得前一遍的中间结果（如源程序），完成它所含的有关工作之后，再把结果记录于外存。</p>
<p>一个编译程序可由一遍、两遍或多遍完成。每一遍可完成不同的阶段或多个阶段的工作。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>从时间和空间角度看</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>多遍编译</td>
<td><strong>少占内存，多耗时间</strong></td>
</tr>
<tr class="even">
<td>一遍编译</td>
<td><strong>多占内存，少耗时间</strong></td>
</tr>
</tbody>
</table>
<h3 id="t形图">T形图</h3>
<img src="/2020/12/03/index/t_diagram.png" class="">
<ul>
<li>S:源语言(程序)，Source language(program)</li>
<li>T:目标语言(程序), target/object language(program)</li>
<li>I:实现语言, implementation language</li>
</ul>
<p>用T形图表示编译器移植</p>
<img src="/2020/12/03/index/t_diagram2.png" class="">
<h3 id="特殊">特殊</h3>
<p>自编译:</p>
<p>交叉编译</p>
<p>自动编译: lex, yacc</p>
<h2 id="复习">复习</h2>
<p>乔姆斯基文法: 0/1/2/3</p>
<p>词法分析: 3型 语法分析: 2型</p>
<p>A卷 - 简单 缓考不考-&gt;B卷-&gt;难</p>
<p>语法分析: LR,SLR,二义文法</p>
<p>就5道大题 5个部分 占40% 平时 60%</p>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>compiler-principle</category>
      </categories>
  </entry>
  <entry>
    <title>语义分析和中间代码生成</title>
    <url>/2020/12/17/ir/</url>
    <content><![CDATA[<h1 id="提纲">提纲</h1>
<img src="/2020/12/17/ir/index1.png" class="">
<img src="/2020/12/17/ir/index2.png" class="">
<h1 id="属性文法和语法制导翻译">属性文法和语法制导翻译</h1>
<h2 id="属性文法">属性文法</h2>
<p>属性文法: 在上下文无关文法的基础上给每个文法符号增加若干属性</p>
<p>语义规则: 对于文法的每个产生式配备了<strong>一组</strong>属性的计算规则 - <span class="math inline">\(b:=f(c_1,c_2,...,c_k)\)</span> - 产生式左边的综合属性和右边的继承属性必须提供语义规则 - 语义规则所描述的工作可以包括属性计算、符号表操作、静态语义检查、代码生成等等。</p>
<p>属性加工的过程即是语义处理的过程</p>
<p>属性 - 综合属性: 在语法树中, 通过子节点的属性计算出来的属性(自下而上) - 继承属性: 在语法树中, 通过父节点和兄弟节点的属性计算出来的属性(自上而下) - 终结符只有综合属性, 有lexer提供</p>
<h3 id="s-属性文法">S-属性文法</h3>
<p>只包含综合属性的文法</p>
<h3 id="l-属性文法">L-属性文法</h3>
<p>如果每个产生式A→X1…Xj-1Xj…Xn的每条语义规则计算的属性或者是A的综合属性；或者是Xj的继承属性，但它仅依赖： - 该产生式中Xj左边符号X1, X2, …, Xj-1的属性； - A的继承属性</p>
<h2 id="语法制导翻译">语法制导翻译</h2>
<p>语法制导翻译法: - 基于属性文法的处理过程: <code>输入串-&gt;语法树-&gt;依赖图-&gt;语义规则计算次序</code> - 由源程序的语法结构所驱动</p>
<p>作用 - <strong>产生中间代码</strong> - 产生目标指令 - 对输入串进行解释执行</p>
<h3 id="依赖图">依赖图</h3>
<p>用DAG表示属性依赖关系 - 每个属性一个结点 - 语义规则中左边属性依赖右边每一个属性</p>
<img src="/2020/12/17/ir/dep_tree.png" class="">
<ol type="1">
<li>树遍历法
<ul>
<li>无环图</li>
<li>DFS</li>
<li>从左到右</li>
</ul></li>
<li>一遍扫描法
<ul>
<li>在语法分析的同时计算属性值</li>
<li>S-属性文法适合于一遍扫描的自下而上分析</li>
<li>L-属性文法适合于一遍扫描的自上而下分析</li>
</ul></li>
</ol>
<h1 id="语义分析和中间代码生成">语义分析和中间代码生成</h1>
<h2 id="语义分析">语义分析</h2>
<h2 id="中间语言">中间语言</h2>
<p>中间语言是复杂性界于源语言和目标语言之间的语言</p>
<p>好处: * 便于进行与机器无关的代码优化工作 * 易于移植 * 使编译程序的结构在逻辑上更为简单明确</p>
<p>常用的中间语言表示法 * 后缀式(逆波兰式) * 图表示 * DAG * AST * 三地址代码 * 三元式 * 四元式 * 间接三元式</p>
<p>后缀式: - 二元操作符后置 - (一元操作符后置) - 去括号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a+b*(c+d/e)</span><br><span class="line">a b*(c+d/e) +</span><br><span class="line">a b (c+d/e) * +</span><br><span class="line">a b c d/e + * +</span><br><span class="line">a b c d e / + * +</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b:=-c*a+-c*a</span><br><span class="line">b -c*a+-c*a :=</span><br><span class="line">b -c*a -c*a + :=</span><br><span class="line">b -c a * -c a * + :=</span><br><span class="line">b c Neg a * c Neg a * + :=</span><br></pre></td></tr></table></figure>
<p>抽象语法树: 去掉对翻译不必要的信息, 更有效表示源程序的语法树</p>
<img src="/2020/12/17/ir/ast.png" class="">
<p>DAG - 一个内部结点代表一个操作符，它的孩子代表操作数 - 一个DAG中代表<strong>公共子表达式</strong>的结点具有多个父结点</p>
<img src="/2020/12/17/ir/dag.png" class="">
<p>三地址代码: <code>x:=y op z</code> - 三地址代码可以看成是抽象语法树或DAG的一种线性表示 - 种类 - <code>x:=y op z</code> - <code>x:=op y</code> - <code>x:=y</code> - <code>goto L</code> - <code>if x rop y goto L</code> - <code>if a goto L</code> - 计算机表示 - 四元式</p>
<pre><code>|     | Op     | arg1 | arg2 | result |
| --- | ------ | ---- | ---- | ------ |
| (0) | uminus | c    |      | T1     |
| (1) | *      | b    | T1   | T2     |
| ... | ...    | ...  | ...  | ...    |</code></pre>
<ul>
<li><p>三元式</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Op</th>
<th>arg1</th>
<th>arg2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0)</td>
<td>uminus</td>
<td>c</td>
<td></td>
</tr>
<tr class="even">
<td>(1)</td>
<td>*</td>
<td>b</td>
<td>(0)</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td>(4)</td>
<td>+</td>
<td>(1)</td>
<td>(3)</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table></li>
<li><p>间接三元式</p>
<ul>
<li>使用间接代码表来压缩存储相同的三元式</li>
<li>好处:
<ul>
<li>调整语句顺序不需要改动三元式表</li>
<li>节省存储空间</li>
</ul></li>
</ul></li>
</ul>
<h2 id="说明语句的翻译">说明语句的翻译</h2>
<h2 id="赋值语句的翻译">赋值语句的翻译</h2>
<img src="/2020/12/17/ir/assign_example.png" class="">
<p>答案:</p>
<img src="/2020/12/17/ir/assign_example_solution.png" class="">
<p>三地址代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1:=uminus C</span><br><span class="line">T2:=T1+D</span><br><span class="line">T3:=B*T2</span><br><span class="line">A:=T3</span><br></pre></td></tr></table></figure></p>
<h2 id="布尔表达式的翻译">布尔表达式的翻译</h2>
<p>基本作用: - 逻辑运算 - 控制语句条件</p>
<p>翻译方法 - 算数方式 - 短路计算</p>
<h3 id="逻辑运算中的布尔表达式翻译">逻辑运算中的布尔表达式翻译</h3>
<img src="/2020/12/17/ir/bool_example.png" class="">
<p>答案:</p>
<p>三地址代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: if a&gt;b goto 3</span><br><span class="line">1: T1:=0</span><br><span class="line">2: goto 4</span><br><span class="line">3: T1:=1</span><br><span class="line">4: if a&gt;b goto 7</span><br><span class="line">5: T1:=0</span><br><span class="line">6: goto 8</span><br><span class="line">7: T1:=1</span><br><span class="line">8: T3=T1 and T2</span><br></pre></td></tr></table></figure></p>
<h3 id="条件控制语句中的布尔表达式翻译">条件控制语句中的布尔表达式翻译</h3>
<p>两种出口: 一真一假</p>
<p>改写产生式 - <code>E -&gt; E and M E</code> - <code>E -&gt; E or M E</code> - <code>M -&gt; epsilon</code></p>
<p>增加属性 - <code>truelist</code>/<code>falselist</code>: 布尔表达式中需要回填地址的四元式构成的(反向)列表, 从最后的需要回填地址四元式指向更靠前的四元式 - <code>nextquad</code>: 下一条即将产生的四元式的地址, 如果是emit过程中包含那么就是该条语句的地址</p>
<p>增加过程 - <code>makelist(i)</code>: 创建一个新链表<code>-&gt;i</code> - <code>merge(p1,p2)</code>: 合并两个链表 - <code>backpatch(p,t)</code>: 回填地址</p>
<img src="/2020/12/17/ir/bool1.png" class="">
<img src="/2020/12/17/ir/bool2.png" class="">
<p>例: 写出布尔式A or (B and not (C or D))的四元式序列</p>
<p>答案:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: jnz,A,-,0</span><br><span class="line">1: j,-,-,2</span><br><span class="line">2: jnz,B,-,4</span><br><span class="line">3: j,-,-,0</span><br><span class="line">4: jnz,C,-,0</span><br><span class="line">5: j,-,-,6</span><br><span class="line">6: jnz,D,-,0</span><br><span class="line">7: j,-,-,0</span><br></pre></td></tr></table></figure>
<h2 id="控制语句的翻译">控制语句的翻译</h2>
<h3 id="条件语句">条件语句</h3>
<p>改写产生式 - <code>S -&gt; if E then M S</code> - <code>S -&gt; if E then M S N else M S</code> - <code>M -&gt; epsilon</code> - <code>N -&gt; epsilon</code></p>
<p>增加属性: - <code>nextlist</code>: 下一条执行语句的地址, 引入此变量是为了优化连续多次跳转</p>
<img src="/2020/12/17/ir/control.png" class="">
<h3 id="循环语句while">循环语句(while)</h3>
<img src="/2020/12/17/ir/while.png" class="">
<h3 id="语句列表和语句块">语句列表和语句块</h3>
<p>改写产生式 - <code>L -&gt; L; M S</code> - <code>M -&gt; epsilon</code></p>
<img src="/2020/12/17/ir/list.png" class="">
<img src="/2020/12/17/ir/block.png" class="">
<h3 id="标号与goto语句的翻译">标号与goto语句的翻译</h3>
<h3 id="case语句的翻译">case语句的翻译</h3>
<h2 id="过程调用的翻译">过程调用的翻译</h2>
<p>不考, 略</p>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>compiler-principle</category>
      </categories>
  </entry>
  <entry>
    <title>词法分析</title>
    <url>/2020/12/17/lex/</url>
    <content><![CDATA[<h2 id="提纲">提纲</h2>
<img src="/2020/12/17/lex/index.png" class="">
<h2 id="概述">概述</h2>
<ul>
<li>单词级别分析和翻译源程序</li>
<li>任务: 作为<strong>字符串</strong>的源程序-&gt;<strong>单词符号串</strong></li>
</ul>
<h2 id="词法分析器的要求">词法分析器的要求</h2>
<p>单词符号表示通常使用二元式 (单词种别, 单词符号的属性值)</p>
<ul>
<li>单词种别: 语法分析需要的信息, 通常使用整数编码</li>
<li>单词(符号属性)值: 编译其他阶段使用</li>
</ul>
<p>单词如何分类取决于处理上的方便:</p>
<ul>
<li>标识符: 一般通归为一种</li>
<li>常数: 按类型分种</li>
<li>关键字: 可全体为一种, 也可一字一种(更方便)</li>
<li>运算符: 一般一符一种, 可以把具有一定共性的视为一类</li>
<li>界符: 一般一符一种</li>
</ul>
<p>单词符号的属性:</p>
<ul>
<li>标识符: 存放它<strong>符号表</strong>项的指针/内部字符串</li>
<li>常数: 存放它<strong>常数表</strong>项的指针/二进制形式</li>
<li>关键字/运算符/界符: 不需要属性</li>
</ul>
<img src="/2020/12/17/lex/lex.png" class="">
<p>实现方式: - 完全独立: lex作为单独一遍 - 结构简洁, 清晰, 条理化 - 相对独立: 作为parser的一个独立子程序, 需要新符号时调用 - 避免中间文件, 提高效率</p>
<h2 id="词法分析器设计">词法分析器设计</h2>
<h3 id="lexer的结构">lexer的结构</h3>
<p>源程序 -&gt; 输入缓冲区/预处理子程序/扫描缓冲区/扫描器 -&gt; 单词符号</p>
<p>预处理子程序: 处理空白符等编辑性字符, 删除注释等</p>
<p>输入缓冲区: 存放源程序文本输入串的缓冲区</p>
<p>扫描缓冲区: 设定两个指示器</p>
<h3 id="单词符号的识别-超前搜索">单词符号的识别: 超前搜索</h3>
<ul>
<li>关键字识别</li>
<li>标识符识别: 一般是字母开头的字母数字串, 一般都跟着算符或者界符, 不难识别</li>
<li>常数的识别: 有些语言需要使用超前搜索</li>
<li>算符和界符: 对于c++中的++,--等需要超前搜索</li>
</ul>
<h3 id="词法规则的表示">词法规则的表示</h3>
<p>大多数pl中的单词符号的<strong>词法规则</strong>可以用<strong>正规文法</strong>描述</p>
<p>例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;标识符&gt; -&gt; 字母|&lt;标识符&gt;字母|&lt;标识符&gt;数字</span><br><span class="line">&lt;整数&gt; -&gt; 数字|&lt;整数&gt;数字</span><br><span class="line">&lt;运算符&gt; -&gt; +|-|×|÷…</span><br><span class="line">&lt;界符&gt; -&gt; ;|,|(|)|…</span><br></pre></td></tr></table></figure>
<p>利用这些规则识别的过程可以用<strong>状态转换图</strong>来表示, 而状态转换图可以方便地用程序实现</p>
<h3 id="tg">TG</h3>
<p>状态转换图TG: 一个有限有向图, 可用于接受(识别)一定的符号串</p>
<ul>
<li>结点表示状态, 用圆圈表示
<ul>
<li>初态: 通常只有一个, 用一条输入弧表示</li>
<li>终态: <strong>至少有一个</strong>, 用双圈表示</li>
</ul></li>
<li>方向弧表示状态转换, 弧上的标记表示接受的输入字符或字符类</li>
</ul>
<p>路: 在状态转换图中从初态到某一个终态的弧上的标记序列</p>
<p>接受(识别): 若存在一条路产生<span class="math inline">\(\beta\)</span>, 则称状态转换图接受符号串<span class="math inline">\(\beta\)</span></p>
<p>状态转换图能识别的语言: L(TG)能别TG接受的符号串的集合</p>
<img src="/2020/12/17/lex/tg.png" class="">
<h2 id="正规表达式和有限自动机">正规表达式和有限自动机</h2>
<h3 id="正规式">正规式</h3>
<p>字母表<span class="math inline">\(\Sigma\)</span>上的正规式和正规集递归定义如下： 1. <span class="math inline">\(\varepsilon\)</span>和<span class="math inline">\(\varphi\)</span>都是<span class="math inline">\(\Sigma\)</span>上的正规式, 它们所表示的正规集分别为<span class="math inline">\(\{\varepsilon\}\)</span>和<span class="math inline">\(\varphi\)</span>。其中：<span class="math inline">\(\varepsilon\)</span>为空字符串, <span class="math inline">\(\varphi\)</span>为空集 2. 任意元素<span class="math inline">\(a\in\Sigma\)</span>, a是<span class="math inline">\(\Sigma\)</span>上的一个正规式, 它所表示的正规集是<span class="math inline">\(\{a\}\)</span>; 3. 假定U和V都是<span class="math inline">\(\Sigma\)</span>上的正规式, 它们所表示的正规集记为L(U)和L(V), 那么(U|V), (U·V)和(U)*都是正规式, 他们所表示的正规集分别记为L(U)∪L(V), L(U)L(V)和(L(U))*。 4. 仅由有限次使用上述三步而得到的表达式才是<span class="math inline">\(\Sigma\)</span>上的正规式, 它们所表示的字集才是<span class="math inline">\(\Sigma\)</span>上的正规集。</p>
<p>运算: - 闭包<code>*</code> - 连接<code>.</code> (可省略) - 或<code>|</code></p>
<p>运算律: - 或交换律 - 或结合律 - 连接结合律 - 或对连接分配律 - <span class="math inline">\(\varepsilon U=U \varepsilon=U\)</span></p>
<p>例: - 以01结尾的二进制数串的正规式: <code>(0|1)*01</code> - 能被5整除的十进制整数: <code>0|5|(1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*(0|5)</code></p>
<h3 id="fa">FA</h3>
<p>自动机: 具有离散输入输出的数学模型</p>
<pre><code>状态 + 输入 + 规则 -&gt; 状态迁移</code></pre>
<p>有限自动机(FA)</p>
<p>有限状态机(FSM)</p>
<h3 id="dfa">DFA</h3>
<p>DFA五元组: <span class="math inline">\(M=(S,\Sigma,\delta,S_0,F)\)</span> - <span class="math inline">\(S\)</span>: 有限的状态集合, 每个元素称为一个状态 - <span class="math inline">\(\Sigma\)</span>: 有限的输入字母表, 每个元素称为一个输入字符 - <span class="math inline">\(\delta: S\times\Sigma \rightarrow S\)</span>: 转换函数(状态转移集合) - <span class="math inline">\(\delta(s, a)=s&#39;\)</span> - <span class="math inline">\(S_0\in S\)</span>: 初始状态 - <span class="math inline">\(F\subseteq S\)</span>: 终止状态集</p>
<p>状态转换矩阵: DFA可以用一个矩阵表示, 每行表示一个状态, 每列表示一种输入, 矩阵元素表示<span class="math inline">\(\delta(s,a)\)</span>的值</p>
<p><strong>DFA与状态转换图: DFA可以用TG唯一表示</strong></p>
<img src="/2020/12/17/lex/dfa_tg.png" class="">
<p><strong>拓展转移函数</strong> - 接收一个字符串的状态转移函数 - <span class="math inline">\(\delta&#39;: S\times\Sigma^* \rightarrow S\)</span> - <span class="math inline">\(\delta&#39;(s, \varepsilon) = s\)</span> - <span class="math inline">\(\delta&#39;(s, \omega a) = \delta(\delta&#39;(s,\omega),a)\)</span></p>
<p>DFA接受的字符串</p>
<p>DFA接受的语言: <span class="math inline">\(L(M)=\{α|\delta&#39;(s,α)\in F\}\)</span></p>
<h3 id="nfa">NFA</h3>
<p>NFA五元组: <span class="math inline">\(M=(S,\Sigma,\delta,S_0,F)\)</span> - <span class="math inline">\(S\)</span>: 同DFA - <span class="math inline">\(\Sigma\)</span>: 同DFA - <span class="math inline">\(\delta: S\times\Sigma^* \rightarrow 2^S(幂集)\)</span>: 转换函数(状态转移集合) - <span class="math inline">\(\delta(s, a)=S&#39;\subseteq S\)</span> - <span class="math inline">\(S_0\subseteq S\)</span>: 非空初态集 - <span class="math inline">\(F\subseteq S\)</span>: 终止状态集</p>
<p><strong>NFA也可以用TG和转换矩阵表示</strong></p>
<p><strong>NFA的状态是一个集合</strong></p>
<table>
<thead>
<tr class="header">
<th>比较</th>
<th>DFA</th>
<th>NFA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输入字母</td>
<td>每个(状态,输入)都有一个<span class="math inline">\(\delta\)</span></td>
<td>可能没有<span class="math inline">\(\delta\)</span>/是空转换</td>
</tr>
<tr class="even">
<td>转移状态</td>
<td>确定的</td>
<td>不确定的, 可能有多个</td>
</tr>
</tbody>
</table>
<p>NFA的拓展转移函数 - <span class="math inline">\(\delta&#39;: S\times\Sigma^* \rightarrow 2^S\)</span> - <span class="math inline">\(\delta&#39;(s, \varepsilon) = \{s\}\)</span> - <span class="math inline">\(\delta&#39;(s,\omega a)=\{p|存在r\in\delta&#39;(s,\omega )\wedge p\in\delta(r,a)\}\)</span></p>
<p>NFA接受的字符串</p>
<p>NFA接受的语言</p>
<h3 id="dfa和nfa的关系-子集法">DFA和NFA的关系 (子集法)</h3>
<p>DFA是NFA的特例, 两者可以相互转化</p>
<p><strong>ε-闭包</strong>: <span class="math display">\[
\varepsilon\_CLOSURE(I)=I\cup\{q&#39;|q经任意条\varepsilon弧可到达q&#39;, q\in I\}, I\subseteq M&#39;
\]</span></p>
<p><strong>NFA-&gt;DFA之子集法</strong>:</p>
<ol type="1">
<li><p>引进新的初态结点X和终态结点Y, 从X到所有原始态结点连接一条<span class="math inline">\(\varepsilon\)</span>弧, 从所有原终态结点到Y连接一条<span class="math inline">\(\varepsilon\)</span>弧</p></li>
<li><p>对复合的弧进行<strong>分裂</strong></p>
<p><img src="/2020/12/17/lex/nfa_dfa.png" class=""></p></li>
<li><p>构造状态矩阵 | I | <span class="math inline">\(I_{\Sigma_i}\)</span> | ... | | --------------------------- | -------------- | --- | | <span class="math inline">\(\varepsilon\_CLOSURE({X})\)</span> | ... | ... | | ... | ... | ... |</p></li>
<li><p>合并相同状态, 重新命名得到新的状态转换矩阵</p>
<ul>
<li>第一行第一列的状态为始态</li>
<li>包含Y的状态为终态</li>
</ul></li>
<li><p>画出状态转换图</p></li>
</ol>
<p>例:</p>
<img src="/2020/12/17/lex/nfa_dfa_example_1.png" class="">
<img src="/2020/12/17/lex/nfa_dfa_example_2.png" class="">
<table>
<thead>
<tr class="header">
<th>I</th>
<th><span class="math inline">\(I_{a}\)</span></th>
<th><span class="math inline">\(I_{b}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>{X, 0, Y}</td>
<td>{1}</td>
<td>{1}</td>
</tr>
<tr class="even">
<td>{1}</td>
<td>{0,Y}</td>
<td>-</td>
</tr>
<tr class="odd">
<td>{0,Y}</td>
<td>{1}</td>
<td>{1}</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>I</th>
<th><span class="math inline">\(I_{a}\)</span></th>
<th><span class="math inline">\(I_{b}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>2</td>
<td>3</td>
<td>-</td>
</tr>
<tr class="odd">
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<img src="/2020/12/17/lex/nfa_dfa_example_3.png" class="">
<h3 id="正规式和fa的关系">正规式和FA的关系</h3>
<ul>
<li>正规式和FA是等价的</li>
</ul>
<h4 id="从nfa构造等价的正规式-简单">从NFA构造等价的正规式 (简单)</h4>
<ol type="1">
<li><p>引进新的初态结点X和终态结点Y, 从X到所有原始态结点连接一条<span class="math inline">\(\varepsilon\)</span>弧, 从所有原终态结点到Y连接一条<span class="math inline">\(\varepsilon\)</span>弧</p></li>
<li><p>对复合的弧进行<strong>合并</strong></p>
<p><img src="/2020/12/17/lex/nfa_regex.png" class=""></p></li>
<li><p>得到regex</p></li>
</ol>
<h4 id="从正规式构造等价的nfa-thompson算法"><strong>从正规式构造等价的NFA (Thompson算法)</strong></h4>
<img src="/2020/12/17/lex/regex_nfa_1.png" class="">
<img src="/2020/12/17/lex/regex_nfa_2.png" class="">
<p>例:</p>
<img src="/2020/12/17/lex/regex_nfa_example.png" class="">
<h3 id="dfa的化简-等价状态法"><strong>DFA的化简 (等价状态法)</strong></h3>
<p>将状态集<span class="math inline">\(S\)</span>根据能否被输入区分划分为更细的集合</p>
<ol type="1">
<li>初始划分: <span class="math inline">\(\Pi=\{终态集I^{(1)}, 非终态集I^{(2)}\}\)</span></li>
<li>检查能否再分
<ol type="1">
<li>如果对输入字符<span class="math inline">\(a\)</span>, 存在<span class="math inline">\(I^{(k)}\)</span>接受<span class="math inline">\(a\)</span>后不全落在现行<span class="math inline">\(\Pi\)</span>的某一个子集中</li>
<li>就把<span class="math inline">\(I^{(k)}\)</span>分成多个组, 使得每个组接受<span class="math inline">\(a\)</span>后都落在<span class="math inline">\(\Pi\)</span>的同一个子集中</li>
</ol></li>
<li>重复直到子集数不再增加</li>
</ol>
<img src="/2020/12/17/lex/dfa_simplify.png" class="">
<p>例题:</p>
<img src="/2020/12/17/lex/dfa_simplify_example.png" class="">
<p>初始划分<span class="math inline">\(\Pi_0=\{\left\{A,B,C,D\right\},\{E\}\}\)</span></p>
<p>考察<span class="math inline">\(\{A,B,C,D\}_a=\{B\}\subseteq \{A,B,C,D\}\)</span></p>
<p><span class="math inline">\(\{A,B,C,D\}_b=\{C,D,E\}\)</span>, 需要划分, 其中<span class="math inline">\(\{A,B,C\}_b=\{C,D\}\)</span>, <span class="math inline">\(\{D\}_b=\{E\}\)</span></p>
<p>将<span class="math inline">\(\{A,B,C,D\}\)</span>分成<span class="math inline">\(\{A,B,C\}\)</span>和<span class="math inline">\(\{D\}\)</span>, 得<span class="math inline">\(\Pi_1=\{\left\{A,B,C\right\},\{D\},\{E\}\}\)</span></p>
<p>考察<span class="math inline">\(\{A,B,C\}_b=\{C,D\}\)</span>, 需要划分, 其中<span class="math inline">\(\{A,C\}_b=\{C\}\)</span>, <span class="math inline">\(\{B\}_b=\{D\}\)</span></p>
<p>将<span class="math inline">\(\{A,B,C\}\)</span>分为<span class="math inline">\(\{A,C\}\)</span>和<span class="math inline">\(\{B\}\)</span>, 得<span class="math inline">\(\Pi_2=\{\left\{A,C\right\},\{B\},\{D\},\{E\}\}\)</span></p>
<h3 id="正规文法和fa的关系">正规文法和FA的关系</h3>
<p>FA和左(右)线性正规文法等价</p>
<p>将FA的状态和右线性正规文法的非终结符作为桥梁, 两者等价</p>
<h2 id="词法分析器的自动生成">词法分析器的自动生成</h2>
<p>略</p>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>compiler-principle</category>
      </categories>
  </entry>
  <entry>
    <title>语法分析</title>
    <url>/2020/12/17/parser/</url>
    <content><![CDATA[<h2 id="提纲">提纲</h2>
<img src="/2020/12/17/parser/index1.png" class="">
<img src="/2020/12/17/parser/index2.png" class="">
<h2 id="语法分析方法">语法分析方法</h2>
<ul>
<li>自上而下分析
<ul>
<li>LL(1)分析法</li>
<li>递归下降分析法</li>
<li>预测分析法</li>
</ul></li>
<li>自下而上分析
<ul>
<li>算符优先分析法</li>
<li>LR分析法
<ul>
<li>LR(0)</li>
<li>SLR</li>
<li>LR(1)</li>
<li>LALR</li>
</ul></li>
</ul></li>
</ul>
<h2 id="ll1">LL(1)</h2>
<h3 id="左递归消除">左递归消除</h3>
<p>一个文法含有下列形式的产生式时, 称为左递归文法, 不能采用自顶向下分析法 1. 直接递归</p>
<pre><code>$A\rightarrow A\beta, A\in V_N$, $\beta$$\in$V*</code></pre>
<ol start="2" type="1">
<li><p>间接递归</p>
<p><span class="math inline">\(A\rightarrow B\beta\)</span></p>
<p><span class="math inline">\(B\rightarrow A\alpha, A,B\in V_N, \alpha, \beta\in V^*\)</span></p></li>
</ol>
<p><strong>左递归消除</strong></p>
<p><span class="math inline">\(P\rightarrow P\alpha_1|P\alpha_2|...|P\alpha_m|\beta_1|\beta_2|...|\beta_n\)</span></p>
<p>改写为</p>
<p><span class="math inline">\(P\rightarrow\beta_1 P&#39;|\beta_2 P&#39;|...|\beta_n P&#39;\)</span></p>
<p><span class="math inline">\(P&#39;\rightarrow\alpha_1 P&#39;|\alpha_2 P&#39;|...|\alpha_m P&#39;|\varepsilon\)</span></p>
<h3 id="first-follow">FIRST, FOLLOW</h3>
<p>终结首符集: <span class="math inline">\(FIRST(\alpha)=\{a|\alpha\Rightarrow^*a...,a\in V_T\}, \\特别地, 如果\alpha\Rightarrow^*\varepsilon, 则规定\varepsilon\in FIRST(\alpha)\)</span></p>
<p>后继终结符号集: <span class="math inline">\(FOLLOW(A)=\{a|S\Rightarrow^*...Aa...,a\in V_T\}, \\特别地, 如果S\Rightarrow^*...A, 则规定\#\in FOLLOW(S)\)</span></p>
<h3 id="ll1文法">LL(1)文法</h3>
<p>可以进行无回溯的自上而下分析 - 不含左递归 - 产生式右侧的所有非终结符的FIRST集无交集 - <span class="math inline">\(A\rightarrow\alpha_1|\alpha_2|...|\alpha_n\Rightarrow FIRST(\alpha_i)\cap FIRST(\alpha_j)=\Phi, (i\neq j)\)</span> - 若<span class="math inline">\(\varepsilon\in FIRST(A)\)</span>, 则<span class="math inline">\(FIRST(A)\cap FOLLOW(A)=\Phi\)</span></p>
<h3 id="ll1分析方法">LL(1)分析方法</h3>
<ul>
<li>当前输入符号为<span class="math inline">\(a\)</span>, 要匹配一个<span class="math inline">\(A\)</span>, 且<span class="math inline">\(A\rightarrow\alpha_1|\alpha_2|...|\alpha_n\)</span></li>
<li>若<span class="math inline">\(a\in FIRST(\alpha_i\)</span>)集合, 则直接匹配<span class="math inline">\(A\rightarrow\alpha_i\)</span></li>
<li>若<span class="math inline">\(\varepsilon\in FIRST(A)\)</span>, 但是<span class="math inline">\(a\in FOLLOW(A)\)</span>中, 仍可以匹配</li>
<li>否则报错</li>
</ul>
<h3 id="ll1程序构造">LL(1)程序构造</h3>
<h4 id="递归下降程序">递归下降程序</h4>
<ul>
<li>每个递归过程对应一个非终结符</li>
</ul>
<h4 id="预测分析程序">预测分析程序</h4>
<p>使用分析表和符号栈实现LL(1)分析</p>
<p>需要预先构造分析表</p>
<p>略</p>
<h2 id="规范规约">规范规约</h2>
<p><strong>短语</strong>: - <span class="math inline">\(对于文法G, 开始符号S, 若\alpha\beta\delta是一个句型, 如果S\Rightarrow^*\alpha A\delta且A\Rightarrow^+\beta, 则称\beta是句型\alpha\beta\delta相对于A的短语\)</span> - <span class="math inline">\(句型语法树中每棵子树的所有叶子结点左右到右排列起来构成一个该句型相对于子树根(A)的短语\)</span></p>
<p><strong>直接短语</strong>: - <span class="math inline">\(A\Rightarrow\beta\)</span> - <span class="math inline">\(只有父子两代的子树形成的短语, 一步推导出终结符的子树\)</span></p>
<p><strong>句柄</strong>: - <span class="math inline">\(一个句型的最左直接短语\)</span> - <span class="math inline">\(语法树中最左的只有父子两代的子树形成的短语\)</span></p>
<img src="/2020/12/17/parser/phrase.png" class="">
<p>句型<code>E+T*F</code>的 - 短语为<code>E+T*F</code>(相对于E), <code>T*F</code>(相对于T) - 直接短语为<code>T*F</code> - 句柄为<code>T*F</code></p>
<h2 id="算符优先分析法">算符优先分析法</h2>
<h3 id="算符优先文法">算符优先文法</h3>
<p>算符文法: 任一产生式的右部都不包含两个<strong>相继(并列)的非终结符</strong></p>
<p>最多一个优先关系: 对任何一对终结符, (a,b)最多满足一个优先关系</p>
<p>算符优先文法: 满足最多一个优先关系的算符文法</p>
<h3 id="优先关系表">优先关系表</h3>
<p>优先关系的表格</p>
<h3 id="firstvt-lastvt">FIRSTVT, LASTVT</h3>
<p><span class="math inline">\(FIRSTVT(P)=\{a|P\Rightarrow^+a...或P\Rightarrow^+Qa..., a\in V_T而Q\in V_N\}\)</span></p>
<p><span class="math inline">\(LASTVT(P)=\{a|P\Rightarrow^+...a或P\Rightarrow^+...Qa, a\in V_T而Q\in V_N\}\)</span></p>
<h3 id="素短语">素短语</h3>
<p>素短语: 至少含有一个终结符, 而且除它自身以外不含有任何更小的素短语</p>
<p>最左素短语: 句型最左边的素短语</p>
<h2 id="lr分析法">LR分析法</h2>
<p>L: 从左到右扫描输入串 R: 构造最右推导的逆过程 LR分析法是严格的规范规约</p>
<p>原理: 在移进-规约过程中寻找句柄</p>
<p>模型: - 将历史和展望抽象成状态, 整体上是一个FA - 一张分析表 - ACTION[s,a]: 状态s遇到输入a应该采取什么动作 - GOTO[s,X]: 状态s遇到文法符号X时下一状态是什么, 构成了一个以文法符号为字母表的DFA</p>
<p>分类: - 总控程序: 所有的LR分析器都相同 - 分析表: 是自动生成语法分析器的关键 - LR(0)表: 基础但有局限性 - SLR表: 简单LR表, 实用 - 规范LR表: 能力强, 代价大 - LALR表: 向前LR表, 介于SLR和规范LR之间</p>
<p>ACTION表: 1. 移进<span class="math inline">\(sN\)</span>: 将<span class="math inline">\(N\)</span>和输入符号<span class="math inline">\(a\)</span>进栈, 读取下一个输入 2. 规约<span class="math inline">\(rN\)</span>: 用<span class="math inline">\(N\)</span>号产生式<span class="math inline">\(A\Rightarrow\beta\)</span>进行规约, 出栈<span class="math inline">\(|\beta|\)</span>项, 将<span class="math inline">\(GOTO[s.top, A]\)</span>和<span class="math inline">\(A\)</span>进栈(规约), <strong>输入不动</strong> 3. 接受<span class="math inline">\(acc\)</span>: 分析成功结束 4. 报错</p>
<p>LR文法: 能够构造LR分析表, 使得每个入口都是唯一确定的文法</p>
<p>LR(k)文法: 每步至多向前检查k个输入符号就能用LR分析器进行分析的文法 - 大多数PL符合LR(1)文法 - k=0表示不需要展望</p>
<h3 id="lr0">LR(0)</h3>
<p>LR(0)项目: 在文法产生式右部中间间隔处加一个圆点 - 指明了在分析过程的某一时刻看到了产生式的多大部分</p>
<p>活前缀: 规范句型的最多到句柄(可以包括句柄)的前缀 - LR分析时栈里的符号应该始终构成活前缀</p>
<h4 id="识别活前缀的nfa方法">1. 识别活前缀的NFA方法:</h4>
<ul>
<li>只有项目1作为初态, 其他任何项目都认为是终态</li>
<li>连接非<span class="math inline">\(\varepsilon\)</span>弧
<ul>
<li><span class="math inline">\(状态i为X\rightarrow X_1...X_{i-1}\cdot X_i...X_n\)</span></li>
<li><span class="math inline">\(状态j为X\rightarrow X_1...X_{i-1}X_i\cdot X_{i+1}...X_n\)</span></li>
<li>则连接状态<span class="math inline">\(i\)</span>到状态<span class="math inline">\(j\)</span>, 标志为<span class="math inline">\(X_i\)</span></li>
</ul></li>
<li>连接<span class="math inline">\(\varepsilon\)</span>弧
<ul>
<li><span class="math inline">\(状态i为X\rightarrow \alpha\cdot A\beta\)</span></li>
<li>则连接状态<span class="math inline">\(i\)</span>到所有状态<span class="math inline">\(A\rightarrow\cdot\gamma\)</span>, 标志为<span class="math inline">\(\varepsilon\)</span></li>
</ul>
<img src="/2020/12/17/parser/huoqianzhui.png" class=""></li>
<li>确定化(NFA转DFA)
<ul>
<li>(也可以直接看出来)</li>
</ul>
<img src="/2020/12/17/parser/huoqianzhui2.png" class=""></li>
</ul>
<h4 id="lr0项目集规范族">2. LR(0)项目集规范族</h4>
<ul>
<li>识别活前缀的DFA的项目集的全体称为文法的LR(0)项目集规范族
<ul>
<li>规约项目: <span class="math inline">\(A\rightarrow\alpha\cdot\)</span></li>
<li>接受项目: <span class="math inline">\(S\rightarrow\alpha\cdot\)</span></li>
<li>移进项目: <span class="math inline">\(A\rightarrow\alpha\cdot a\beta\)</span></li>
<li>待约项目: <span class="math inline">\(A\rightarrow\alpha\cdot B\beta\)</span></li>
</ul></li>
<li>拓广文法
<ul>
<li>构造一个新的文法<span class="math inline">\(G&#39;\supseteq G\)</span></li>
<li>引进一个开始符号, 非终结符<span class="math inline">\(S&#39;\)</span></li>
<li>增加一个产生式<span class="math inline">\(S&#39;\rightarrow S\)</span></li>
<li>唯一接受态: <span class="math inline">\(S&#39;\rightarrow S\cdot\)</span></li>
</ul></li>
<li>项目集的闭包<span class="math inline">\(Closure(I)\)</span>:
<ul>
<li><span class="math inline">\(I\in Closure(I)\)</span></li>
<li>若<span class="math inline">\((A\rightarrow\alpha\cdot B\beta)\in Closure(I)\)</span>, 则对于任何<span class="math inline">\(B\rightarrow\gamma\)</span>, <span class="math inline">\((B\rightarrow\cdot\gamma)\in Closure(I)\)</span></li>
<li>与<span class="math inline">\(I\)</span>同状态的项目集合, 包括子项目</li>
</ul></li>
<li>状态转换函数<span class="math inline">\(GO(I,X)\)</span>:
<ul>
<li><span class="math inline">\(GO(I, X)=Closure(\{A\rightarrow\alpha X\cdot\beta|(A\rightarrow\alpha\cdot X\beta)\in I\})\)</span></li>
<li>若<span class="math inline">\(I\)</span>是对活前缀<span class="math inline">\(\gamma\)</span>有效的项目集, 那么<span class="math inline">\(GO(I, X)\)</span>就是对<span class="math inline">\(\gamma X\)</span>有效的项目集</li>
<li>(接受<span class="math inline">\(X\)</span>之后的<span class="math inline">\(Closure\)</span>集合)</li>
</ul></li>
<li>构造DFA算法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROCEDURE ITEMSETS(G&#x27;)</span><br><span class="line">BEGIN</span><br><span class="line">  C:=&#123;Closure(&#123;S&#x27;\rightarrow\cdot S&#125;)&#125;</span><br><span class="line">  REPEAT</span><br><span class="line">    FOR C中每个项目集I和G&#x27;的每个符号X DO</span><br><span class="line">      IF GO(I, X)非空且不属于C THEN</span><br><span class="line">        C += GO(I, X)</span><br><span class="line">  UNTIL C 不再增大</span><br><span class="line">END</span><br></pre></td></tr></table></figure></li>
</ul>
<p>LR(0)文法: - 拓广文法的识别活前缀的dfa的项目集(LR(0)项目集规范族)不包含任何<strong>冲突</strong>的文法</p>
<p>冲突 - 既含移进项目又含规约项目 - <code>E-&gt;E·*E</code> - <code>E-&gt;E+E·</code> - 含有多个规约项目 - <code>P-&gt;A·</code> - <code>Q-&gt;A·</code></p>
<p>构造LR(0)分析表: - 每个项目集为一个状态 - 包含<span class="math inline">\(S&#39;\rightarrow\cdot S\)</span>的集合为初态</p>
<p><strong>构造LR(0)的ACTION和GOTO</strong>: - 若<span class="math inline">\((A\rightarrow\alpha\cdot a\beta)\in I_k\)</span>且<span class="math inline">\(GO(I_k, a)=I_j\)</span>, 则<span class="math inline">\(ACTION[k, a]=sj\)</span> - 若<span class="math inline">\((A\rightarrow\alpha\cdot)\in I_k\)</span>, 则<span class="math inline">\(ACTION[k, a]=rj\)</span> - 若<span class="math inline">\((S&#39;\rightarrow S)\in I_k\)</span>, 则<span class="math inline">\(ACTION[k, a]=acc\)</span> - 若<span class="math inline">\(GO(I_k,A)=I_j\)</span>, 则<span class="math inline">\(GOTO[k, a]=j\)</span> - 其他均为报错</p>
<img src="/2020/12/17/parser/lr0_table.png" class="">
<h3 id="slr">SLR</h3>
<p>LR(0)可能会误判: 即使存在项目冲突, 也不一定不合法</p>
<p>假定LR(0)规范族的一个项目集 <span class="math display">\[
\begin{aligned}
I=\{
&amp;A_1\rightarrow\alpha\cdot a_1\beta_1,\\
&amp;A_2\rightarrow\alpha\cdot a_2\beta_2,\\
&amp;...\\
&amp;A_m\rightarrow\alpha\cdot a_m\beta_m,\\ 
&amp;B_1\rightarrow\alpha\cdot,\\
&amp;B_2\rightarrow\alpha\cdot,\\
&amp;...\\
&amp;B_n\rightarrow\alpha\cdot\}
\end{aligned}
\]</span></p>
<p>如果集合<span class="math inline">\(\{a_1, ..., a_m\}, FOLLOW(B_1), ..., FOLLOW(B_n)\)</span>两两不相交(包括不得有两个FOLLOW集合有#), 则 1. 若a是某个ai, i=1,2,...,m, 则移进 2. 若<span class="math inline">\(a\in FOLLOW(B_i), i=1,2,...,n\)</span>, 则用产生式<span class="math inline">\(B_i\rightarrow\alpha\)</span>进行归约 3. 此外, 报错。</p>
<p>冲突性动作的这种解决办法叫做SLR(1)解决办法。上述方法构造出的ACTION与GOTO表如果不含多重入口，则称该文法为<strong>SLR(1)文法</strong></p>
<h3 id="lr1">LR(1)</h3>
<h3 id="lalr">LALR</h3>
<p>不考, 略</p>
<h2 id="二义文法的应用">二义文法的应用</h2>
<h3 id="二义文法">二义文法</h3>
<ul>
<li>不是LR文法</li>
<li>简洁、自然</li>
<li>可以用文法以外的信息来消除二义</li>
<li>语法分析的效率高（基于消除二义后得到的分析表）</li>
</ul>
<p>举例: E → E + E | E * E | (E) | id</p>
<p>消除二义性: 1. 使用文法以外信息来解决分析动作冲突</p>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>compiler-principle</category>
      </categories>
  </entry>
  <entry>
    <title>make-a-compiler</title>
    <url>/2023/12/19/practice/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>光说不连假把式, 开搞!</p>
<h2 id="目标">目标</h2>
<ul>
<li><p>实现一个 C-to-assembly compiler</p></li>
<li><p>可以有 pre-processer</p></li>
<li><p>不需要 linker, 生成二进制通过已有的 Assembler</p></li>
<li><p>支持常用的 C99 语法</p></li>
<li><p>需要有编译优化</p></li>
</ul>
<h2 id="词法分析-语法分析">词法分析, 语法分析</h2>
<h2 id="关键数据结构">关键数据结构</h2>
<ol type="1">
<li><p>类型(Type)结构</p></li>
<li><p>结构体/联合体成员(Member)结构</p></li>
<li><p>全局变量/函数定义对象(Obj)结构</p></li>
</ol>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>compiler-principle</category>
      </categories>
      <tags>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>优化</title>
    <url>/2020/12/17/profile/</url>
    <content><![CDATA[<h2 id="提纲">提纲</h2>
<img src="/2020/12/17/profile/index.png" class="">
<h2 id="概述">概述</h2>
<p>优化：对程序进行各种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。</p>
<p>原则 - 等价 - 有效 - 合算</p>
<p>级别 - 局部优化 - 循环优化 - 全局优化</p>
<p>种类 - 删除公用子表达式 - 复写传播 - 删除无用赋值 - 代码外提 - 强度削弱 - 变换循环控制条件 - 合并已知量</p>
<h2 id="局部优化">局部优化</h2>
<h3 id="基本块">基本块</h3>
<p>基本块 - 指程序中一顺序执行语句序列，其中只有一个入口和一个出口。入口就是其中第一个语句，出口就是其中最后一个语句。</p>
<p>活跃 - 基本块中的一个名字在某个给定点之后仍被引用, 则称该名字在给定点是活跃的</p>
<p>局部优化 - 局限在基本块范围内的优化</p>
<p>划分基本块 - 基本块入口 - 程序第一条语句 - <strong>能</strong>转移到的语句 - 转移语句后面的语句 - 基本块的出口(包括) - 基本块入口的前一条语句 - 转移语句(包括) - 停语句(包括) - 不在基本块中的语句可以从程序中删除</p>
<img src="/2020/12/17/profile/basic_block.png" class="">
<p>基本块中的优化 - 删除公用子表达式 - 删除无用赋值 - 合并已知量: <code>T1=2; T2=4*T1;</code> =&gt; <code>T2=8;</code> - 临时变量改名 - 交换语句的位置 - 代数变换: 删除<code>x=x+0; x=x*1;</code>, <code>x=y^2;</code> =&gt; <code>x=y*y;</code></p>
<h3 id="流图">流图</h3>
<ul>
<li>把基本块编号后按执行顺序连接成一张图</li>
<li>入口语句是流图的首结点</li>
</ul>
<p>前驱和后继 - 在程序序列中, 若A,B相邻而且A最后一条语句不是无条件跳转, 则称A是B的前驱, B为A的后继</p>
<img src="/2020/12/17/profile/program_flow.png" class="">
<h3 id="基本块的dag表示">基本块的DAG表示</h3>
<ul>
<li>用带有标记或附加信息的DAG来表示变量间的关系</li>
<li>叶结点: 以<strong>标识符或常数</strong>作为标记</li>
<li>内部结点: 以<strong>运算符</strong>作为标记</li>
<li>每个结点可以有<strong>附加标识符</strong>: 表示附加标识符具有相同的值</li>
</ul>
<h3 id="基本块的dag优化算法">基本块的DAG优化算法</h3>
<p>基本块代码分类 - 0型: 单纯赋值语句<code>A:=B</code> - 1型: 一元运算赋值<code>A:=op B</code> - 2型: 二元运算赋值<code>A:=B op C</code>/数组取值赋值<code>A:=B[C]</code></p>
<p>对基本块中每一四元式，依次执行以下步骤: 1. 如果是0型, 记<code>NODE(B)</code>的值为<code>n</code>, 转4 2. 如果存在任意一个操作数无定义, 则构造该操作数结点 3. 如果所有操作数都是常数 1. 如果<code>NODE(B)</code>(或<code>NODE(C)</code>)是新构造的结点, 删除 2. 计算<code>op</code>, 记为<code>P</code> 3. 如果<code>NODE(P)</code>无定义, 构造之, 记为<code>n</code> 4. 否则 1. 检查DAG中是否已经存在结点<code>op</code>, 如果没有则构造之, 记为<code>n</code> 5. 删除无用赋值 1. 如果<code>A</code>已经在某个结点处定义, 删除之, 把<code>A</code>附在<code>n</code>结点上, 令<code>NODE(A)=n</code></p>
<p>DAG优化算法 - 执行上述算法 - 在基本块外被定值的标识符作为叶子结点上的标识符 - 在基本块内被定值且在基本块后被引用的标识符作为结点上的附加标识符</p>
<h2 id="循环优化">循环优化</h2>
<p>不考, 略</p>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>compiler-principle</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络复习</title>
    <url>/2021/01/05/index/</url>
    <content><![CDATA[<h1 id="按章节">按章节</h1>
<h2 id="osi七层模型">1.9 OSI七层模型</h2>
<p>设计者: 国际标准化组织ISO, 国际电信联盟ITU</p>
<p>OSI七层模型: 物理层/数据链路层/网络层/传输层/会话层/表示层/应用层</p>
<p>TCP/IP位于: 传输层/网络层</p>
<p>会话层和表示层几乎没有内容</p>
<h2 id="cs模型">3.4 CS模型</h2>
<table>
<thead>
<tr class="header">
<th>服务端程序S</th>
<th>客户端程序A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>先启动</td>
<td>后启动</td>
</tr>
<tr class="even">
<td>不知道C</td>
<td>必须知道S的位置</td>
</tr>
<tr class="odd">
<td>积极等待C来连接</td>
<td>需要通讯时初始化连接</td>
</tr>
<tr class="even">
<td>通过收发数据进行通讯</td>
<td>通过收发数据进行通讯</td>
</tr>
<tr class="odd">
<td>服务之后继续运行, 等待下一个C来连接</td>
<td>可能结束</td>
</tr>
</tbody>
</table>
<p>Internet只提供基本通讯, 实际上是由计算机上的程序来处理连接</p>
<h2 id="cs程序的特点">3.5 C/S程序的特点</h2>
<p>略</p>
<h2 id="网络编程socket-api">3.13 网络编程Socket API</h2>
<p>事实标准: Socket API</p>
<h2 id="url和超链接">4.6 URL和超链接</h2>
<h2 id="http">4.7 HTTP</h2>
<h2 id="dns和域名">4.17 DNS和域名</h2>
<h2 id="名字解析">4.20 名字解析</h2>
<h2 id="与数据传输相关的话题">5.5 与数据传输相关的话题</h2>
<ul>
<li>信息源</li>
<li>数据源编码/解码器</li>
<li>加密/解密器</li>
<li>通道编码/解码器</li>
<li>复用/解复用器</li>
<li>调制/解调器</li>
<li>物理信道和传输</li>
</ul>
<h2 id="低地卫星leo和集群">7.18 低地卫星(LEO)和集群</h2>
<p>LEO卫星群协同工作以转发消息。集群成员必须知道当前在地球给定区域上的卫星，并将消息转发给适当的成员以传输到地面站。</p>
<h2 id="奇偶校验码">8.6 奇偶校验码</h2>
<p>单奇偶校验（SPC）是信道编码的一种基本形式，其中发送方<strong>在每个字节上添加一个额外的位，以使1的个数为偶数（或奇数）</strong>，接收方验证输入的数据是否具有正确的1位数。</p>
<h2 id="因特网使用的16位校验和">8.12 因特网使用的16位校验和</h2>
<p>源数据M, 任意长度</p>
<ol type="1">
<li>补零, 直至长度是16位的倍数</li>
<li>将M按照16位分组并求和, 最多允许溢出到32位</li>
<li>将结果对半相加(高16位加低16位), 只保留16位</li>
<li>将结果取反</li>
<li>如果是0则再取反</li>
</ol>
<p>取反的目的: 方便验证, 只要求完相加判断是否溢出剩0就行了</p>
<h2 id="crc">8.13 CRC</h2>
<p>例: data=<code>10010101010</code>, G=<code>10101</code> 多项式表示: <span class="math inline">\(G=x^5+x^3+1\)</span></p>
<ol type="1">
<li>补零</li>
</ol>
<p><code>mdata = data + '0' * (G.length - 1)</code></p>
<p>得到<code>mdata = 100101010100000</code></p>
<ol start="2" type="1">
<li>模2除法</li>
</ol>
<p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">      ___101100101100_</span><br><span class="line"><span class="number">10101</span>/<span class="number">100101010100000</span></span><br><span class="line">    / <span class="number">10101</span> |   | | |</span><br><span class="line">     =  <span class="number">11110</span>   | | |</span><br><span class="line">        <span class="number">10101</span>   | | |</span><br><span class="line">       = <span class="number">10111</span>  | | |</span><br><span class="line">         <span class="number">10101</span>  | | |</span><br><span class="line">        =   <span class="number">10010</span> | |</span><br><span class="line">            <span class="number">10101</span> | |</span><br><span class="line">           =  <span class="number">11100</span> |</span><br><span class="line">              <span class="number">10101</span> |</span><br><span class="line">             = <span class="number">10010</span>|</span><br><span class="line">               <span class="number">10101</span>|</span><br><span class="line">              =  <span class="number">1110</span></span><br></pre></td></tr></table></figure></p>
<p>得到CRC=<code>1110</code></p>
<ol start="3" type="1">
<li>拼接</li>
</ol>
<p>发送的数据<code>send = data + CRC</code></p>
<p><code>send = 1000101010 1110</code></p>
<h2 id="单工半双工全双工传输">9.12 单工/半双工/全双工传输</h2>
<p>信道的三种类型</p>
<p>单工: 只能单向传输, 单根光纤就是单工, 类比收音机, 电视</p>
<p>全双工: 可以同时双向传输, 有两个光纤就可以组成全双工, 类比电话</p>
<p>半双工: 需要一个共享传输介质, 可以双向传输但是不能同时, 类比对讲机</p>
<h2 id="模拟调制">10.3 模拟调制</h2>
<p>载波: 信息发送出去时以电波的形式, 负责承载信息的波就是载波</p>
<p>调制: 根据要发送的信息, 对载波进行的调整</p>
<pre><code>原始载波(输入1) --\
                (调制器) ---&gt; 调制过的载波(输出)
信息 (输入2)    --/</code></pre>
<p>三种主要调制技术: * 振幅调制 * 频率调制 * 移相调制</p>
<h2 id="modem">10.12 Modem</h2>
<p>为了方便网络安装, 一般将调制和解调功能集成在一个叫做调制解调器的设备中</p>
<h2 id="局部环路特性和适应">12.6 局部环路特性和适应</h2>
<p>接入技术: ISP到用户的连接</p>
<p>本地用户环路(local subscriber line)/本地环路(local loop): 电话公司交换局到用户之间的物理连接, 一般是使用双绞线 (其实就是电话线路?)</p>
<p>DSL: 一种利用local loop提供网络的技术</p>
<p>ADSL: 不对称DSL, 利用频分复用将local loop的带宽分成三个区域</p>
<table>
<thead>
<tr class="header">
<th>频率</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0-4</td>
<td>普通老式电话业务</td>
</tr>
<tr class="even">
<td>26-138</td>
<td>上行频带</td>
</tr>
<tr class="odd">
<td>138-1100</td>
<td>下行频带</td>
</tr>
</tbody>
</table>
<p>因为本地环路的电气特性变化各异，ADSL采用了自适应技术，即一对调制解调器先探测彼此之间连接线路上的许多频率，然后选择在此线路上能产生最优传输质量的频率和相应的调制技术。</p>
<h2 id="adsl的传输速率">12.7 ADSL的传输速率</h2>
<p>上行: 32 - 640 Kbps, 去掉控制信道: 32 - 576 Kbps</p>
<p>下行: 32 - 8448 Kbps</p>
<h2 id="电缆调制解调器技术">12.9 电缆调制解调器技术</h2>
<p>本地环路具有局限性: 双绞线不抗干扰,</p>
<p>因此创造了基于 同轴电缆 + FDM + 统计复用 的电缆调制解调器技术, 每一组用户共享一个数据信道, 通过Modem判断数据是否属于该用户</p>
<p>传输速率: 上行 512 Kbps, 下行 52 Mbps</p>
<h2 id="本地和广域包交换网络">13.4 本地和广域包交换网络</h2>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>距离</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LAN</td>
<td>房间/建筑</td>
</tr>
<tr class="even">
<td>MAN</td>
<td>大城市</td>
</tr>
<tr class="odd">
<td>WAN</td>
<td>多个城市</td>
</tr>
</tbody>
</table>
<h2 id="包识别-解复用-mac地址">13.9 包识别, 解复用, MAC地址</h2>
<p>地址: 在包交换系统中, 解复用时使用的标识符, 每个包都包含了目的地地址</p>
<p>IEEE地址(MAC地址): 48位地址, 每个NIC都不一样, 分为前24位OUI, 24位NIC地址</p>
<h2 id="单播-广播-多播">13.10 单播, 广播, 多播</h2>
<p>IEEE保留了MAC地址中的一位(最高有效字节的最低位)来区分单播(0)和多播(1)</p>
<p>广播视为一种特殊的多播, 广播地址所有位全1</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>单播</td>
<td>唯一标识一台计算机，并规定只有被标识的那台计算机才能接收分组的副本</td>
</tr>
<tr class="even">
<td>广播</td>
<td>对应所有的计算机，并规定网络上每台计算机都应该接收分组的副本</td>
</tr>
<tr class="odd">
<td>组播</td>
<td>标识指定网络上所有计算机的一个子集，并规定该子集中的每台计算机都应该接收分组的副本</td>
</tr>
</tbody>
</table>
<h2 id="广播-多播和多点传递">13.11 广播, 多播和多点传递</h2>
<p>在LAN中, 广播和多播极大地提高了效率</p>
<h2 id="随机接入协议">14.6 随机接入协议</h2>
<p>接入技术: 多台相互独立的计算机如何进行协调接入一个<strong>共享介质</strong></p>
<p>MAC层: Media <strong>Access</strong> Control 介质接入控制</p>
<p>方法: 采用复用技术的改进形式, 采用分布式算法</p>
<p>多址接入协议 - 受控接入协议 - 预约 - 轮询 - 令牌传递 - 随机接入协议 - ALOHA - CSMA/CD - CSMA/CA - 信道分配协议 - FDMA - TDMA - CDMA</p>
<p>在LAN中, 用户接入共享介质的时机是随机的, 因此可能造成冲突, 需要用合适的方法解决</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ALOHA</td>
<td>教科书中流行的协议, 但没有实际应用, 划分上行/下行两个频段用来传输信息, 上行采用随机延迟来解决冲突问题, 下行采用广播机制</td>
</tr>
<tr class="even">
<td>CSMA/CD</td>
<td>带冲突检测的载波侦听多址接入, 原始以太网使用, 但交换式以太网不再使用, 使用载波侦听+冲突检测+指数退避算法解决冲突问题</td>
</tr>
<tr class="odd">
<td>CSMA/CA</td>
<td>带冲突避免的载波侦听多址接入, 无线LAN使用, 与CSMA/CD类似, 不同在于分组传输前会发送一个控制报文, 接收方广播控制消息</td>
</tr>
</tbody>
</table>
<p>CSMA/CD: - Carrier Sense载波侦听 - Multiple Access多址接入 - Collision Detect冲突检测</p>
<p>CSMA/CA: - Carrier Sense载波侦听 - Multiple Access多址接入 - Collision Avoidance冲突避免</p>
<h2 id="以太网帧格式">15.3 以太网帧格式</h2>
<p>(传统)以太网: 是一种LAN技术, 最早在施乐公司的PARC中发明, 后来被标准化</p>
<p>帧: 数据链路层的协议数据单元</p>
<p>(传统)以太网帧格式:</p>
<img src="/2021/01/05/index/ethernet_frame.png" class="">
<ul>
<li><p>以太网帧(64-1518) := 头部(14) + 载荷(46-1500) + CRC(4)</p></li>
<li><p>头部 := 目的地址(MAC地址, 6) + 源地址(MAC地址, 6) + 类型(2)</p></li>
</ul>
<h2 id="以太网帧的类型域">15.4 以太网帧的类型域</h2>
<p>以太网帧类型域包含了载荷中的报文类型, 如IPv4/IPv6/ARP等, 接收方检查该值来进行复用与解复用</p>
<h2 id="以太网">15.5 802.3以太网</h2>
<p>802.3以太网: IEEE 802.3重新修订后的以太网标准, (但不是很成功)</p>
<img src="/2021/01/05/index/8023_ethernet_frame.png" class="">
<ul>
<li><p>802.3以太网帧(64-1518) := 头部(14) + <strong>SNAP头部(8)</strong> + 新载荷(46(存疑)-<strong>1492</strong>) + CRC(4)</p></li>
<li><p>头部 := 目的地址(MAC地址, 6) + 源地址(MAC地址, 6) + <strong>帧长度(2)</strong></p></li>
<li><p><strong>SNAP头部 := LLC(3) + OUI(3) + 类型(2)</strong></p></li>
<li><p>兼容性处理: 类型域&lt;=1500是802.3帧, 否则是传统以太网帧</p></li>
</ul>
<h2 id="粗缆布线的以太网">15.7 粗缆布线的以太网</h2>
<p>粗缆以太网(Thick wire Ethernet)/粗网(Thicknet, 10Base5): 最初版本的以太网布线方案, 因为其使用笨重的同轴电缆+收发器+AUI电缆方式而得名.</p>
<img src="/2021/01/05/index/thicknet.png" class="">
<h2 id="细缆布线的以太网">15.8 细缆布线的以太网</h2>
<p>细缆以太网(Thin wire Ethernet)/细网(Thinnet, 10Base2): 第二代以太网布线方案, 使用细同轴电缆依次串联计算机, 不再需要AUI线, 收发器集成到NIC中, 缺点是容易单点故障</p>
<img src="/2021/01/05/index/thinnet.png" class="">
<h2 id="双绞线布线的以太网">15.9 双绞线布线的以太网</h2>
<p>双绞线以太网(10BaseT): 第三代以太网布线系统, 使用了双绞线取代同轴电缆, 引入中心集线器(hub)</p>
<img src="/2021/01/05/index/twistnet.png" class="">
<p>集线器是物理层设备, 具有一定的功能, 比如CSMA/CD等, 现在大部分已经被交换机取代</p>
<h2 id="无线网络的分类">16.2 无线网络的分类</h2>
<p>和有线网络类似: 个域网/局域网/城域网/广域网</p>
<h2 id="个域网">16.3 个域网</h2>
<p>蓝牙/红外/ISM无线</p>
<h2 id="wlan和wi-fi">16.5 WLAN和Wi-Fi</h2>
<p>WLAN技术的种类很多, 归类于IEEE802.11标准</p>
<p>Wi-Fi联盟: 一群无线设备供应商组成的非营利性组织, 使用802.11标准对无线设备进行测试与认证</p>
<h2 id="wlan基础结构">16.8 WLAN基础结构</h2>
<p>WLAN的三个构件: 接入点(Access Point, AP, 非正式也称基站), 互联机构(交换机或路由器等), 无线主机(Station)</p>
<img src="/2021/01/05/index/wlan.png" class="">
<img src="/2021/01/05/index/wlan2.png" class="">
<p>WLAN的两种类型: Adhoc无接入点结构(很少), Infrastructure有中心接入点</p>
<p>互联设备到AP的有线连接通常使用双绞线以太网</p>
<p>基本服务组(BSS): 在某一个给定AP范围内的计算机集合</p>
<h2 id="重叠-关联-802.11帧格式">16.9 重叠, 关联, 802.11帧格式</h2>
<p>重叠: 两个AP太近, 一台STA可以同时触及到两个AP</p>
<p>802.11要求每个主机只能与一个AP相关联(associate), 而且在802.11帧中携带了AP的MAC地址</p>
<ul>
<li>接入点MAC</li>
<li>本机地址</li>
<li>路由器MAC</li>
<li>专用地址</li>
</ul>
<img src="/2021/01/05/index/80211_frame.png" class="">
<h2 id="竞争与无竞争接入">16.11 竞争与无竞争接入</h2>
<p>802.11定义了两种接入方法 - 点协调功能PCF - 分布式协调功能DCF</p>
<p>隐蔽站问题: WLAN中所用的发射机有一个受限的发射范围, 离发射机的距离超过发射范围的接收方将无法收到信号, 因而无法检测载波</p>
<p>802.11使用CSMA/CA协议来解决接入中的隐蔽站问题 * 传输分组前交换一对RTS,CTS控制报文 * 没有冲突检测, 而是采用确认ACK+超时重传机制 * 设定SIFS(发ACK前延时)/DIFS(传输前延时)/Slot Time等时间间隔参数</p>
<img src="/2021/01/05/index/csma_ca.png" class="">
<h2 id="pan技术与标准">16.13 PAN技术与标准</h2>
<ul>
<li>802.15.1a 蓝牙</li>
<li>802.15.3a UWB 超宽带</li>
<li>802.15.4 Zigbee 工业无线控制标准</li>
</ul>
<h2 id="光纤猫扩展">17.3 光纤猫扩展</h2>
<p>最简单的LAN扩展机制: 光纤+一对光纤猫, 连接一台计算机和一个远程以太网</p>
<h2 id="中继器">17.4 中继器</h2>
<p>中继器: 信号放大, 信号转发, 早期广泛应用</p>
<h2 id="网桥与桥接">17.5 网桥与桥接</h2>
<p>网桥: 往往用来连接两个LAN网段(比如hub), 保证两边的计算机都能互相连通</p>
<p>计算机无法分辨LAN中有无网桥</p>
<h2 id="自学习网桥与帧过滤">17.6 自学习网桥与帧过滤</h2>
<p>网桥与一根网线直连的区别: 网桥分隔冲突域, 但不分隔广播域 <strong>网桥仅在有必要的时候才进行转发</strong> * 源地址和目标地址位于两个网段 * 广播帧和多播帧</p>
<p>网桥能够自动学习设备位于网桥的哪一侧(基于分组中的源MAC地址)</p>
<h2 id="桥接的好处">17.7 桥接的好处</h2>
<p>桥接的各个网段可以同时进行传输, 使得不同建筑物之间的通讯成为了可能</p>
<h2 id="分布式生成树">17.8 分布式生成树</h2>
<p>如果网桥连接导致网络中存在环路, 那么广播和多播帧会被无限循环转发下去</p>
<p>因此网桥会执行生成树算法来生成一个树</p>
<h2 id="下一条转发">18.7 下一条转发</h2>
<p>分组交换机收到一个分组后, 如果分组的目的地不是直连在交换机上, 就需要查表转发</p>
<p>交换机的转发表: 目的地址:输出接口</p>
<h2 id="广域网动态路由更新">18.9 广域网动态路由更新</h2>
<p>转发表的要求 * 全局通信 - 必须覆盖所有可能目的地的 * 最优路径 - 下一条必须是距目的地的最短路径</p>
<p>路由软件: 自动重新配置转发表的软件</p>
<h2 id="分布式路径计算">18.12 分布式路径计算</h2>
<p>分布式路径计算的两种常用形式: * 链路状态路由LSR, 采用Dijkstra算法 * 距离向量路由DVR</p>
<p>LSR: 每台交换机定期广播一条边的状态, 相邻交换机据此更新自己的转发表</p>
<p>DVR: 每台交换机定期告诉相邻交换机自己的距离向量表(包含一对(目的,距离)), 相邻交换机据此更新自己的转发表</p>
<h2 id="最短路径的计算">18.13 最短路径的计算</h2>
<p>Dijkstra算法</p>
<h2 id="用路由器连接物理网络">20.6 用路由器连接物理网络</h2>
<p>路由器是一台专门完成网络互联任务的专用硬件系统, 可以将多个使用不同技术（包括不同的传输介质、物理编址方案或帧格式）的网络互相连接（互联）起来 (比如连接以太网和WiFi网)</p>
<h2 id="ip有类编址方案">21.7 IP有类编址方案</h2>
<p>IP地址<strong>有类编址方案</strong></p>
<table>
<thead>
<tr class="header">
<th>类别</th>
<th>标识位</th>
<th>前缀长度</th>
<th>最大网络数量</th>
<th>后缀长度</th>
<th>最大主机数量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>0</td>
<td>7</td>
<td>128</td>
<td>24</td>
<td>2^24</td>
</tr>
<tr class="even">
<td>B</td>
<td>10</td>
<td>14</td>
<td>16384</td>
<td>16</td>
<td>65536</td>
</tr>
<tr class="odd">
<td>C</td>
<td>110</td>
<td>21</td>
<td>2^21</td>
<td>8</td>
<td>256</td>
</tr>
<tr class="even">
<td>D(组播)</td>
<td>1110</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="odd">
<td>E(保留)</td>
<td>1111</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="ip无类编址方案">21.10 IP无类编址方案</h2>
<p>IP地址<strong>无类/子网编址方案</strong>: 引入附加的地址掩码(子网掩码)来指定网络地址和主机地址的分界线</p>
<p>无类地址 &amp; 子网掩码 == 网络地址</p>
<h2 id="ipv6地址">21.21 IPv6地址</h2>
<p>和IPv4类似, IPv6为每个接入网络的计算机分配了一个独一无二的地址</p>
<p>IPv6的特点</p>
<ul>
<li><p>将<code>网络地址</code>进一步细分为<code>全球单播地址</code>和<code>子网地址</code>两部分, <code>主机地址</code>仍保留, 两者共128位, 用<code>/xx</code>来表示<code>网络地址</code>的长度, 如不指定默认是64位</p>
<img src="/2021/01/05/index/ipv6.png" class=""></li>
<li><p>取消<code>广播</code>, 支持<code>多播</code>, 增加<code>任播</code>(anycast)</p>
<img src="/2021/01/05/index/ipv6_special.png" class=""></li>
</ul>
<h2 id="ip数据报">22.4 IP数据报</h2>
<p>IP数据报(-65535) := 头部 + 数据区(载荷区)</p>
<h2 id="ip数据报头部格式">22.5 IP数据报头部格式</h2>
<img src="/2021/01/05/index/ip_datagram.png" class="">
<h2 id="网络前缀提取与数据报转发">22.7 网络前缀提取与数据报转发</h2>
<p>根据网络地址查询转发表发给下一站</p>
<h2 id="最长前缀匹配">22.8 最长前缀匹配</h2>
<p>查询转发表时如果有多项匹配, 采用<strong>最长前缀匹配</strong>规则</p>
<h2 id="ip封装">22.11 IP封装</h2>
<p>IP数据报要被封装到一个帧里才能发送出去, 帧的目的地址是下一站的IP地址对应的MAC地址(通过ARP协议获得)</p>
<h2 id="ip分片和重装机制">22.14 IP分片和重装机制</h2>
<h2 id="分片数据报的收集">22.15 分片数据报的收集</h2>
<p>最大传输单元MTU: 每种物理网络规定的一帧能够携带的最大数据量</p>
<p>IP数据报分片机制: 当一个数据报长度大于前方网络的MTU时, 路由器会将数据报分成若干较小的片(fragment), 然后将每一片独立地封装发送出去</p>
<p>分片: 每个片与数据报的格式一样, 头部部分参数不同 * 标识: 每个数据报的唯一标识, 同一个原始数据报的所有片段的标识是一样的 * 标志: 标识了该数据报是片还是完整的数据报, 以及是否是最后一片 * 片偏移: 该片在原数据报中的位置</p>
<p>重装: 在所有片的基础上重新产生原数据报的过程, <strong>IP规定只有最终目的主机才能对片进行重装</strong></p>
<h2 id="icmp报文格式与封装">23.9 ICMP报文格式与封装</h2>
<p>因特网控制报文协议(ICMP): 利用IP来传输IP传输中发生的错误</p>
<p>ICMP报文放置在IP数据报的数据区传输</p>
<h2 id="协议软件-参数和配置">23.10 协议软件, 参数和配置</h2>
<p>协议软件采用参数化设计</p>
<p>主机配置采用自举过程, 运行时获取到IP地址, 掩码, DNS服务器地址等参数填入程序中运行</p>
<h2 id="udp">24.3 UDP</h2>
<p>UDP的特征: * 端到端: UDP是一个传输协议, 它能区分运行在给定计算机上的多个应用程序 * 无连接: UDP提供给应用的接口遵从无连接模式 * 面向报文: 使用UDP的应用进程所发送和接收的数据是单个报文 * 尽力而为: UDP提供给应用的是与IP一样的尽力传递机制 * 任意交互: UDP允许应用进程给很多其他应用进程发送数据, 也允许从很多其他应用进程那里接收数据, 或者只跟一个其他应用进程相互通信 * 操作系统无关: UDP所提供的标识应用程序的方法, 不取决于本地操作系统所使用的标识符</p>
<img src="/2021/01/05/index/udp_segment.png" class="">
<h2 id="无连接的通信模式">24.4 无连接的通信模式</h2>
<p>UDP采用无连接通信模式, 可以在任何时候发送数据, 不需要维护通信状态, 也不使用控制报文, 因此传输开销极低</p>
<h2 id="交互模式和广播传递">24.7 交互模式和广播传递</h2>
<p>UDP支持四种交互通信方式: * 一对一 * 一对多 * 多对一 * 多对多</p>
<p>底层是利用IP组播和广播机制实现的</p>
<h2 id="用协议端口号标识端点">24.8 用协议端口号标识端点</h2>
<p>协议端口号: 用来标识应用程序的<strong>标识符抽象集</strong>, 独立于底层操作系统</p>
<h2 id="tcp">25.3 TCP</h2>
<p>TCP提供的服务有7个主要特点: * 面向连接: TCP提供面向连接的服务, 应用程序必须首先请求建立一个到目的地的连接, 然后使用这个连接来传输数据 * 点对点通信: 每个TCP连接上只有两个端点 * 完全的可靠性: TCP能保证在一个连接上发送的数据被正确地传递, 且保证数据的完整和按序到达 * 全双工通信: TCP连接允许数据在任何一个方向上流动, 并允许任何应用程序在任何时刻发送数据 * 流接口: TCP提供一个流接口, 利用它应用进程可以在一个连接上发送连续的字节流. TCP不必将数据组合成记录或是报文, 也不要求传递给接收应用进程的数据段大小一定要与发送端所送出的数据段大小相同 * 可靠的连接建立: TCP允许两个应用进程可靠地开始通信 * 友好的连接关闭: 在关闭一个连接之前, TCP必须保证所有数据已经传递完毕, 并且通信双方都要同意关闭这个连接</p>
<img src="/2021/01/05/index/tcp_segment.png" class="">
<h2 id="端对端服务与虚拟连接">25.4 端对端服务与虚拟连接</h2>
<p>TCP和UDP都是<strong>端到端协议</strong>: 提供在一台计算机上的应用进程与另一台计算机上的应用进程之间的通信能力</p>
<p>TCP是<strong>面向连接</strong>的协议, TCP提供的连接是一种虚拟连接, 因为它是软件实现的连接</p>
<p>TCP将底层因特网视为一个通信系统</p>
<h2 id="一般可靠传输协议所采用的技术">25.5 一般可靠传输协议所采用的技术</h2>
<ul>
<li>分组乱序
<ul>
<li>排序技术: 每个分组都附加一个序号</li>
</ul></li>
<li>分组丢失
<ul>
<li>带重传的正向确认: 接收方发送ACK报文表示成功接收; 若超时仍未收到ACK, 则重传</li>
</ul></li>
<li>分组重复(重放错误)
<ul>
<li>每一次会话用一个唯一的ID标识</li>
</ul></li>
<li>数据过载
<ul>
<li>停-走系统: 不好, 效率很低</li>
<li>滑动窗口: 定义<strong>窗口大小</strong>为接收方一次可以承载的最大数据量/发送方收到ACK前可以发送的最大数据量, 发送方收到ACK之后窗口向后移动</li>
</ul></li>
</ul>
<h2 id="缓冲-流控制-窗口">25.11 缓冲, 流控制, 窗口</h2>
<p>TCP使用了以字节计量的窗口, 接收方将自己剩余的缓冲区大小放在ACK报文中, 发送方根据这个窗口大小来决定是继续发送还是停止</p>
<h2 id="动态路由和路由器">26.4 动态路由和路由器</h2>
<p>每个路由器都运行路由软件，该软件了解其他路由器可以到达的目的地，并向其他路由器通知其可以到达的目的地。路由软件使用传入的信息来连续更新本地转发表。</p>
<h2 id="两类因特网路由协议">26.7 两类因特网路由协议</h2>
<p>因特网路由协议的分类: * 内部网关协议IGP: 自治系统内部使用的协议, 可以自由选择, 例如RIP, OSPF, is-is等 * 外部网关协议EGP: 自治系统之间使用的协议, 例如BGP</p>
<p>路由度量指标: 评价路由路径好坏的指标</p>
<ul>
<li><p>尽管大多数Internet路由协议都设计为使用跃点作为路由指标，网络管理员也可以覆盖该指标以实施策略。</p></li>
<li><p>在自治系统中，IGP软件使用路由度量来选择到达每个目的地的最佳路径。 EGP软件可以找到到达每个目的地的路径，但是找不到最佳路径，因为它无法比较来自多个自治系统的路由度量。</p></li>
</ul>
<h2 id="ospf协议">26.12 OSPF协议</h2>
<p>RIP是内部网关协议, 使用<strong>距离矢量算法</strong>来传递路由信息。RIP 是在 UDP 协议之上的一种路由协议，应用于 OSI 网络七层模型的<strong>网络层</strong>。</p>
<p>OSPF是内部网关协议，它使用<strong>链路状态算法</strong>来传播路由信息。路由器使用<strong>Dijkstra算法</strong>计算最短路径。</p>
<h2 id="组播路由技术">26.16 组播路由技术</h2>
<p>IP组播群组的成员关系构成是动态的，即计算机可以随时加入或离开一个群组。群组成员关系只是定义了一组接收者；任意一个应用进程（即使它不是一个群组成员）都能发送数据报给组播群组。</p>
<p>因特网组播的动态特性使它的组播路径传播问题变得很困难。虽然已经提出了很多协议，但是目前因特网还没有全网范围内的组播路由设施。</p>
<h2 id="私有密钥对称加密">29.9 私有密钥(对称)加密</h2>
<h2 id="公开密钥非对称加密">29.10 公开密钥(非对称)加密</h2>
<h2 id="使用数字签名的鉴别">29.11 使用数字签名的鉴别</h2>
<p>签名: 发送方使用自己的私钥对报文进行加密</p>
<p>验证: 接收方使用发送方的公钥进行解密</p>
<p>认证+加密: 发送者先对报文进行签名, 再用接收者的公钥进行加密</p>
<h2 id="防火墙">29.13 防火墙</h2>
<p>防火墙: 防止因特网上的问题扩散到本地内部的计算机上的技术, 一般放置在本单位的网络与外部因特网之间</p>
<h2 id="包过滤防火墙的实现">29.14 包过滤防火墙的实现</h2>
<p>防火墙利用包过滤技术来防止不希望有的通信交互。每种过滤器规则都要给出数据包头部参数的组合，包括IP源地址、目的地址、协议端口号和传输协议类型等。</p>
<h2 id="snmp">30.7 SNMP</h2>
<p>简单网络管理协议SNMP: 基于IP的网络管理的标准协议</p>
<h1 id="按作业内容">按作业内容</h1>
<h2 id="tcpip的分层模型">TCP/IP的分层模型</h2>
<p>物理层/网络接口层/网络层/传输层/应用层</p>
<h2 id="导线类型">导线类型</h2>
<ul>
<li>无屏蔽双绞线(UTP)</li>
<li>屏蔽双绞线(STP)</li>
<li>同轴电缆(CC)</li>
</ul>
<h2 id="通信卫星类型">通信卫星类型</h2>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>低地球轨道(LEO)</td>
<td>低时延</td>
<td>相对地球移动</td>
</tr>
<tr class="even">
<td>中地球轨道(MEO)</td>
<td>主要提供南北级通信</td>
<td>-</td>
</tr>
<tr class="odd">
<td>地球静止轨道(GEO)</td>
<td>相对地球静止</td>
<td>距离远</td>
</tr>
</tbody>
</table>
<h2 id="为什么要区分上下行通信">为什么要区分上下行通信</h2>
<p>大多数因特网用户都是按非对称（asymmetric）模式使用网络的，即典型的居民用户从因特网接收的数据要多于他们发送出去的数据。例如，为了浏览一个网页，浏览器发送一个只包含几个字节的 URL，而 Web 服务器响应回来的内容可能是包含几千字节的文本或者是一个包含好几万字节的图片。运行 Web 服务器的商业用户可能具有相反的流量模式——商业用户发送的数据要多于接收的数据。</p>
<h2 id="宽带与窄带">宽带与窄带</h2>
<p>窄带接入技术: - 拨号电话连接 - 使用调制解调器的租用电路 - 部分 T1 数据电路 - ISDN 及其他电信数据服务</p>
<p>宽带接入技术: - DSL 技术 - 电缆调制解调器技术 - 无线接入技术 - T1 速率或更高速率的数据线路</p>
<h2 id="section"></h2>
<h1 id="背背背">背背背</h1>
<h2 id="tcp的特征">TCP的特征</h2>
<ul>
<li>面向连接: TCP提供面向连接的服务, 应用程序必须首先请求建立一个到目的地的连接, 然后使用这个连接来传输数据</li>
<li>点对点通信: 每个TCP连接上只有两个端点</li>
<li>完全的可靠性: TCP能保证在一个连接上发送的数据被正确地传递, 且保证数据的完整和按序到达</li>
<li>全双工通信: TCP连接允许数据在任何一个方向上流动, 并允许任何应用程序在任何时刻发送数据</li>
<li>流接口: TCP提供一个流接口, 利用它应用进程可以在一个连接上发送连续的字节流. TCP不必将数据组合成记录或是报文, 也不要求传递给接收应用进程的数据段大小一定要与发送端所送出的数据段大小相同</li>
<li>可靠的连接建立: TCP允许两个应用进程可靠地开始通信</li>
<li>友好的连接关闭: 在关闭一个连接之前, TCP必须保证所有数据已经传递完毕, 并且通信双方都要同意关闭这个连接</li>
</ul>
<h2 id="udp的特征">UDP的特征</h2>
<ul>
<li>端到端: UDP 是一个传输协议，它能区分运行在给定计算机上的多个应用程序。</li>
<li>无连接: UDP 提供给应用的接口遵从无连接模式。</li>
<li>面向报文: 使用 UDP 的应用进程所发送和接收的数据是单个报文。</li>
<li>尽力而为: UDP 提供给应用的是与 IP 一样的尽力传递机制。</li>
<li>任意交互: UDP 允许应用进程给很多其他应用进程发送数据，也允许从很多其他应用进程那里接收数据，或者只跟一个其他应用进程相互通信。</li>
</ul>
<h2 id="服务端-客户端特征">服务端-客户端特征</h2>
<p>虽然存在少量的变种，但大多数客户——服务器交互模式都具有相同的一般特征。一般情况 下，客户软件具有如下特征： 1. 它是一个任意的应用程序，仅在需要进行远程访问时才暂时成为客户，同时还要完成其他的计算任务。 2. 直接受用户介入操作，并且只执行一个会话过程。 3. 在用户的个人计算机上进行本地运行。 4. 主动地发起与服务器的连接请求。 5. 能访问所需的多种服务，但通常一次只与一个远地服务器请求连接。 6. 不会特别地要求功能强大的计算机硬件。</p>
<p>而服务器软件的特征如下： 1. 它是一个专门提供某种服务的专用特权程序，但同时可以处理多个远程客户的请求。 2. 在系统启动时自动被调入执行，进行多次会话并持续不断地运行。 3. 运行在大型、高性能计算机上。 4. 被动地等待来自任意的远端客户的通信请求。 5. 接收来自任何客户的通信请求，但只提供单一的服务。 6. 要求功能强大的硬件和高级复杂的操作系统支持。</p>
<h2 id="section-1"></h2>
<h2 id="端口号">端口号</h2>
<p>FTP: 20/数据流, 21/控制流 TELNET: 23 SMTP: 25 DNS: 53 SNMP: 161/162</p>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>computer-networking</category>
      </categories>
  </entry>
  <entry>
    <title>考研总结1</title>
    <url>/2021/02/16/index/</url>
    <content><![CDATA[<h2 id="经验分享">经验分享:</h2>
<ul>
<li><a href="http://www.cskaoyan.com/thread-659004-1-1.html">2020浙江大学计算机考研初试428分经验分享（风华注：初试状元）</a></li>
</ul>
<h2 id="考试内容">考试内容</h2>
<table>
<thead>
<tr class="header">
<th>科目</th>
<th></th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>政治</td>
<td>101全国统一</td>
<td>100分</td>
</tr>
<tr class="even">
<td>英语</td>
<td>英语一/英语二</td>
<td>100分</td>
</tr>
<tr class="odd">
<td>数学</td>
<td>数学一/数学二</td>
<td>150分</td>
</tr>
<tr class="even">
<td>专业课</td>
<td>408/自主命题</td>
<td>150分</td>
</tr>
</tbody>
</table>
<p>408 = 数据结构 + 计组 + 操作系统 + 计算机网络</p>
<h2 id="时间轴">时间轴</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发布招生计划       9-10月</span><br><span class="line">报名时间           9-10月</span><br><span class="line">[!]考试(笔试)时间  12月末(大四上学期期末)</span><br><span class="line">初试成绩           2-3月</span><br><span class="line">复试时间           3-5月</span><br><span class="line">[!]offer发放       5-6月</span><br></pre></td></tr></table></figure>
<h2 id="考研趋势">考研趋势</h2>
<p>报考人数逐年升高</p>
<p>报考地区: 北上广,江苏湖北</p>
<p>专硕:学硕=7:3</p>
<p>77%的人来自双非院校</p>
<p>往届生比例与应届生几乎持平</p>
<p>2020报录比 4:1 20%</p>
<h2 id="考研择校">考研择校</h2>
<h2 id="学硕和专硕">学硕和专硕</h2>
<ul>
<li><p>学术型硕士</p>
<p>面向学术科研</p></li>
<li><p>专业型硕士</p>
<p>面向工作, 考试较为容易</p>
<p>学费贵, 奖学金少</p></li>
</ul>
<h2 id="信息搜集">信息搜集</h2>
<p>择校: 目标院校的历年报录比, 历年分数线, 推免人数</p>
<p>择专业: 参考书, 真题, 招生简章, 报考指南</p>
<p>经验: 网络</p>
<p>怎么搜集: - 目标院校招生信息网 - 研招网 - 论坛类(院校论坛等) - 知乎豆瓣微信QQ群</p>
<h2 id="备考计划">备考计划</h2>
<!-- 
2018.9 入学, 大一开始
 2019.3 大一下开始
2019.9 大二开始
 2020.3 大二下开始
2020.9 大三开始
-> 2021.3 大三下开始
2021.9 大四开始
=> 2021.12 考研!!
 2022.3 大四下开始
2022.9 毕业
 -->
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1-6月     数学 + 英语基础 + 专业课基础知识</span><br><span class="line">7-8月     数学刷题 + 专业课强化 + 政治基础课&amp;非主观题一刷 + 英语真题</span><br><span class="line">9-10月    (毕业)数学真题 + 政治非主观题二刷 + 专业课刷题&amp;知识点 + 英语真题</span><br><span class="line">11-12月   政治主观题 + 各科查缺补漏</span><br><span class="line">英语贯穿始终, 单词每日看</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">政治: 到3月甚至7月后准备都可</span><br><span class="line">英语: 某些企业对四六级成绩有要求, 背单词!</span><br><span class="line">数学: 先看同济高数/辅导书, 做课后习题, 特别是前几章, 刷题</span><br><span class="line">专业课: 刷OJ(如leetcode), 认真做课程项目(整理), 写代码实现常用数据结构, 对以后复试或者就业有帮助</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>kaoyan</category>
      </categories>
  </entry>
  <entry>
    <title>日本语1</title>
    <url>/2021/02/15/1/</url>
    <content><![CDATA[<h1 id="what-is-japanese">What is Japanese</h1>
<h2 id="japanese-sound-system">Japanese Sound System</h2>
<p>23 consonant sounds + 5 vowel sounds, with pitch accent</p>
<p>When spoken, the Japanese language is formed using either vowels or a consonant-vowel pair, except the "n" sound (single consonant sound)</p>
<h2 id="japanese-writing-system">Japanese Writing System</h2>
<p>Come around 1500 years age from China</p>
<p>Currentlt has 3 types of writing: hiragana, katakana, kanji</p>
<p>Kanji were imported from China, traditionally used for both meaning and sound.</p>
<p>Hiragana: 46 characters with two diacritical marks that are used to denote the sounds</p>
<p>Each hiragana symbolizes with a vowel or a consonant combined with a vowel.</p>
<p>Hiraganas are in particular used for function words and inflectional endings, as well as in some content words.</p>
<table>
<thead>
<tr class="header">
<th>Hiragana</th>
<th>ん</th>
<th>w</th>
<th>r</th>
<th>y</th>
<th>m</th>
<th>h</th>
<th>n</th>
<th>t</th>
<th>s</th>
<th>k</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>ん</td>
<td>わ</td>
<td>ら</td>
<td>や</td>
<td>ま</td>
<td>は</td>
<td>な</td>
<td>た</td>
<td>さ</td>
<td>か</td>
<td>あ</td>
</tr>
<tr class="even">
<td>i</td>
<td></td>
<td></td>
<td>り</td>
<td></td>
<td>み</td>
<td>ひ</td>
<td>に</td>
<td>ち</td>
<td>し</td>
<td>き</td>
<td>い</td>
</tr>
<tr class="odd">
<td>u</td>
<td></td>
<td></td>
<td>る</td>
<td>ゆ</td>
<td>む</td>
<td>ふ</td>
<td>ぬ</td>
<td>つ</td>
<td>す</td>
<td>く</td>
<td>う</td>
</tr>
<tr class="even">
<td>e</td>
<td></td>
<td></td>
<td>れ</td>
<td></td>
<td>め</td>
<td>へ</td>
<td>ね</td>
<td>て</td>
<td>せ</td>
<td>け</td>
<td>え</td>
</tr>
<tr class="odd">
<td>o</td>
<td></td>
<td>を</td>
<td>ろ</td>
<td>よ</td>
<td>も</td>
<td>ほ</td>
<td>の</td>
<td>と</td>
<td>そ</td>
<td>こ</td>
<td>お</td>
</tr>
</tbody>
</table>
<p>Katagana is also a syllabary, is used for loan words, onomatopoeic words and scientific words.</p>
]]></content>
      <categories>
        <category>misc</category>
        <category>japanese</category>
      </categories>
  </entry>
  <entry>
    <title>Learning Sciences —— 学习的科学</title>
    <url>/2021/02/15/index/</url>
    <content><![CDATA[<h1 id="学习的科学">学习的科学</h1>
<h2 id="引言">引言</h2>
<p>你是否有过这样的经历： - 同样是学习，不同的人的效率相差甚远 - 班级里，某个同学的成绩突飞猛进 - 背单词毫无章法 - 想学习一门新技能却感觉无从下手，最后不了了之</p>
<p>如果你对上一个问题的回答“是”，那么你是否想要知道其中的原因？既然知识可以被分门别类地总结，那么世界上有没有关于学习的知识呢？</p>
<p>我们从小到大做的最多也是最熟悉的一件事情就是“学习”。一直以来，我们都认为学习是一件简单的事情，但是事实真的如此吗，学习有没有什么方法呢。</p>
<p>目前可能要从以下几个方面入手： - 心理学方面 - 记忆规律方面 - 学习工具</p>
<h2 id="教学主义">教学主义</h2>
<p>我们今天的学校体系实际上是基于从未经过科学验证的常识性假设设计的，例如：</p>
<ul>
<li>知识（Knowledge）是一系列关于世界的事实（Facts）和解决问题的程序（Procedures）的集合。</li>
<li>学校教育的目标是使学生了解这些事实和程序。让一个人拥有大量这样的事实和程序时，他们就被认为是受过教育的。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>misc</category>
        <category>learn-sci</category>
      </categories>
  </entry>
  <entry>
    <title>LaTeX Render Test</title>
    <url>/2023/12/19/latex-test/</url>
    <content><![CDATA[<p><span class="math inline">\(\alpha \beta \gamma \rho \sigma \delta \epsilon\)</span></p>
<p><span class="math inline">\(\times \otimes \oplus \cup \cap\)</span></p>
<p><span class="math inline">\(&lt; &gt; \subset \supset \subseteq \supseteq\)</span></p>
<p><span class="math inline">\(\int \oint \sum \prod\)</span></p>
<p><span class="math display">\[
\begin{align*}
  f(x) &amp;= x^2\\
  g(x) &amp;= \frac{1}{x}\\
  F(x) &amp;= \int^a_b \frac{1}{3}x^3
\end{align*}
\]</span></p>
<p><span class="math display">\[
\left[
\begin{matrix}
1 &amp; 0\\
0 &amp; 1
\end{matrix}
\right]
\]</span></p>
<p><span class="math display">\[
 \thinspace A - B \thinspace 或 A \setminus B
\]</span></p>
<p><span class="math display">\[
\displaystyle \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} = 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\cdots} } } }
\]</span></p>
<p><span class="math display">\[
\displaystyle \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)
\]</span></p>
<p><span class="math display">\[
\displaystyle {1 +  \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots }= \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \quad\quad \text{for }\lvert q\rvert&lt;1.
\]</span></p>
<p><span class="math display">\[
\left(\beta m c^2 + c \left(\sum_{n=1}^3\alpha_n p_n\right)\right) \psi(x,t)
= i\hbar \frac{\partial \psi(x,t)}{\partial t}
\]</span></p>
]]></content>
      <categories>
        <category>misc</category>
        <category>self-test</category>
      </categories>
  </entry>
  <entry>
    <title>每日上报自动打卡</title>
    <url>/2020/12/25/auto_check/</url>
    <content><![CDATA[<h1 id="每日上报自动打卡程序">每日上报自动打卡程序</h1>
<figure class="highlight python"><figcaption><span>auto_check.py</span><a href="/downloads/code/auto_check.py">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse, error</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">token, param: <span class="built_in">dict</span> = {}</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;每日上报&#x27;&#x27;&#x27;</span></span><br><span class="line">    req = request.Request(<span class="string">&#x27;https://tjxsfw.chisai.tech/api/school_tjxsfw_student/yqfkLogDailyreport/v2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    req.add_header(<span class="string">&#x27;User-Agent&#x27;</span>, <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:78.0) Gecko/20100101 Firefox/78.0&#x27;</span>)</span><br><span class="line">    req.add_header(<span class="string">&#x27;Accept-Language&#x27;</span>, <span class="string">&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;</span>)</span><br><span class="line">    req.add_header(<span class="string">&#x27;Host&#x27;</span>, <span class="string">&#x27;tjxsfw.chisai.tech&#x27;</span>)</span><br><span class="line">    req.add_header(<span class="string">&#x27;Referer&#x27;</span>, <span class="string">&#x27;https://servicewechat.com/wx427cf6b5481c866a/27/page-frame.html&#x27;</span>)</span><br><span class="line">    req.add_header(<span class="string">&#x27;Authorization&#x27;</span>, <span class="string">f&#x27;Bearer <span class="subst">{token}</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    payload = parse.urlencode([</span><br><span class="line">        (<span class="string">&#x27;studentPid&#x27;</span>, param.get(<span class="string">&#x27;studentPid&#x27;</span>)),  <span class="comment"># pid</span></span><br><span class="line">        (<span class="string">&#x27;studentName&#x27;</span>, param.get(<span class="string">&#x27;studentName&#x27;</span>)),  <span class="comment"># 姓名</span></span><br><span class="line">        (<span class="string">&#x27;studentStudentno&#x27;</span>, param.get(<span class="string">&#x27;studentStudentno&#x27;</span>)),  <span class="comment"># 学号</span></span><br><span class="line">        (<span class="string">&#x27;studentCollege&#x27;</span>, param.get(<span class="string">&#x27;studentCollege&#x27;</span>, <span class="string">&#x27;软件学院&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locLat&#x27;</span>, param.get(<span class="string">&#x27;locLat&#x27;</span>, <span class="string">&#x27;31.37482&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locLng&#x27;</span>, param.get(<span class="string">&#x27;locLng&#x27;</span>, <span class="string">&#x27;121.26621&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locNation&#x27;</span>, param.get(<span class="string">&#x27;locNation&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locProvince&#x27;</span>, param.get(<span class="string">&#x27;locProvince&#x27;</span>, <span class="string">&#x27;上海市&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locCity&#x27;</span>, param.get(<span class="string">&#x27;locCity&#x27;</span>, <span class="string">&#x27;上海市&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locDistrict&#x27;</span>, param.get(<span class="string">&#x27;locDistrict&#x27;</span>, <span class="string">&#x27;嘉定区&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;healthy&#x27;</span>, param.get(<span class="string">&#x27;healthy&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;source&#x27;</span>, param.get(<span class="string">&#x27;source&#x27;</span>, <span class="string">&#x27;weixin,windows&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;reportDatetime&#x27;</span>, datetime.strftime(datetime.now(), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)),</span><br><span class="line">        (<span class="string">&#x27;hasMoved&#x27;</span>, param.get(<span class="string">&#x27;hasMoved&#x27;</span>, <span class="string">&#x27;false&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;leaveReason&#x27;</span>, param.get(<span class="string">&#x27;leaveReason&#x27;</span>, <span class="string">&#x27;&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locNation1&#x27;</span>, param.get(<span class="string">&#x27;locNation1&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locProvince1&#x27;</span>, param.get(<span class="string">&#x27;locProvince1&#x27;</span>, <span class="string">&#x27;上海市&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locCity1&#x27;</span>, param.get(<span class="string">&#x27;locCity1&#x27;</span>, <span class="string">&#x27;上海市&#x27;</span>))</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    res = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> request.urlopen(req, data=payload.encode()) <span class="keyword">as</span> f:</span><br><span class="line">            res = json.loads(f.read()) <span class="keyword">if</span> f.status == <span class="number">200</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请求失败&quot;</span>, e)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    token = <span class="string">&#x27;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjEyMzQ1Njc4OSwidXNlcl9uYW1lIjoic3dpZDB4eHh4eHh4eDZjNiIsImF1dGhvcml0aWVzIjpbImFwcF91c2VyIl0sImp0aSI6ImVjY3h4eHgteHh4eC14eHh4LTllN2IteHh4eHhkODRmYjgiLCJjbGllbnRfaWQiOiJhcHAiLCJzY29wZSI6WyJhbGwiXX0.xxxxxxxxxxxxxxxxxxxxxxxxr6d8D4&#x27;</span></span><br><span class="line"></span><br><span class="line">    param = {</span><br><span class="line">        <span class="string">&#x27;studentPid&#x27;</span>: <span class="string">&#x27;9999999&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;studentName&#x27;</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;studentStudentno&#x27;</span>: <span class="string">&#x27;1888888&#x27;</span></span><br><span class="line">    }</span><br><span class="line">    res = check(token, param)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>misc</category>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>考研201 英语一 大纲</title>
    <url>/2021/02/19/index/</url>
    <content><![CDATA[<h2 id="考察">考察</h2>
<p>选拔性考试</p>
<p>听说读写</p>
<p>初始不考听力</p>
<p>复试(面试)考察听力和口语</p>
<h2 id="题型">题型</h2>
<ol type="1">
<li><p>完型填空</p>
<p>20个空 10分</p></li>
<li><p>阅读理解</p>
<p>4篇文章*5小题 40分</p></li>
<li><p>新题型</p>
<p>七选五/排序题/标题匹配</p>
<p>10分</p></li>
<li><p>翻译</p>
<p>5句话(长难句) 10分</p></li>
<li><p>小作文</p>
<p>应用文(信/通知/备忘录/报告) 10分</p></li>
<li><p>大作文</p>
<p>20分</p></li>
</ol>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>kaoyan</category>
        <category>201</category>
      </categories>
  </entry>
  <entry>
    <title>考研301 数学一 大纲</title>
    <url>/2021/02/19/index/</url>
    <content><![CDATA[<h2 id="分值构成-数学一">分值构成 (数学一)</h2>
<ol type="1">
<li>高数 90分</li>
<li>线代 30分</li>
<li>概率论 30分</li>
</ol>
<h2 id="题型">题型</h2>
<p>一共22道题目</p>
<ol type="1">
<li><p>单选</p>
<p>10小题 50分 —— 考基本概念, 性质</p></li>
<li><p>填空</p>
<p>6小题 30分 —— 考运算, 方法</p>
<p>注重准确率!</p></li>
<li><p>解答题(包括证明)</p>
<p>6大题 70分 —— 综合性</p></li>
</ol>
<h2 id="大纲新增">21大纲新增</h2>
<ol type="1">
<li>反常积分比较判别法</li>
<li>无穷级数积分判别法</li>
</ol>
]]></content>
      <categories>
        <category>course-notes</category>
        <category>kaoyan</category>
        <category>301</category>
      </categories>
  </entry>
</search>
