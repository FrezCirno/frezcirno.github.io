<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Oracle APEX学习</title>
    <url>/oracle-apex.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么垃圾软件, 毁我人生!!</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>略</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>启动apex安装到的数据库(PDB默认不会自动open)</p>
<p>启动ords服务</p>
<p><code>$ java -jar ords.war</code></p>
<h1 id="怎么修改密码"><a href="#怎么修改密码" class="headerlink" title="怎么修改密码"></a>怎么修改密码</h1><p><code>SQL&gt; @apxchpwd.sql</code></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title>Oracle数据库学习</title>
    <url>/oracledb.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考资料:</p>
<p><a href="https://docs.oracle.com/en/database/oracle/oracle-database/index.html">Oracle官方文档</a></p>
<h1 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h1><p>Schema是表, 索引, 存储过程等等数据库对象(DB Object)的存储容器</p>
<p>用户与Schema之间是<strong>一对一</strong>的关系</p>
<p>例如: 访问用户A的xxx对象就通过 <code>A.xxx</code></p>
<p><img src="oracledb/user-schema-tables.png" alt=""></p>
<h1 id="Oracle-表空间"><a href="#Oracle-表空间" class="headerlink" title="Oracle 表空间"></a>Oracle 表空间</h1><p>表空间是逻辑上, 存放数据表的容器</p>
<p>每张表一定属于某个表空间</p>
<p>每个用户(Schema)可以拥有多个表空间, 而且都有一个默认表空间</p>
<p>用户之间可以通过共享表空间的方式共享数据表</p>
<p>物理上, 表空间的存储可能不是连续的</p>
<h1 id="PL-SQL"><a href="#PL-SQL" class="headerlink" title="PL/SQL"></a>PL/SQL</h1><ul>
<li>A primary benefit of PL/SQL is the ability to store application logic in the database itself.</li>
</ul>
<h1 id="Oracle-体系结构-重要"><a href="#Oracle-体系结构-重要" class="headerlink" title="Oracle 体系结构 (重要)"></a>Oracle 体系结构 (重要)</h1><ul>
<li>Oracle Server = Oracle Instance + Oracle Database</li>
</ul>
<h2 id="1-Oracle实例-Oracle-Instance"><a href="#1-Oracle实例-Oracle-Instance" class="headerlink" title="1. Oracle实例 (Oracle Instance)"></a>1. Oracle实例 (Oracle Instance)</h2><p>Oracle Instance = SGA(system global area) + Background Process</p>
<p>是一组<strong>OS进程(线程)和一些内存(SGA)</strong>的总称</p>
<p>可以用来mount和open一个数据库</p>
<p>一个实例在其生存期中最多只能装载和打开一个数据库。要想再打开这个（或其他）数据库，必须先丢弃这个实例，并创建一个新的实例。</p>
<p>一个数据库实例的状态分为以下几种</p>
<ul>
<li><p><code>started</code></p>
</li>
<li><p><code>mounted</code></p>
</li>
<li><p><code>open</code></p>
</li>
<li><p><code>close</code></p>
</li>
<li><p><code>mounted</code></p>
</li>
<li><p><code>open</code></p>
</li>
</ul>
<h3 id="started-状态"><a href="#started-状态" class="headerlink" title="started 状态"></a><code>started</code> 状态</h3><p>在执行<code>startup nomount</code>命令后, Oracle会执行以下操作, 之后实例会进入<code>started</code>状态, 此时实例还未绑定数据库</p>
<ul>
<li><p>读取配置文件</p>
</li>
<li><p>分配<code>SGA</code></p>
</li>
<li><p>启动后台进程</p>
</li>
<li><p>打开一些用于记录的文件</p>
</li>
</ul>
<h3 id="mounted-状态"><a href="#mounted-状态" class="headerlink" title="mounted 状态"></a><code>mounted</code> 状态</h3><p>在执行<code>startup mount</code>或者<code>alter database mount</code>命令后, 实例会进入<code>mounted</code>状态, 对应数据库的open_mode也是<code>mounted</code>。</p>
<p>数据库打开后, 执行<code>alter database close</code>命令后, 实例也会进入<code>mounted</code>状态, 对应数据库的open_mode也是<code>mounted</code>。</p>
<p>此时实例与数据库建立了联系, 但是只有DBA能够访问数据库。</p>
<h3 id="open-状态"><a href="#open-状态" class="headerlink" title="open 状态"></a><code>open</code> 状态</h3><p>在执行<code>startup</code>或者<code>alter database open</code>命令后, 实例会进入<code>open</code>状态。</p>
<p>此时实例与数据库建立了联系, 数据库完全启动, 普通用户也可以访问数据库。</p>
<h2 id="2-Oracle数据库-Oracle-Database"><a href="#2-Oracle数据库-Oracle-Database" class="headerlink" title="2. Oracle数据库 (Oracle Database)"></a>2. Oracle数据库 (Oracle Database)</h2><p>Oracle Database = Controlfile + datafile + logfile + spfile + …</p>
<p>是存储在<strong>磁盘</strong>上的<strong>一组数据文件</strong>的集合</p>
<p>一般来说, 一个数据库上只有一个实例对其进行操作</p>
<p>但是也有例外: RAC（Real Application Clusters）就允许在集群环境中的多台计算机上操作，这样就可以有多台实例同时装载并打开一个数据库（位于一组共享物理磁盘上）</p>
<p>例外2: 容器式数据库</p>
<h2 id="3-Oracle数据库和Oracle实例的关系"><a href="#3-Oracle数据库和Oracle实例的关系" class="headerlink" title="3. Oracle数据库和Oracle实例的关系"></a>3. <em>Oracle数据库</em>和<em>Oracle实例</em>的关系</h2><ol>
<li><p>一个实例一生只能够装载及打开一个数据库  </p>
</li>
<li><p>一个数据库能够被多个实例装载并打开(RAC)</p>
</li>
<li><p>每个运行着的数据库一定与至少一个实例关联</p>
</li>
</ol>
<p><img src="oracledb/instance-and-database.png" alt=""></p>
<p>Oracle数据库与实例的启动过程</p>
<p><img src="oracledb/startup-sequence.png" alt=""></p>
<p>Oracle数据库与实例的关闭过程</p>
<p><img src="oracledb/shutdown-sequence.png" alt=""></p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul>
<li><p>名称, 版本信息查看</p>
<ul>
<li><p>查询数据库版本信息</p>
<p>  <code>SQL&gt; select * from v$version;</code></p>
</li>
<li><p>查看数据库名称</p>
<p>  <code>SQL&gt; show parameter db_name;</code></p>
</li>
<li><p>查看数据库服务名</p>
<p>  <code>SQL&gt; show parameter service_names;</code></p>
</li>
<li><p>查询全局数据库名称</p>
<p>  <code>SQL&gt; select * from global_name;</code></p>
</li>
</ul>
</li>
<li><p>数据库实例 (Instance)</p>
<ul>
<li><p>查询当前数据库实例名称</p>
<p>  <code>SQL&gt; select instance_name from v$instance;</code></p>
</li>
<li><p>查看当前数据库实例状态(open/mount等)</p>
<p>  <code>SQL&gt; select status from v$instance;</code></p>
</li>
<li><p>查看数据库实例启动时间</p>
<p>  <code>SQL&gt; SELECT TO_CHAR(STARTUP_TIME,&#39;MON-DD-RR HH24:MI:SS&#39;) AS &quot;Inst Start Time&quot; FROM V$INSTANCE;</code></p>
</li>
<li><p>创建一个新的数据库实例、加载数据库、打开数据库 (需要DBA权限)</p>
<p>  <code>SQL&gt; startup [nomount | mount | open];</code></p>
</li>
<li><p>关闭实例绑定的数据库、卸载数据库、结束当前实例 (需要DBA权限)</p>
<p>  <code>SQL&gt; shutdown [normal | transactional | immediate];</code></p>
</li>
<li><p>关闭实例绑定的数据库、卸载数据库</p>
<p>  <code>SQL&gt; alter database close;</code></p>
</li>
<li><p>加载数据库/打开数据库</p>
<p>  <code>SQL&gt; alter database [mount | open];</code></p>
</li>
</ul>
</li>
<li><p>数据库设置, 统计信息等</p>
<ul>
<li><p>查询数据库打开模式(mounted/open/read write)</p>
<p>  <code>SQL&gt; select open_mode from v$database;</code></p>
</li>
<li><p>查看数据库DBF文件位置</p>
<p>  <code>SQL&gt; select name from v$datafile;</code></p>
</li>
<li><p>查询数据文件状态</p>
<p>  <code>SQL&gt; select file#,name,status,enabled,checkpoint_change# from v$datafile;</code></p>
</li>
<li><p>查询数据文件位置</p>
<p>  <code>SQL&gt; select name from v$datafile;</code></p>
</li>
<li><p>查询数据文件（表空间）大小</p>
<p>  <code>SQL&gt; select sum(bytes)/1024/1024/1024 as GB from v$datafile;</code></p>
</li>
<li><p>查询有效数据大小</p>
<p>  <code>SQL&gt; select sum(bytes)/1024/1024/1024 as GB from dba_segments;</code></p>
</li>
<li><p>查看当前库的所有数据表</p>
<p>  <code>SQL&gt; select TABLE_NAME from all_tables;</code></p>
</li>
</ul>
</li>
<li><p>可插拔数据库 (PDB) 管理</p>
<ul>
<li><p>查看数据库是CDB还是传统DB</p>
<p>  <code>SQL&gt; select name, cdb, open_mode, con_id from v$database;</code></p>
</li>
<li><p>查看当前容器 (CDB) 名</p>
<p>  <code>SQL&gt; show con_name;</code></p>
</li>
<li><p>列举当前容器中的所有PDB以及状态</p>
<p>  <code>SQL&gt; select con_id, dbid, guid, name, open_mode from v$pdbs;</code></p>
</li>
<li><p>切换到某个PDB</p>
<p>  <code>SQL&gt; alter session set container=&lt;PDB&gt;;</code></p>
</li>
<li><p>启动PDB数据库</p>
<p>  <code>SQL&gt; alter pluggable database &lt;PDB&gt; open;</code></p>
<p>  或者</p>
<p>  <code>SQL&gt; alter session set container=&lt;PDB&gt;;</code><br>  <code>SQL&gt; startup</code></p>
</li>
<li><p>关闭PDB数据库</p>
<p>  <code>SQL&gt; alter pluggable database &lt;PDB&gt; close;</code></p>
</li>
</ul>
</li>
<li><p>用户管理</p>
<ul>
<li>创建用户</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title>1032. Sharing</title>
    <url>/PTA/1032.html</url>
    <content><![CDATA[<p>寻找最长公共后缀</p>
<p>注意:<br>边界情况: 两条链没有交集, 其中一条链是另一条链的子链</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">ERR</span><span class="params">(T x, <span class="built_in">string</span> name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[DEBUG]&#123;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#125; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> debug(x) ERR(x, #x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> debug(...) 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">pair</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    freopen(__FILE__ <span class="string">&quot;.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">// freopen(__FILE__ &quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> w1, w2;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w1 &gt;&gt; w2 &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> a, b;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; c &gt;&gt; b;</span><br><span class="line">        M[a] = <span class="built_in">make_pair</span>(c, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; s1, s2;</span><br><span class="line">    debug(<span class="string">&quot;s1&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">string</span> addr = w1; addr != <span class="string">&quot;-1&quot;</span>; addr = M[addr].second) &#123;</span><br><span class="line">        s1.push(addr);</span><br><span class="line">        debug(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    debug(<span class="string">&quot;s2&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">string</span> addr = w2; addr != <span class="string">&quot;-1&quot;</span>; addr = M[addr].second) &#123;</span><br><span class="line">        s2.push(addr);</span><br><span class="line">        debug(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> top = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (s1.size() &amp;&amp; s2.size() &amp;&amp; s1.top() == s2.top()) &#123;</span><br><span class="line">        top = s1.top();</span><br><span class="line">        debug(top);</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; top &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1035. Password</title>
    <url>/PTA/1035.html</url>
    <content><![CDATA[<p>水题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ostringstream</span> out;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> name, pass;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; pass;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;ch : pass) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: ch = <span class="string">&#x27;L&#x27;</span>; flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: ch = <span class="string">&#x27;@&#x27;</span>; flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: ch = <span class="string">&#x27;%&#x27;</span>; flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: ch = <span class="string">&#x27;o&#x27;</span>; flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            mod++;</span><br><span class="line">            out &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pass &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mod) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; mod &lt;&lt; <span class="built_in">endl</span> &lt;&lt; out.str();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;There &quot;</span> &lt;&lt; (n == <span class="number">1</span> ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;are&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; account&quot;</span></span><br><span class="line">             &lt;&lt; (n == <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;s&quot;</span>) &lt;&lt; <span class="string">&quot; and no account is modified&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1036. Boys vs Girls</title>
    <url>/PTA/1036.html</url>
    <content><![CDATA[<p>送分题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> major;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    student s, male_min, female_max;</span><br><span class="line">    <span class="keyword">int</span> score, male_score_min = <span class="number">101</span>, female_score_max = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">string</span> gender;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s.name &gt;&gt; gender &gt;&gt; s.major &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (gender == <span class="string">&quot;M&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (score &lt; male_score_min) &#123;</span><br><span class="line">                male_min = s;</span><br><span class="line">                male_score_min = score;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (score &gt; female_score_max) &#123;</span><br><span class="line">                female_max = s;</span><br><span class="line">                female_score_max = score;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (female_score_max != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; female_max.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; female_max.major &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Absent&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (male_score_min != <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; male_min.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; male_min.major &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Absent&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (female_score_max != <span class="number">-1</span> &amp;&amp; male_score_min != <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; female_score_max - male_score_min &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NA&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1046. Shortest Distance</title>
    <url>/PTA/1046.html</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>仅由一个环的图, 求任意两个节点之间的最短距离</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将环剪开成一条线, 记录每个节点距离起始节点的距离, 查询时取两个方向的距离的最小值</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>意外的很简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    freopen(__FILE__ <span class="string">&quot;.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> dist;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; dist;</span><br><span class="line">        D[i + <span class="number">1</span>] = D[i] + dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = D[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            swap(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; min(D[y - <span class="number">1</span>] - D[x - <span class="number">1</span>], len - D[y - <span class="number">1</span>] + D[x - <span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1048. Find Coins</title>
    <url>/PTA/1048.html</url>
    <content><![CDATA[<p>寻找{(x,y)|x+y=m,x,y∈S}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        S[x]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;k : S) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = k.first;</span><br><span class="line">        <span class="keyword">int</span> y = m - x;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y &amp;&amp; S.find(y) != S.end() || x == y &amp;&amp; S[x] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!minx || x &lt; minx)</span><br><span class="line">                minx = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minx) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; minx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m - minx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1055. The World&#39;s Richest</title>
    <url>/PTA/1055.html</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>数据表按照某一列筛选后按另一列排序输出, 重复多次</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>按照输出的最大数量缩减原数据表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> worth;</span><br><span class="line">    person(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="keyword">int</span> &amp;age, <span class="keyword">const</span> <span class="keyword">int</span> &amp;worth)</span><br><span class="line">        : name(name), age(age), worth(worth)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;person&gt; P;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">int</span> worth;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; age &gt;&gt; worth;</span><br><span class="line">        P.emplace_back(name, age, worth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(P.begin(), P.end(), [](<span class="keyword">const</span> person &amp;p1, <span class="keyword">const</span> person &amp;p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> (p1.worth != p2.worth ?</span><br><span class="line">                    p1.worth &gt; p2.worth :</span><br><span class="line">                    (p1.age != p2.age ? p1.age &lt; p2.age : p1.name &lt; p2.name));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;person&gt; P1;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; AgeCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AgeCount[P[i].age] &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            AgeCount[P[i].age]++;</span><br><span class="line">            P1.emplace_back(P[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> m, amin, amax, count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; amin &gt;&gt; amax;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;p : P1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.age &gt;= amin &amp;&amp; p.age &lt;= amax) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.worth &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count &gt;= m)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;None&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1063. Set Similarity</title>
    <url>/PTA/1063.html</url>
    <content><![CDATA[<p>给出n个集合和k次查询, 计算集合相似度:</p>
<blockquote>
<p>集合相似度 = 交集元素数量 / 并集元素数量</p>
</blockquote>
<p>思路: 重复查询缓存结果</p>
<p>tips: </p>
<ul>
<li>C++ STL中有<code>set_intersection</code>, <code>set_union</code>, <code>set_difference</code>可以直接使用</li>
<li>insert_iterator<Container>(Container container, Iterator iter)可以创建一个”自动插入迭代器”, 将对迭代器的copy(to)操作转化为插入操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">float</span> F[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (F[_a][_b]) &#123;</span><br><span class="line">        <span class="keyword">return</span> F[_a][_b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;a = S[_a], &amp;b = S[_b];</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; U, I;</span><br><span class="line">    set_intersection(a.begin(), a.end(), b.begin(), b.end(), insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt;(I, I.begin()));</span><br><span class="line">    set_union(a.begin(), a.end(), b.begin(), b.end(), insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt;(U, U.begin()));</span><br><span class="line">    <span class="keyword">float</span> res = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(I.size()) / U.size();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) res = <span class="number">0.0001F</span>;</span><br><span class="line">    <span class="keyword">return</span> F[_a][_b] = F[_b][_a] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            S[i].insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.1f%%\n&quot;</span>, <span class="number">100</span> * compare(a - <span class="number">1</span>, b - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1093. Count PAT&#39;s</title>
    <url>/PTA/1093.html</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>计算<code>PAT</code>字串个数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划?</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>增加一个</th>
<th><code>PAT</code>个数</th>
<th><code>PA</code>个数</th>
<th><code>P</code>个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>不变</td>
<td>不变</td>
<td>增加1</td>
</tr>
<tr>
<td>A</td>
<td>不变</td>
<td>增加前面的<code>P</code>的个数</td>
<td>不变</td>
</tr>
<tr>
<td>T</td>
<td>增加前面的<code>PA</code>字串的个数</td>
<td>不变</td>
<td>不变</td>
</tr>
</tbody>
</table>
</div>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    ll p = <span class="number">0</span>, pa = <span class="number">0</span>, pat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>: p++; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: pa = (pa + p) % <span class="number">1000000007</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: pat = (pat + pa) % <span class="number">1000000007</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pat % <span class="number">1000000007</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1098. Insertion or Heap Sort</title>
    <url>/PTA/1098.html</url>
    <content><![CDATA[<p>根据排序的中间结果判断使用的插入排序还是堆排序, 并给出下一轮迭代的中间结果</p>
<p>堆排序: 先逐步构造一个大顶堆, 再每次从堆中取出最大的元素放到堆后面</p>
<p>思路:<br>插入排序的特点: 前面递增, 后面和原数组一样</p>
<p>进行1次插排: sort<br>进行1次堆排: pop_heap</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; n &amp;&amp; b[p - <span class="number">1</span>] &lt;= b[p])</span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">int</span> index = p;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; n &amp;&amp; a[p] == b[p])</span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">if</span> (p == n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insertion Sort&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sort(b, b + index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Heap Sort&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> p = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; <span class="number">1</span> &amp;&amp; b[p] &gt;= b[<span class="number">1</span>])</span><br><span class="line">            p--;</span><br><span class="line">        pop_heap(b, b + p + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    freopen(__FILE__ <span class="string">&quot;.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1099. Build A Binary Search Tree</title>
    <url>/PTA/1099.html</url>
    <content><![CDATA[<p>给出二叉树结构和节点的值列表, 将值填入二叉树中, 输出层次序遍历的结果</p>
<p>考点: 二叉树的直接后继</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">ERR</span><span class="params">(T x, <span class="built_in">string</span> name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[DEBUG]&#123;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#125; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> debug(x) ERR(x, #    x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> debug(...) 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> left, right, parent;</span><br><span class="line">&#125; N[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    freopen(__FILE__ <span class="string">&quot;.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">// freopen(__FILE__ &quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    N[<span class="number">0</span>].parent = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        N[i].left = l;</span><br><span class="line">        N[l].parent = i;</span><br><span class="line">        N[i].right = r;</span><br><span class="line">        N[r].parent = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">        vals.push_back(val);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vals.begin(), vals.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (N[p].left != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N[p].left != <span class="number">-1</span>)</span><br><span class="line">            p = N[p].left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        debug(p);</span><br><span class="line">        N[p].val = vals.front();</span><br><span class="line">        vals.erase(vals.begin());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N[p].right != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// right down</span></span><br><span class="line">            p = N[p].right;</span><br><span class="line">            <span class="keyword">while</span> (N[p].left != <span class="number">-1</span>) &#123;</span><br><span class="line">                p = N[p].left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N[p].parent != <span class="number">-1</span> &amp;&amp; N[N[p].parent].left == p) &#123;</span><br><span class="line">            <span class="comment">// right up</span></span><br><span class="line">            p = N[p].parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (N[p].parent != <span class="number">-1</span> &amp;&amp; N[N[p].parent].right == p) &#123;</span><br><span class="line">                p = N[p].parent;</span><br><span class="line">            &#125;</span><br><span class="line">            p = N[p].parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (Q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (!first)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            first = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; N[top].val;</span><br><span class="line">        <span class="keyword">if</span> (N[top].left != <span class="number">-1</span>)</span><br><span class="line">            Q.push(N[top].left);</span><br><span class="line">        <span class="keyword">if</span> (N[top].right != <span class="number">-1</span>)</span><br><span class="line">            Q.push(N[top].right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1104. Sum of Number Segments</title>
    <url>/PTA/1104.html</url>
    <content><![CDATA[<p>数学题</p>
<h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>给定一个数组, 计算该数组所有子序列的和的和, 即</p>
<script type="math/tex; mode=display">
\begin{aligned}
S&=\sum_{i=1}^{n}\sum_{j=i}^{n}{\sum_{k=i}^{j}{a_{k}}}
\\&=\sum_{i=1}^{n}\sum_{j=i}^{n}{\sum_{k=i}^{j}{a_{k}}}
\end{aligned}</script><h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>对于任意$x\in{[1,n]}$, $a_{x}$被计算的次数</p>
<p>就等于集合${(i,j)|1 \le i \le j \le n}$中$i \le x \le j$的次数</p>
<p>即</p>
<script type="math/tex; mode=display">
\begin{aligned}
C_{x}&=\sum_{i=1}^{x}{\sum_{j=x}^{n}{1}} \\
&=\sum_{i=1}^{x}{(n-x+1)} \\
&=x(n-x+1)
\end{aligned}</script><p>总和</p>
<script type="math/tex; mode=display">
\begin{aligned}
S&=\sum_{i=1}^{n}{C_{i}a_{i}}\\
&=\sum_{i=1}^{n}{(i(n-i+1)a_{i})}\\
\end{aligned}</script><p>实测: 高精度?<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        res += (<span class="keyword">long</span> <span class="keyword">long</span>)(<span class="number">1000</span> * x) * i * (n - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, res / <span class="number">1000.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1109. Group Photo</title>
    <url>/PTA/1109.html</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><ol>
<li>将N个人按照身高排成K行</li>
<li>每行N/K个人, </li>
<li>后排的人比前排的人高</li>
<li>每一排之中, 最高的人在中间, 然后依次在左,右排列 </li>
<li>相同身高的人按字典序排列</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用deque模拟一排</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; person;</span><br><span class="line">    <span class="built_in">vector</span>&lt;person&gt; P;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; height;</span><br><span class="line">        P.emplace_back(name, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(P.begin(), P.end(), [](<span class="keyword">const</span> person &amp;p1, <span class="keyword">const</span> person &amp;p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.second != p2.second ? p1.second &gt; p2.second :</span><br><span class="line">                                        p1.first &lt; p2.first;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rowcount = n / k;</span><br><span class="line">    <span class="keyword">int</span> rest = n % k;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; row;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, left = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left)</span><br><span class="line">            row.push_back(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            row.push_front(i);</span><br><span class="line">        left = <span class="number">1</span> - left;</span><br><span class="line">        <span class="keyword">if</span> (row.size() == rowcount + rest) &#123;</span><br><span class="line">            rest = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;i : row) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; (first ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; &quot;</span>) &lt;&lt; P[i].first;</span><br><span class="line">                first = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            row.clear();</span><br><span class="line">            left = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;i : row) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (first ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; &quot;</span>) &lt;&lt; P[i].first;</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1115. Counting Nodes in a BST</title>
    <url>/PTA/1115.html</url>
    <content><![CDATA[<p>按给定序列构造一个二叉搜索树, 分别计算最低两层的节点数量</p>
<p>思路: 如题, 考基本功</p>
<p>注意: 一种新奇的写法, 获取倒数第n个元素 (想到了Python是不是XD)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector&lt;int&gt; x;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x.end()[-n] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><br>代码(有内存泄漏):<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    node *left, *right, *parent;</span><br><span class="line">&#125; root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.parent) &#123;</span><br><span class="line">        <span class="comment">// is the first root</span></span><br><span class="line">        root.parent = &amp;root;</span><br><span class="line">        root.val = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node *p = &amp;root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= p-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; p-&gt;val) &#123;</span><br><span class="line">        p-&gt;right = <span class="keyword">new</span> node();</span><br><span class="line">        p-&gt;right-&gt;val = x;</span><br><span class="line">        p-&gt;right-&gt;parent = p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;left = <span class="keyword">new</span> node();</span><br><span class="line">        p-&gt;left-&gt;val = x;</span><br><span class="line">        p-&gt;left-&gt;parent = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trav</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node *&gt; Q;</span><br><span class="line">    <span class="keyword">if</span> (root.parent) &#123;</span><br><span class="line">        Q.push(&amp;root);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.push(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> lcount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counts;</span><br><span class="line">    <span class="keyword">while</span> (Q.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        node *x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            counts.push_back(lcount);</span><br><span class="line">            lcount = <span class="number">0</span>;</span><br><span class="line">            Q.push(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lcount++;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;left)</span><br><span class="line">            Q.push(x-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;right)</span><br><span class="line">            Q.push(x-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    counts.push_back(lcount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> back = counts.size() ? counts.back() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> back2 = counts.size() &gt; <span class="number">2</span> ? counts.end()[<span class="number">-2</span>] : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; back &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; back2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; back + back2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        insert(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trav();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1123. Is It a Complete AVL Tree</title>
    <url>/PTA/1123.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>按输入序列构造AVL树, 输出层次序遍历的结果, 和AVL树是否为完全二叉树</p>
<h2 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧:"></a>一些小技巧:</h2><h3 id="1-树的初始化问题"><a href="#1-树的初始化问题" class="headerlink" title="1. 树的初始化问题"></a>1. 树的初始化问题</h3><p>我们可以让insert函数返回插入后新的树根(从而可以递归调用), 调用时采用 <code>node = insert(node, val)</code> 的方式, 从而统一了第一个节点和其他节点的处理, 极大地简化了判断逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">insert</span><span class="params">(node* p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">        p=<span class="keyword">new</span> node();</span><br><span class="line">        p-&gt;val=x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;p-&gt;val)&#123;</span><br><span class="line">        p-&gt;left=insert(p-&gt;left,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;right=insert(p-&gt;right,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node*root=<span class="literal">nullptr</span>;</span><br><span class="line">    root=insert(root,<span class="number">1</span>);</span><br><span class="line">    root=insert(root,<span class="number">2</span>);</span><br><span class="line">    root=insert(root,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="体会"><a href="#体会" class="headerlink" title="体会:"></a>体会:</h2><ol>
<li>KISS, 简单的才是最好的</li>
<li>用好递归能节约大量代码</li>
<li>数据结构题不必在性能上过多纠结</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>(部分参考自网络)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    node *left = <span class="literal">nullptr</span>, *right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p ? <span class="number">1</span> + max(depth(p-&gt;left), depth(p-&gt;right)) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">rr</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *lc = p-&gt;left;</span><br><span class="line">    p-&gt;left = lc-&gt;right;</span><br><span class="line">    lc-&gt;right = p;</span><br><span class="line">    <span class="keyword">return</span> lc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">lr</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *rc = p-&gt;right;</span><br><span class="line">    p-&gt;right = rc-&gt;left;</span><br><span class="line">    rc-&gt;left = p;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">lrr</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;left = lr(p-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> rr(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">rlr</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;right = rr(p-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> lr(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">insert</span><span class="params">(node *p, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> node();</span><br><span class="line">        p-&gt;val = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; p-&gt;val) &#123;</span><br><span class="line">        p-&gt;left = insert(p-&gt;left, x);</span><br><span class="line">        <span class="keyword">if</span> (depth(p-&gt;left) - depth(p-&gt;right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; p-&gt;left-&gt;val)</span><br><span class="line">                p = rr(p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = lrr(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;right = insert(p-&gt;right, x);</span><br><span class="line">        <span class="keyword">if</span> (depth(p-&gt;left) - depth(p-&gt;right) &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; p-&gt;right-&gt;val)</span><br><span class="line">                p = lr(p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = rlr(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trav</span><span class="params">(node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> empty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> comp = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node *&gt; Q;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        Q.push(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Q.size()) &#123;</span><br><span class="line">        node *top = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; top-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (top-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                comp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.push(top-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            empty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (top-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                comp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.push(top-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            empty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; (comp ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        root = insert(root, x);</span><br><span class="line">    &#125;</span><br><span class="line">    trav(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1140. Look-and-say Sequence</title>
    <url>/PTA/1140.html</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求一个数字用行程编码压缩n-1次的结果</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">compress</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n || i &gt; <span class="number">0</span> &amp;&amp; s[i] != s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            res.push_back(s[i - <span class="number">1</span>]);</span><br><span class="line">            res += to_string(count);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s = compress(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>1151. LCA in a Binary Tree</title>
    <url>/PTA/1151.html</url>
    <content><![CDATA[<p>二叉树上寻找最近公共祖先</p>
<p>需要注意节点的key不一定连续</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right, parent, depth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, node&gt; N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator &amp;preord_b,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator &amp;preord_e,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator &amp;inord_b,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator &amp;inord_e,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> parent,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preord_b == preord_e)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> key = *preord_b;</span><br><span class="line">    <span class="keyword">auto</span> inord_mid = find(inord_b, inord_e, key);</span><br><span class="line">    <span class="keyword">int</span> left_len = inord_mid - inord_b;</span><br><span class="line">    N[key].left = build(preord_b + <span class="number">1</span>, preord_b + <span class="number">1</span> + left_len, inord_b,</span><br><span class="line">        inord_mid, key, depth + <span class="number">1</span>);</span><br><span class="line">    N[key].right = build(preord_b + <span class="number">1</span> + left_len, preord_e, inord_mid + <span class="number">1</span>,</span><br><span class="line">        inord_e, key, depth + <span class="number">1</span>);</span><br><span class="line">    N[key].parent = parent;</span><br><span class="line">    N[key].depth = depth;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N[a].depth &gt; N[b].depth) &#123;</span><br><span class="line">        <span class="keyword">return</span> lca(N[a].parent, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N[a].depth &lt; N[b].depth) &#123;</span><br><span class="line">        <span class="keyword">return</span> lca(N[b].parent, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lca(N[a].parent, N[b].parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; inord(n), preord(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; inord[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; preord[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root =</span><br><span class="line">        build(preord.begin(), preord.end(), inord.begin(), inord.end(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">bool</span> e1 = (N.find(u) == N.end());</span><br><span class="line">        <span class="keyword">bool</span> e2 = (N.find(v) == N.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e1 &amp;&amp; e2) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; are not found.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e1 || e2) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; (e1 ? u : v) &lt;&lt; <span class="string">&quot; is not found.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = lca(u, v);</span><br><span class="line">        <span class="keyword">if</span> (a == u || a == v) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; is an ancestor of &quot;</span> &lt;&lt; (a == u ? v : u) &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">                 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LCA of &quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">                 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>每日 PTA</title>
    <url>/PTA/index.html</url>
    <content><![CDATA[<p>leetcode medium 纯算法题偏少, 准备每日加一道PTA.</p>
<p><strong>目标</strong>: 每天一道PTA甲级 [PAT (Advanced Level) Practice]</p>
<p>题号就roll一个<a href="http://katty.top:8888/api/rand?from=1&amp;to=156">随机数</a></p>
]]></content>
      <categories>
        <category>PTA</category>
      </categories>
  </entry>
  <entry>
    <title>目标代码生成</title>
    <url>/compiler-principle/codegen.html</url>
    <content><![CDATA[<h1 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><pre><code>中间代码 --&gt; 代码生成器 --&gt; 目标程序
                ^
                |
            符号表
</code></pre><h2 id="目标代码的三种形式"><a href="#目标代码的三种形式" class="headerlink" title="目标代码的三种形式:"></a>目标代码的三种形式:</h2><ol>
<li>能立即执行的机器码(所有地址已经定位)</li>
<li>待装配的机器语言模块(连接装入后即可执行)</li>
<li>汇编语言代码(经汇编程序汇编后即可执行)</li>
</ol>
<p>此处选择汇编语言</p>
<h2 id="目标机器模型"><a href="#目标机器模型" class="headerlink" title="目标机器模型"></a>目标机器模型</h2><p>此处假设目标计算机:</p>
<ol>
<li>具有多个通用寄存器, 可以用来运算, 也可以用来取地址</li>
<li>支持四种指令形式<ol>
<li>直接地址型 <code>OP R, M</code> - <code>R OP M =&gt; R</code></li>
<li>寄存器型 <code>OP Ri, Rj</code> - <code>Ri OP Rj =&gt; Ri</code></li>
<li>变址型 <code>OP Ri, c(Rj)</code> - <code>Ri OP (Rj+c) =&gt; Ri</code></li>
<li>间接型<ol>
<li><code>OP Ri, (M)</code> - <code>R OP (M) =&gt; R</code></li>
<li><code>OP Ri, (Rj)</code> - <code>Ri OP (Rj) =&gt; Ri</code></li>
<li><code>OP Ri, (c(Rj))</code> - <code>Ri OP ((Rj+c)) =&gt; Ri</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>OP可以是ADD,SUB,MUL,DIV等</p>
<h2 id="简单代码生成器"><a href="#简单代码生成器" class="headerlink" title="简单代码生成器"></a>简单代码生成器</h2><p>思路: 代码生成器在生成每一条指令时, 必须要知道每个寄存器中存储的是什么, 以及每个变量存储到什么位置<br>方法: </p>
<ol>
<li>引入<strong>待用信息</strong></li>
<li>寄存器描述数组</li>
<li>变量地址描述数组</li>
</ol>
<h2 id="待用信息"><a href="#待用信息" class="headerlink" title="待用信息"></a>待用信息</h2><p>待用信息</p>
<ul>
<li>在基本块中, 四元式i对A定值, 四元式j对A取值, 且i,j之间无再对A定值, 则称j是i的变量A的待用信息</li>
</ul>
<p>活跃信息</p>
<ul>
<li>基本块中的一个名字在某个给定点之后仍被引用, 则称该名字在给定点是活跃的</li>
</ul>
<p>修改符号表</p>
<ul>
<li>记录待用信息和活跃信息</li>
<li><p>表示: (<code>待用信息[i/^]</code>,<code>活跃信息[y/^]</code>)</p>
<p>| 变量名 | 待用/活跃信息栏 |<br>| ——— | ———————- |<br>| A      | (…, …)      |<br>| B      | (…, …)      |<br>| …    | (…, …)      |</p>
</li>
</ul>
<p>计算待用和活跃信息</p>
<ol>
<li>开始时, 所有变量均为<code>非待用</code>, 根据基本块之后是否活跃填写<code>活跃</code>或<code>非活跃</code></li>
<li>逆序遍历每个四元式<code>i</code><ol>
<li>把<code>A</code>的引用信息附加到四元式<code>i</code>左值上</li>
<li><code>A</code>的引用信息附加<code>(^,^)</code></li>
<li>把<code>B</code>,<code>C</code>的引用信息附加到四元式<code>i</code>上</li>
<li><code>B</code>,<code>C</code>的引用信息附加<code>(^,^)</code></li>
</ol>
</li>
</ol>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T1:&#x3D;B-C</span><br><span class="line">T2:&#x3D;A*T1</span><br><span class="line">T3:&#x3D;D+1</span><br><span class="line">T4:&#x3D;E-F</span><br><span class="line">T5:&#x3D;T3*T4</span><br><span class="line">W:&#x3D;T2&#x2F;T5</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>四元式</th>
<th>左值</th>
<th>左操作数</th>
<th>右操作数</th>
</tr>
</thead>
<tbody>
<tr>
<td>(6)</td>
<td>W:=T2/T5</td>
<td>(^,y)</td>
<td>(^,^)</td>
<td>(^,^)</td>
</tr>
<tr>
<td>(5)</td>
<td>T5:=T3*T4</td>
<td>(6,y)</td>
<td>(^,^)</td>
<td>(^,^)</td>
</tr>
<tr>
<td>(4)</td>
<td>T4:=E-F</td>
<td>(3,y)</td>
<td>(^,^)</td>
<td>(^,^)</td>
</tr>
<tr>
<td>(3)</td>
<td>T3:=D+1</td>
<td>(3,y)</td>
<td>(^,^)</td>
<td>(^,^)</td>
</tr>
<tr>
<td>(2)</td>
<td>T2:=A*T1</td>
<td>(6,y)</td>
<td>(^,^)</td>
<td>(^,^)</td>
</tr>
<tr>
<td>(1)</td>
<td>T1:=B-C</td>
<td>(2,y)</td>
<td>(^,^)</td>
<td>(^,^)</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量名</th>
<th>待用/活跃信息栏</th>
</tr>
</thead>
<tbody>
<tr>
<td>T5</td>
<td>(^,^)-&gt;(6,y)-&gt;(^,^)</td>
</tr>
<tr>
<td>T4</td>
<td>(^,^)-&gt;(3,y)-&gt;(^,^)</td>
</tr>
<tr>
<td>T3</td>
<td>(^,^)-&gt;(3,y)-&gt;(^,^)</td>
</tr>
<tr>
<td>T2</td>
<td>(^,^)-&gt;(6,y)-&gt;(^,^)</td>
</tr>
<tr>
<td>T1</td>
<td>(^,^)-&gt;(2,y)-&gt;(^,^)</td>
</tr>
<tr>
<td>W</td>
<td>(^,y)-&gt;(^,^)</td>
</tr>
<tr>
<td>F</td>
<td>(^,^)-&gt;(4,y)</td>
</tr>
<tr>
<td>E</td>
<td>(^,^)-&gt;(4,y)</td>
</tr>
<tr>
<td>D</td>
<td>(^,^)-&gt;(3,y)</td>
</tr>
<tr>
<td>C</td>
<td>(^,^)-&gt;(1,y)</td>
</tr>
<tr>
<td>B</td>
<td>(^,^)-&gt;(1,y)</td>
</tr>
<tr>
<td>A</td>
<td>(^,^)-&gt;(2,y)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="寄存器分配算法"><a href="#寄存器分配算法" class="headerlink" title="寄存器分配算法"></a>寄存器分配算法</h2><p>寄存器描述和地址描述</p>
<ul>
<li>寄存器描述数组<code>RVALUE</code><ul>
<li>记录寄存器内存储的变量, 可以是多个</li>
<li><code>RVALUE[R1]=&#123;A,B&#125;</code></li>
</ul>
</li>
<li>变量地址描述数组<code>AVALUE</code><ul>
<li>记录变量存储的位置(寄存器/内存)</li>
<li><code>AVALUE[A]=&#123;R1,R2,A&#125;</code></li>
</ul>
</li>
</ul>
<p>代码生成算法</p>
<ul>
<li>对于四元式<code>A:=B op C</code>, 依次执行</li>
</ul>
<ol>
<li>调用<code>GETREG(i: A:=B op C)</code>获取一个寄存器<code>R</code></li>
<li>查询<code>AVALUE[B]</code>和<code>AVALUE[C]</code>, 如果在寄存器中, 假设是<code>B&#39;</code>和<code>C&#39;</code></li>
<li>如果<code>B&#39;≠R</code>, 先把<code>B</code>加载到<code>R</code>中, 生成代码: <code>LD R,B&#39;</code></li>
<li>进行运算, 生成代码: <code>op R,C&#39;</code></li>
<li>更新描述信息<ol>
<li>如果<code>B&#39;</code>或<code>C&#39;</code>是<code>R</code>, 就要把<code>AVALUE</code>中的记录删除</li>
<li>设置<code>AVALUE[A]=&#123;R&#125;, RVALUE[R]=&#123;A&#125;</code></li>
</ol>
</li>
<li>如果<code>B</code>或<code>C</code>仍存储在某个寄存器中, 但后续不再被引用且不再活跃, 就从<code>AVALUE</code>和<code>RVALUE</code>中删除<code>B</code>和<code>C</code>的记录</li>
</ol>
<p>寄存器分配原则</p>
<ul>
<li>尽可能用B独占的寄存器</li>
<li>尽可能用空闲的寄存器</li>
<li>抢占用非空闲寄存器<ul>
<li><code>Ri</code>的值也存储在内存中</li>
<li><code>Ri</code>最远才会用到</li>
</ul>
</li>
</ul>
<p>寄存器分配算法<code>GETREG(i: A:=B op C)</code></p>
<ol>
<li>如果B独占某个寄存器<ul>
<li>如果<code>AB</code>是同一个标识符(即修改B的指令<code>B:=B op C</code>)<ul>
<li>返回<code>B</code>所在的寄存器</li>
</ul>
</li>
<li>如果<code>B</code>在后面不会再引用(非待用, 非活跃)<ul>
<li>返回<code>B</code>所在的寄存器</li>
</ul>
</li>
</ul>
</li>
<li>如果有空闲寄存器, 返回空闲寄存器</li>
<li>抢占一个寄存器<code>Ri</code>, <ol>
<li>对于<code>Ri</code>中存储的每一个变量<code>M</code>, 如果存储的不是<code>A</code>, 或者存储的是<code>A == C != B</code>且<code>Ri</code>中不存储<code>B</code>.(<code>M==A &amp;&amp; M==C &amp;&amp; M!=B &amp;&amp; B not in RVALUE[Ri]</code>)<ol>
<li>如果<code>M</code>仅存储在<code>Ri</code>, 则要存到内存中: <code>ST Ri, M</code></li>
<li>如果<code>M == B</code>, 或者<code>M == C &amp;&amp; B in RVALUE[Ri]</code>中, 则令<code>AVALUE[M]=&#123;M,R&#125;</code>, 否则令<code>AVALUE[M]=&#123;M&#125;</code></li>
<li>删除<code>M</code>在<code>Ri</code>中的记录, <code>RVALUE[Ri].reLD e(M)</code></li>
<li>返回<code>R</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>例:</p>
<p>寄存器: R0, R1, </p>
<p>基本块出口活跃变量: W</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T1:&#x3D;B-C</span><br><span class="line">T2:&#x3D;A*T1</span><br><span class="line">T3:&#x3D;D+1</span><br><span class="line">T4:&#x3D;E-F</span><br><span class="line">T5:&#x3D;T3*T4</span><br><span class="line">W:&#x3D;T2&#x2F;T5</span><br></pre></td></tr></table></figure>
<p>答案:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">【解答】该基本块的目标代码如下(指令后面为相应的注释)：</span><br><span class="line">LD  R0, B  <span class="comment">/* 取第一个空闲寄存器 R0 */</span> </span><br><span class="line">SUB R0, C  <span class="comment">/* 运算结束后R0中为T1结果，内存中无该结果 */</span> </span><br><span class="line">LD  R1, A  <span class="comment">/* 取一个空闲寄存器R1 */</span> </span><br><span class="line">MUL R1, R0 <span class="comment">/* 运算结束后R1中为T2结果，内存中无该结果 */</span> </span><br><span class="line">LD  R0,D  <span class="comment">/* 此时R0中结果T1已经没有引用点，且临时单元T1是非活跃的，所以，寄存器R0可作为空闲寄存器使用 */</span> </span><br><span class="line">ADD R0, <span class="number">1</span> <span class="comment">/* 运算结束后R0中为T3结果，内存中无该结果 */</span> </span><br><span class="line">ST  R1, T2  <span class="comment">/*翻译四元式T4=E-F时，所有寄存器已经分配完毕，寄存器R0中存的T3和寄存器R1中存的T2都是有用的。由于T2的下一个引用点较T3的下一个引用点更远，所以暂时可将寄存器R1中的结果存回到内存的变量T2中，从而将寄存器R1空闲以备使用*/</span> </span><br><span class="line">LD  R1, E     </span><br><span class="line">SUB R1, F  <span class="comment">/*运算结束后R1中为T4结果，内存中无该结果*/</span>  </span><br><span class="line">MUL R0, R1 <span class="comment">/*运算结束后R0中为T5结果，内存中无该结果。注意，该指令将寄存器R0中原来的结果T3冲掉了。可以这么做的原因是，T3在该指令后不再有引用点，且是非活跃变量*/</span> </span><br><span class="line">LD  R1, T2 <span class="comment">/*此时R1中结果T4已经没有引用点，且临时单元T4是非活跃的，因此寄存器R1可作为空闲寄存器使用*/</span> </span><br><span class="line">DIV R1, R0  </span><br><span class="line"><span class="comment">/*运算结束后R1中为W结果，内存中无该结果。此时所有指令部分已经翻译完毕*/</span> </span><br><span class="line">ST  R1, W </span><br><span class="line"><span class="comment">/*指令翻译完毕时，寄存器中存有最新的计算结果，必须将它们存回到内存相应的单元中去，否则，在翻译下一个基本块时，所有的寄存器被当成空闲的寄存器使用，从而造成计算结果的丢失。考虑到寄存器R0中的T5和寄存器R1中的W，临时单元T5是非活跃的，因此只要将结果W存回对应单元即可*/</span> </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课程笔记</category>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>编译原理笔记</title>
    <url>/compiler-principle/index.html</url>
    <content><![CDATA[<h2 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h2><p>总评 = 考试 <em> 60% + 作业 </em> 30% + 平时 * 10%</p>
<h2 id="程序语言的发展"><a href="#程序语言的发展" class="headerlink" title="程序语言的发展"></a>程序语言的发展</h2><p>机器语言 -&gt; 汇编语言 -&gt; 高级语言</p>
<h2 id="程序的两种执行方式"><a href="#程序的两种执行方式" class="headerlink" title="程序的两种执行方式"></a>程序的两种执行方式</h2><ul>
<li><p>解释方式</p>
</li>
<li><p>编译方式</p>
</li>
</ul>
<p>Java认为是解释型语言</p>
<h2 id="编译的步骤"><a href="#编译的步骤" class="headerlink" title="编译的步骤"></a>编译的步骤</h2><p>编译过程基本分为五个基本阶段: </p>
<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析和中间代码生成</li>
<li>优化</li>
<li>目标代码生成</li>
</ol>
<h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h3><ul>
<li>词法分析程序又称扫描程序(Scanner)。<ul>
<li>任务：读源程序的字符流、识别单词（也称单词符号，或简称符号），如标识符、关键字、常量、界限符等，并转换成内部形式。</li>
<li>输入：源程序中的字符流</li>
<li>输出：等长的内部形式，即属性字（单词类型Token-name, 单词属性Attribute-value），其中单词属性指向符号表</li>
</ul>
</li>
</ul>
<p>输入: 字符流<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cppcode = <span class="string">`</span></span><br><span class="line"><span class="string">int a, b;</span></span><br><span class="line"><span class="string">a = a + 2;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><br>输出: Token流和对应的符号表<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tokenList = [</span><br><span class="line">    &lt;int&gt;</span><br><span class="line">    &lt;id,<span class="number">1</span>&gt;</span><br><span class="line">    &lt;,&gt;</span><br><span class="line">    &lt;id,<span class="number">2</span>&gt;</span><br><span class="line">    &lt;;&gt;</span><br><span class="line">    &lt;id,<span class="number">1</span>&gt;</span><br><span class="line">    &lt;op,EQ&gt;</span><br><span class="line">    &lt;id,<span class="number">1</span>&gt;</span><br><span class="line">    &lt;+&gt;</span><br><span class="line">    &lt;<span class="number">2</span>&gt;</span><br><span class="line">    &lt;;&gt;</span><br><span class="line">]</span><br><span class="line">tokenTable = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>, ...&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>, ...&#125; </span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在词法分析阶段工作所依循的是语言的词法规则。</li>
<li>描述词法规则的有效工具是<strong>正规式</strong>和<strong>有限自动机</strong>。</li>
<li>方法：<strong>状态图</strong>；<strong>DFA</strong>；<strong>NFA</strong></li>
</ul>
<p>DFA模拟代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s = s0;</span><br><span class="line">c = nextChar() ;</span><br><span class="line"><span class="keyword">while</span> ( c != eof ) &#123;</span><br><span class="line">    s = move(s, c);</span><br><span class="line">    c = nextChar() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( s is in F ) <span class="keyword">return</span> <span class="string">&quot; yes &quot;</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;no &quot;</span> ;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2. 语法分析"></a>2. 语法分析</h3><ul>
<li>语法分析程序又称识别程序(Parser)。<ul>
<li>任务：读入由词法分析程序识别出的符号，根据给定语法规则，识别出各个语法单位（如：短语、子句、语句、程序段、程序）,并生成另一种内部表示。</li>
<li>输入：由词法分析程序识别出并转换的符号</li>
<li>输出：另一种内部表示，如<strong>语法分析树</strong>或其它<strong>中间表示</strong>。</li>
</ul>
</li>
<li>语法规则通常用<strong>上下文无关文法</strong>描述。</li>
<li>方法：递归子程序法、<strong>LR分析法</strong>、<strong>算符优先分析法</strong>。</li>
</ul>
<p>输入: 符号流<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sum := first + count * <span class="number">10</span></span><br></pre></td></tr></table></figure><br>输出: 语法树<br><img src="index/ast_demo.png" alt=""></p>
<h3 id="3-1-语义分析"><a href="#3-1-语义分析" class="headerlink" title="3.1 语义分析"></a>3.1 语义分析</h3><h3 id="3-2-中间代码生成"><a href="#3-2-中间代码生成" class="headerlink" title="3.2 中间代码生成"></a>3.2 中间代码生成</h3><h3 id="4-优化"><a href="#4-优化" class="headerlink" title="4. 优化"></a>4. 优化</h3><ul>
<li>优化的任务在于对前段产生的中间代码进行加工，把它变换成功能相同，但功效更高的优化了的中间表示代码，以期在最后阶段产生更为高效（省时间和空间）的代码</li>
<li>优化所依循的原则是程序的等价变换规则</li>
<li>其方法有：公共子表达式的提取、循环优化、删除无用代码等等。</li>
</ul>
<h3 id="5-目标代码生成"><a href="#5-目标代码生成" class="headerlink" title="5. 目标代码生成"></a>5. 目标代码生成</h3><h3 id="遍-Pass"><a href="#遍-Pass" class="headerlink" title="遍(Pass)"></a>遍(Pass)</h3><p>对<strong>源程序</strong>或源程序的<strong>中间结果</strong>从头到尾扫描一次，并做相关处理，生成新的中间结果或目标程序的过程。</p>
<p>“遍”是处理数据的一个完整周期，每遍工作从外存上获得前一遍的中间结果（如源程序），完成它所含的有关工作之后，再把结果记录于外存。</p>
<p>一个编译程序可由一遍、两遍或多遍完成。每一遍可完成不同的阶段或多个阶段的工作。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>从时间和空间角度看</th>
</tr>
</thead>
<tbody>
<tr>
<td>多遍编译</td>
<td><strong>少占内存，多耗时间</strong></td>
</tr>
<tr>
<td>一遍编译</td>
<td><strong>多占内存，少耗时间</strong></td>
</tr>
</tbody>
</table>
</div>
<h3 id="T形图"><a href="#T形图" class="headerlink" title="T形图"></a>T形图</h3><p><img src="index/t_diagram.png" alt=""></p>
<ul>
<li>S:源语言(程序)，Source language(program)</li>
<li>T:目标语言(程序), target/object language(program)</li>
<li>I:实现语言, implementation language</li>
</ul>
<p>用T形图表示编译器移植</p>
<p><img src="index/t_diagram2.png" alt=""></p>
<h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><p>自编译: </p>
<p>交叉编译</p>
<p>自动编译:<br>    lex, yacc</p>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>乔姆斯基文法:<br>0/1/2/3</p>
<p>词法分析: 3型<br>语法分析: 2型</p>
<p>A卷 - 简单<br>缓考不考-&gt;B卷-&gt;难</p>
<p>语法分析:<br>LR,SLR,二义文法</p>
<p>就5道大题 5个部分 占40%<br>平时 60%</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>语义分析和中间代码生成</title>
    <url>/compiler-principle/ir.html</url>
    <content><![CDATA[<h1 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h1><p><img src="ir/index1.png" alt=""></p>
<p><img src="ir/index2.png" alt=""></p>
<h1 id="属性文法和语法制导翻译"><a href="#属性文法和语法制导翻译" class="headerlink" title="属性文法和语法制导翻译"></a>属性文法和语法制导翻译</h1><h2 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h2><p>属性文法: 在上下文无关文法的基础上给每个文法符号增加若干属性</p>
<p>语义规则: 对于文法的每个产生式配备了<strong>一组</strong>属性的计算规则</p>
<ul>
<li>$b:=f(c_1,c_2,…,c_k)$</li>
<li>产生式左边的综合属性和右边的继承属性必须提供语义规则</li>
<li>语义规则所描述的工作可以包括属性计算、符号表操作、静态语义检查、代码生成等等。</li>
</ul>
<p>属性加工的过程即是语义处理的过程</p>
<p>属性</p>
<ul>
<li>综合属性: 在语法树中, 通过子节点的属性计算出来的属性(自下而上)</li>
<li>继承属性: 在语法树中, 通过父节点和兄弟节点的属性计算出来的属性(自上而下)</li>
<li>终结符只有综合属性, 有lexer提供</li>
</ul>
<h3 id="S-属性文法"><a href="#S-属性文法" class="headerlink" title="S-属性文法"></a>S-属性文法</h3><p>只包含综合属性的文法</p>
<h3 id="L-属性文法"><a href="#L-属性文法" class="headerlink" title="L-属性文法"></a>L-属性文法</h3><p>如果每个产生式A→X1…Xj-1Xj…Xn的每条语义规则计算的属性或者是A的综合属性；或者是Xj的继承属性，但它仅依赖：</p>
<ul>
<li>该产生式中Xj左边符号X1, X2, …, Xj-1的属性；</li>
<li>A的继承属性</li>
</ul>
<h2 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h2><p>语法制导翻译法: </p>
<ul>
<li>基于属性文法的处理过程: <code>输入串-&gt;语法树-&gt;依赖图-&gt;语义规则计算次序</code></li>
<li>由源程序的语法结构所驱动</li>
</ul>
<p>作用</p>
<ul>
<li><strong>产生中间代码</strong></li>
<li>产生目标指令</li>
<li>对输入串进行解释执行</li>
</ul>
<h3 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h3><p>用DAG表示属性依赖关系</p>
<ul>
<li>每个属性一个结点</li>
<li>语义规则中左边属性依赖右边每一个属性</li>
</ul>
<p><img src="ir/dep_tree.png" alt=""></p>
<ol>
<li><p>树遍历法</p>
<ul>
<li>无环图</li>
<li>DFS</li>
<li>从左到右</li>
</ul>
</li>
<li><p>一遍扫描法</p>
<ul>
<li>在语法分析的同时计算属性值</li>
<li>S-属性文法适合于一遍扫描的自下而上分析</li>
<li>L-属性文法适合于一遍扫描的自上而下分析</li>
</ul>
</li>
</ol>
<h1 id="语义分析和中间代码生成"><a href="#语义分析和中间代码生成" class="headerlink" title="语义分析和中间代码生成"></a>语义分析和中间代码生成</h1><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><h2 id="中间语言"><a href="#中间语言" class="headerlink" title="中间语言"></a>中间语言</h2><p>中间语言是复杂性界于源语言和目标语言之间的语言</p>
<p>好处:</p>
<ul>
<li>便于进行与机器无关的代码优化工作</li>
<li>易于移植</li>
<li>使编译程序的结构在逻辑上更为简单明确</li>
</ul>
<p>常用的中间语言表示法</p>
<ul>
<li>后缀式(逆波兰式)</li>
<li>图表示<ul>
<li>DAG</li>
<li>AST</li>
</ul>
</li>
<li>三地址代码<ul>
<li>三元式</li>
<li>四元式</li>
<li>间接三元式</li>
</ul>
</li>
</ul>
<p>后缀式:</p>
<ul>
<li>二元操作符后置</li>
<li>(一元操作符后置)</li>
<li>去括号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a+b*(c+d&#x2F;e)</span><br><span class="line">a b*(c+d&#x2F;e) +</span><br><span class="line">a b (c+d&#x2F;e) * +</span><br><span class="line">a b c d&#x2F;e + * +</span><br><span class="line">a b c d e &#x2F; + * +</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b:&#x3D;-c*a+-c*a</span><br><span class="line">b -c*a+-c*a :&#x3D;</span><br><span class="line">b -c*a -c*a + :&#x3D;</span><br><span class="line">b -c a * -c a * + :&#x3D;</span><br><span class="line">b c Neg a * c Neg a * + :&#x3D;</span><br></pre></td></tr></table></figure>
<p>抽象语法树: 去掉对翻译不必要的信息, 更有效表示源程序的语法树</p>
<p><img src="ir/ast.png" alt=""></p>
<p>DAG</p>
<ul>
<li>一个内部结点代表一个操作符，它的孩子代表操作数</li>
<li>一个DAG中代表<strong>公共子表达式</strong>的结点具有多个父结点</li>
</ul>
<p><img src="ir/dag.png" alt=""></p>
<p>三地址代码: <code>x:=y op z</code></p>
<ul>
<li>三地址代码可以看成是抽象语法树或DAG的一种线性表示</li>
<li>种类<ul>
<li><code>x:=y op z</code></li>
<li><code>x:=op y</code></li>
<li><code>x:=y</code></li>
<li><code>goto L</code></li>
<li><code>if x rop y goto L</code></li>
<li><code>if a goto L</code></li>
</ul>
</li>
<li><p>计算机表示</p>
<ul>
<li><p>四元式</p>
<p>|     | Op     | arg1 | arg2 | result |<br>| —- | ——— | —— | —— | ——— |<br>| (0) | uminus | c    |      | T1     |<br>| (1) | *      | b    | T1   | T2     |<br>| … | …    | …  | …  | …    |</p>
</li>
<li><p>三元式</p>
<p>|     | Op     | arg1 | arg2 |<br>| —- | ——— | —— | —— |<br>| (0) | uminus | c    |      |<br>| (1) | *      | b    | (0)  |<br>| … | …    | …  | …  |<br>| (4) | +      | (1)  | (3)  |<br>| … | …    | …  | …  |</p>
</li>
<li><p>间接三元式</p>
<ul>
<li>使用间接代码表来压缩存储相同的三元式</li>
<li>好处: <ul>
<li>调整语句顺序不需要改动三元式表</li>
<li>节省存储空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="说明语句的翻译"><a href="#说明语句的翻译" class="headerlink" title="说明语句的翻译"></a>说明语句的翻译</h2><h2 id="赋值语句的翻译"><a href="#赋值语句的翻译" class="headerlink" title="赋值语句的翻译"></a>赋值语句的翻译</h2><p><img src="ir/assign_example.png" alt=""></p>
<p>答案:</p>
<p><img src="ir/assign_example_solution.png" alt=""></p>
<p>三地址代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T1:&#x3D;uminus C</span><br><span class="line">T2:&#x3D;T1+D</span><br><span class="line">T3:&#x3D;B*T2</span><br><span class="line">A:&#x3D;T3</span><br></pre></td></tr></table></figure></p>
<h2 id="布尔表达式的翻译"><a href="#布尔表达式的翻译" class="headerlink" title="布尔表达式的翻译"></a>布尔表达式的翻译</h2><p>基本作用:</p>
<ul>
<li>逻辑运算</li>
<li>控制语句条件</li>
</ul>
<p>翻译方法</p>
<ul>
<li>算数方式</li>
<li>短路计算</li>
</ul>
<h3 id="逻辑运算中的布尔表达式翻译"><a href="#逻辑运算中的布尔表达式翻译" class="headerlink" title="逻辑运算中的布尔表达式翻译"></a>逻辑运算中的布尔表达式翻译</h3><p><img src="ir/bool_example.png" alt=""></p>
<p>答案:</p>
<p>三地址代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: if a&gt;b goto 3</span><br><span class="line">1: T1:&#x3D;0</span><br><span class="line">2: goto 4</span><br><span class="line">3: T1:&#x3D;1</span><br><span class="line">4: if a&gt;b goto 7</span><br><span class="line">5: T1:&#x3D;0</span><br><span class="line">6: goto 8</span><br><span class="line">7: T1:&#x3D;1</span><br><span class="line">8: T3&#x3D;T1 and T2</span><br></pre></td></tr></table></figure></p>
<h3 id="条件控制语句中的布尔表达式翻译"><a href="#条件控制语句中的布尔表达式翻译" class="headerlink" title="条件控制语句中的布尔表达式翻译"></a>条件控制语句中的布尔表达式翻译</h3><p>两种出口: 一真一假</p>
<p>改写产生式</p>
<ul>
<li><code>E -&gt; E and M E</code></li>
<li><code>E -&gt; E or M E</code></li>
<li><code>M -&gt; epsilon</code></li>
</ul>
<p>增加属性</p>
<ul>
<li><code>truelist</code>/<code>falselist</code>: 布尔表达式中需要回填地址的四元式构成的(反向)列表, 从最后的需要回填地址四元式指向更靠前的四元式</li>
<li><code>nextquad</code>: 下一条即将产生的四元式的地址, 如果是emit过程中包含那么就是该条语句的地址</li>
</ul>
<p>增加过程</p>
<ul>
<li><code>makelist(i)</code>: 创建一个新链表<code>-&gt;i</code></li>
<li><code>merge(p1,p2)</code>: 合并两个链表</li>
<li><code>backpatch(p,t)</code>: 回填地址</li>
</ul>
<p><img src="ir/bool1.png" alt=""></p>
<p><img src="ir/bool2.png" alt=""></p>
<p>例: 写出布尔式A or (B and not (C or D))的四元式序列</p>
<p>答案:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: jnz,A,-,0</span><br><span class="line">1: j,-,-,2</span><br><span class="line">2: jnz,B,-,4</span><br><span class="line">3: j,-,-,0</span><br><span class="line">4: jnz,C,-,0</span><br><span class="line">5: j,-,-,6</span><br><span class="line">6: jnz,D,-,0</span><br><span class="line">7: j,-,-,0</span><br></pre></td></tr></table></figure>
<h2 id="控制语句的翻译"><a href="#控制语句的翻译" class="headerlink" title="控制语句的翻译"></a>控制语句的翻译</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>改写产生式</p>
<ul>
<li><code>S -&gt; if E then M S</code></li>
<li><code>S -&gt; if E then M S N else M S</code></li>
<li><code>M -&gt; epsilon</code></li>
<li><code>N -&gt; epsilon</code></li>
</ul>
<p>增加属性:</p>
<ul>
<li><code>nextlist</code>: 下一条执行语句的地址, 引入此变量是为了优化连续多次跳转</li>
</ul>
<p><img src="ir/control.png" alt=""></p>
<h3 id="循环语句-while"><a href="#循环语句-while" class="headerlink" title="循环语句(while)"></a>循环语句(while)</h3><p><img src="ir/while.png" alt=""></p>
<h3 id="语句列表和语句块"><a href="#语句列表和语句块" class="headerlink" title="语句列表和语句块"></a>语句列表和语句块</h3><p>改写产生式</p>
<ul>
<li><code>L -&gt; L; M S</code></li>
<li><code>M -&gt; epsilon</code></li>
</ul>
<p><img src="ir/list.png" alt=""></p>
<p><img src="ir/block.png" alt=""></p>
<h3 id="标号与goto语句的翻译"><a href="#标号与goto语句的翻译" class="headerlink" title="标号与goto语句的翻译"></a>标号与goto语句的翻译</h3><h3 id="case语句的翻译"><a href="#case语句的翻译" class="headerlink" title="case语句的翻译"></a>case语句的翻译</h3><h2 id="过程调用的翻译"><a href="#过程调用的翻译" class="headerlink" title="过程调用的翻译"></a>过程调用的翻译</h2><p>不考, 略</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>词法分析</title>
    <url>/compiler-principle/lex.html</url>
    <content><![CDATA[<h2 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h2><p><img src="lex/index.png" alt=""></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>单词级别分析和翻译源程序</li>
<li>任务: 作为<strong>字符串</strong>的源程序-&gt;<strong>单词符号串</strong></li>
</ul>
<h2 id="词法分析器的要求"><a href="#词法分析器的要求" class="headerlink" title="词法分析器的要求"></a>词法分析器的要求</h2><p>单词符号表示通常使用二元式 (单词种别, 单词符号的属性值)</p>
<ul>
<li>单词种别: 语法分析需要的信息, 通常使用整数编码</li>
<li>单词(符号属性)值: 编译其他阶段使用</li>
</ul>
<p>单词如何分类取决于处理上的方便:</p>
<ul>
<li>标识符: 一般通归为一种</li>
<li>常数: 按类型分种</li>
<li>关键字: 可全体为一种, 也可一字一种(更方便)</li>
<li>运算符: 一般一符一种, 可以把具有一定共性的视为一类</li>
<li>界符: 一般一符一种</li>
</ul>
<p>单词符号的属性:</p>
<ul>
<li>标识符: 存放它<strong>符号表</strong>项的指针/内部字符串</li>
<li>常数: 存放它<strong>常数表</strong>项的指针/二进制形式</li>
<li>关键字/运算符/界符: 不需要属性</li>
</ul>
<p><img src="lex/lex.png" alt=""></p>
<p>实现方式:</p>
<ul>
<li>完全独立: lex作为单独一遍<ul>
<li>结构简洁, 清晰, 条理化</li>
</ul>
</li>
<li>相对独立: 作为parser的一个独立子程序, 需要新符号时调用<ul>
<li>避免中间文件, 提高效率</li>
</ul>
</li>
</ul>
<h2 id="词法分析器设计"><a href="#词法分析器设计" class="headerlink" title="词法分析器设计"></a>词法分析器设计</h2><h3 id="lexer的结构"><a href="#lexer的结构" class="headerlink" title="lexer的结构"></a>lexer的结构</h3><p>源程序 -&gt; 输入缓冲区/预处理子程序/扫描缓冲区/扫描器 -&gt; 单词符号</p>
<p>预处理子程序: 处理空白符等编辑性字符, 删除注释等</p>
<p>输入缓冲区: 存放源程序文本输入串的缓冲区</p>
<p>扫描缓冲区: 设定两个指示器</p>
<h3 id="单词符号的识别-超前搜索"><a href="#单词符号的识别-超前搜索" class="headerlink" title="单词符号的识别: 超前搜索"></a>单词符号的识别: 超前搜索</h3><ul>
<li>关键字识别</li>
<li>标识符识别: 一般是字母开头的字母数字串, 一般都跟着算符或者界符, 不难识别</li>
<li>常数的识别: 有些语言需要使用超前搜索</li>
<li>算符和界符: 对于c++中的++,—等需要超前搜索</li>
</ul>
<h3 id="词法规则的表示"><a href="#词法规则的表示" class="headerlink" title="词法规则的表示"></a>词法规则的表示</h3><p>大多数pl中的单词符号的<strong>词法规则</strong>可以用<strong>正规文法</strong>描述</p>
<p>例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;标识符&gt; -&gt; 字母|&lt;标识符&gt;字母|&lt;标识符&gt;数字</span><br><span class="line">&lt;整数&gt; -&gt; 数字|&lt;整数&gt;数字</span><br><span class="line">&lt;运算符&gt; -&gt; +|-|×|÷…</span><br><span class="line">&lt;界符&gt; -&gt; ;|,|(|)|…</span><br></pre></td></tr></table></figure>
<p>利用这些规则识别的过程可以用<strong>状态转换图</strong>来表示, 而状态转换图可以方便地用程序实现</p>
<h3 id="TG"><a href="#TG" class="headerlink" title="TG"></a>TG</h3><p>状态转换图TG: 一个有限有向图, 可用于接受(识别)一定的符号串</p>
<ul>
<li>结点表示状态, 用圆圈表示<ul>
<li>初态: 通常只有一个, 用一条输入弧表示</li>
<li>终态: <strong>至少有一个</strong>, 用双圈表示</li>
</ul>
</li>
<li>方向弧表示状态转换, 弧上的标记表示接受的输入字符或字符类</li>
</ul>
<p>路: 在状态转换图中从初态到某一个终态的弧上的标记序列</p>
<p>接受(识别): 若存在一条路产生$\beta$, 则称状态转换图接受符号串$\beta$</p>
<p>状态转换图能识别的语言: L(TG)能别TG接受的符号串的集合</p>
<p><img src="lex/tg.png" alt=""></p>
<h2 id="正规表达式和有限自动机"><a href="#正规表达式和有限自动机" class="headerlink" title="正规表达式和有限自动机"></a>正规表达式和有限自动机</h2><h3 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h3><p>字母表$\Sigma$上的正规式和正规集递归定义如下：</p>
<ol>
<li>$\varepsilon$和$\varphi$都是$\Sigma$上的正规式, 它们所表示的正规集分别为${\varepsilon}$和$\varphi$。其中：$\varepsilon$为空字符串, $\varphi$为空集</li>
<li>任意元素$a\in\Sigma$, a是$\Sigma$上的一个正规式, 它所表示的正规集是${a}$;</li>
<li>假定U和V都是$\Sigma$上的正规式, 它们所表示的正规集记为L(U)和L(V), 那么(U|V), (U·V)和(U)*都是正规式, 他们所表示的正规集分别记为L(U)∪L(V), L(U)L(V)和(L(U))*。</li>
<li>仅由有限次使用上述三步而得到的表达式才是$\Sigma$上的正规式, 它们所表示的字集才是$\Sigma$上的正规集。</li>
</ol>
<p>运算:</p>
<ul>
<li>闭包<code>*</code></li>
<li>连接<code>.</code> (可省略)</li>
<li>或<code>|</code></li>
</ul>
<p>运算律:</p>
<ul>
<li>或交换律</li>
<li>或结合律</li>
<li>连接结合律</li>
<li>或对连接分配律</li>
<li>$\varepsilon U=U \varepsilon=U$</li>
</ul>
<p>例:</p>
<ul>
<li>以01结尾的二进制数串的正规式: <code>(0|1)*01</code></li>
<li>能被5整除的十进制整数: <code>0|5|(1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*(0|5)</code></li>
</ul>
<h3 id="FA"><a href="#FA" class="headerlink" title="FA"></a>FA</h3><p>自动机: 具有离散输入输出的数学模型</p>
<pre><code>状态 + 输入 + 规则 -&gt; 状态迁移
</code></pre><p>有限自动机(FA)</p>
<p>有限状态机(FSM)</p>
<h3 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h3><p>DFA五元组: $M=(S,\Sigma,\delta,S_0,F)$</p>
<ul>
<li>$S$: 有限的状态集合, 每个元素称为一个状态</li>
<li>$\Sigma$: 有限的输入字母表, 每个元素称为一个输入字符</li>
<li>$\delta: S\times\Sigma \rightarrow S$: 转换函数(状态转移集合)<ul>
<li>$\delta(s, a)=s’$</li>
</ul>
</li>
<li>$S_0\in S$: 初始状态</li>
<li>$F\subseteq S$: 终止状态集</li>
</ul>
<p>状态转换矩阵: DFA可以用一个矩阵表示, 每行表示一个状态, 每列表示一种输入, 矩阵元素表示$\delta(s,a)$的值</p>
<p><strong>DFA与状态转换图: DFA可以用TG唯一表示</strong></p>
<p><img src="lex/dfa_tg.png" alt=""></p>
<p><strong>拓展转移函数</strong></p>
<ul>
<li>接收一个字符串的状态转移函数</li>
<li>$\delta’: S\times\Sigma^* \rightarrow S$<ul>
<li>$\delta’(s, \varepsilon) = s$</li>
<li>$\delta’(s, \omega a) = \delta(\delta’(s,\omega),a)$</li>
</ul>
</li>
</ul>
<p>DFA接受的字符串</p>
<p>DFA接受的语言: $L(M)={α|\delta’(s,α)\in F}$</p>
<h3 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h3><p>NFA五元组: $M=(S,\Sigma,\delta,S_0,F)$</p>
<ul>
<li>$S$: 同DFA</li>
<li>$\Sigma$: 同DFA</li>
<li>$\delta: S\times\Sigma^* \rightarrow 2^S(幂集)$: 转换函数(状态转移集合)<ul>
<li>$\delta(s, a)=S’\subseteq S$</li>
</ul>
</li>
<li>$S_0\subseteq S$: 非空初态集</li>
<li>$F\subseteq S$: 终止状态集</li>
</ul>
<p><strong>NFA也可以用TG和转换矩阵表示</strong></p>
<p><strong>NFA的状态是一个集合</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>比较</th>
<th>DFA</th>
<th>NFA</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入字母</td>
<td>每个(状态,输入)都有一个$\delta$</td>
<td>可能没有$\delta$/是空转换</td>
</tr>
<tr>
<td>转移状态</td>
<td>确定的</td>
<td>不确定的, 可能有多个</td>
</tr>
</tbody>
</table>
</div>
<p>NFA的拓展转移函数</p>
<ul>
<li>$\delta’: S\times\Sigma^* \rightarrow 2^S$<ul>
<li>$\delta’(s, \varepsilon) = {s}$</li>
<li>$\delta’(s,\omega a)={p|存在r\in\delta’(s,\omega )\wedge p\in\delta(r,a)}$</li>
</ul>
</li>
</ul>
<p>NFA接受的字符串</p>
<p>NFA接受的语言</p>
<h3 id="DFA和NFA的关系-子集法"><a href="#DFA和NFA的关系-子集法" class="headerlink" title="DFA和NFA的关系 (子集法)"></a>DFA和NFA的关系 (子集法)</h3><p>DFA是NFA的特例, 两者可以相互转化</p>
<p><strong>ε-闭包</strong>:</p>
<script type="math/tex; mode=display">
\varepsilon\_CLOSURE(I)=I\cup\{q'|q经任意条\varepsilon弧可到达q', q\in I\}, I\subseteq M'</script><p><strong>NFA-&gt;DFA之子集法</strong>:</p>
<ol>
<li>引进新的初态结点X和终态结点Y, 从X到所有原始态结点连接一条$\varepsilon$弧, 从所有原终态结点到Y连接一条$\varepsilon$弧</li>
<li><p>对复合的弧进行<strong>分裂</strong></p>
<p> <img src="lex/nfa_dfa.png" alt=""> </p>
</li>
<li><p>构造状态矩阵<br> | I                           | $I_{\Sigma_i}$ | … |<br> | —————————————- | ——————— | —- |<br> | $\varepsilon_CLOSURE({X})$ | …            | … |<br> | …                         | …            | … |</p>
</li>
<li><p>合并相同状态, 重新命名得到新的状态转换矩阵</p>
<ul>
<li>第一行第一列的状态为始态</li>
<li>包含Y的状态为终态</li>
</ul>
</li>
<li>画出状态转换图</li>
</ol>
<p>例:</p>
<p><img src="lex/nfa_dfa_example_1.png" alt=""></p>
<p><img src="lex/nfa_dfa_example_2.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>I</th>
<th>$I_{a}$</th>
<th>$I_{b}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>{X, 0, Y}</td>
<td>{1}</td>
<td>{1}</td>
</tr>
<tr>
<td>{1}</td>
<td>{0,Y}</td>
<td>-</td>
</tr>
<tr>
<td>{0,Y}</td>
<td>{1}</td>
<td>{1}</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>I</th>
<th>$I_{a}$</th>
<th>$I_{b}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p><img src="lex/nfa_dfa_example_3.png" alt=""></p>
<h3 id="正规式和FA的关系"><a href="#正规式和FA的关系" class="headerlink" title="正规式和FA的关系"></a>正规式和FA的关系</h3><ul>
<li>正规式和FA是等价的</li>
</ul>
<h4 id="从NFA构造等价的正规式-简单"><a href="#从NFA构造等价的正规式-简单" class="headerlink" title="从NFA构造等价的正规式 (简单)"></a>从NFA构造等价的正规式 (简单)</h4><ol>
<li><p>引进新的初态结点X和终态结点Y, 从X到所有原始态结点连接一条$\varepsilon$弧, 从所有原终态结点到Y连接一条$\varepsilon$弧</p>
</li>
<li><p>对复合的弧进行<strong>合并</strong></p>
<p> <img src="lex/nfa_regex.png" alt=""></p>
</li>
<li><p>得到regex</p>
</li>
</ol>
<h4 id="从正规式构造等价的NFA-Thompson算法"><a href="#从正规式构造等价的NFA-Thompson算法" class="headerlink" title="从正规式构造等价的NFA (Thompson算法)"></a><strong>从正规式构造等价的NFA (Thompson算法)</strong></h4><p><img src="lex/regex_nfa_1.png" alt=""><br><img src="lex/regex_nfa_2.png" alt=""></p>
<p>例:</p>
<p><img src="lex/regex_nfa_example.png" alt=""></p>
<h3 id="DFA的化简-等价状态法"><a href="#DFA的化简-等价状态法" class="headerlink" title="DFA的化简 (等价状态法)"></a><strong>DFA的化简 (等价状态法)</strong></h3><p>将状态集$S$根据能否被输入区分划分为更细的集合</p>
<ol>
<li>初始划分: $\Pi={终态集I^{(1)}, 非终态集I^{(2)}}$</li>
<li>检查能否再分<ol>
<li>如果对输入字符$a$, 存在$I^{(k)}$接受$a$后不全落在现行$\Pi$的某一个子集中</li>
<li>就把$I^{(k)}$分成多个组, 使得每个组接受$a$后都落在$\Pi$的同一个子集中</li>
</ol>
</li>
<li>重复直到子集数不再增加</li>
</ol>
<p><img src="lex/dfa_simplify.png" alt=""></p>
<p>例题:</p>
<p><img src="lex/dfa_simplify_example.png" alt=""></p>
<p>初始划分$\Pi_0={\left{A,B,C,D\right},{E}}$</p>
<p>考察${A,B,C,D}_a={B}\subseteq {A,B,C,D}$</p>
<p>${A,B,C,D}_b={C,D,E}$, 需要划分, 其中${A,B,C}_b={C,D}$, ${D}_b={E}$</p>
<p>将${A,B,C,D}$分成${A,B,C}$和${D}$, 得$\Pi_1={\left{A,B,C\right},{D},{E}}$</p>
<p>考察${A,B,C}_b={C,D}$, 需要划分, 其中${A,C}_b={C}$, ${B}_b={D}$</p>
<p>将${A,B,C}$分为${A,C}$和${B}$, 得$\Pi_2={\left{A,C\right},{B},{D},{E}}$</p>
<h3 id="正规文法和FA的关系"><a href="#正规文法和FA的关系" class="headerlink" title="正规文法和FA的关系"></a>正规文法和FA的关系</h3><p>FA和左(右)线性正规文法等价</p>
<p>将FA的状态和右线性正规文法的非终结符作为桥梁, 两者等价</p>
<h2 id="词法分析器的自动生成"><a href="#词法分析器的自动生成" class="headerlink" title="词法分析器的自动生成"></a>词法分析器的自动生成</h2><p>略</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>语法分析</title>
    <url>/compiler-principle/parser.html</url>
    <content><![CDATA[<h2 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h2><p><img src="parser/index1.png" alt=""></p>
<p><img src="parser/index2.png" alt=""></p>
<h2 id="语法分析方法"><a href="#语法分析方法" class="headerlink" title="语法分析方法"></a>语法分析方法</h2><ul>
<li>自上而下分析<ul>
<li>LL(1)分析法</li>
<li>递归下降分析法</li>
<li>预测分析法</li>
</ul>
</li>
<li>自下而上分析<ul>
<li>算符优先分析法</li>
<li>LR分析法<ul>
<li>LR(0)</li>
<li>SLR</li>
<li>LR(1)</li>
<li>LALR</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h2><h3 id="左递归消除"><a href="#左递归消除" class="headerlink" title="左递归消除"></a>左递归消除</h3><p>一个文法含有下列形式的产生式时, 称为左递归文法, 不能采用自顶向下分析法</p>
<ol>
<li><p>直接递归</p>
<p> $A\rightarrow A\beta, A\in V_N$, $\beta$$\in$V*</p>
</li>
<li><p>间接递归</p>
<p> $A\rightarrow B\beta$</p>
<p> $B\rightarrow A\alpha, A,B\in V_N, \alpha, \beta\in V^*$</p>
</li>
</ol>
<p><strong>左递归消除</strong></p>
<p>$P\rightarrow P\alpha_1|P\alpha_2|…|P\alpha_m|\beta_1|\beta_2|…|\beta_n$</p>
<p>改写为</p>
<p>$P\rightarrow\beta_1 P’|\beta_2 P’|…|\beta_n P’$</p>
<p>$P’\rightarrow\alpha_1 P’|\alpha_2 P’|…|\alpha_m P’|\varepsilon$</p>
<h3 id="FIRST-FOLLOW"><a href="#FIRST-FOLLOW" class="headerlink" title="FIRST, FOLLOW"></a>FIRST, FOLLOW</h3><p>终结首符集: $FIRST(\alpha)={a|\alpha\Rightarrow^<em>a…,a\in V_T}, \特别地, 如果\alpha\Rightarrow^</em>\varepsilon, 则规定\varepsilon\in FIRST(\alpha)$</p>
<p>后继终结符号集: $FOLLOW(A)={a|S\Rightarrow^<em>…Aa…,a\in V_T}, \特别地, 如果S\Rightarrow^</em>…A, 则规定#\in FOLLOW(S)$</p>
<h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><p>可以进行无回溯的自上而下分析</p>
<ul>
<li>不含左递归</li>
<li>产生式右侧的所有非终结符的FIRST集无交集<ul>
<li>$A\rightarrow\alpha_1|\alpha_2|…|\alpha_n\Rightarrow FIRST(\alpha_i)\cap FIRST(\alpha_j)=\Phi, (i\neq j)$</li>
</ul>
</li>
<li>若$\varepsilon\in FIRST(A)$, 则$FIRST(A)\cap FOLLOW(A)=\Phi$</li>
</ul>
<h3 id="LL-1-分析方法"><a href="#LL-1-分析方法" class="headerlink" title="LL(1)分析方法"></a>LL(1)分析方法</h3><ul>
<li>当前输入符号为$a$, 要匹配一个$A$, 且$A\rightarrow\alpha_1|\alpha_2|…|\alpha_n$</li>
<li>若$a\in FIRST(\alpha_i$)集合, 则直接匹配$A\rightarrow\alpha_i$</li>
<li>若$\varepsilon\in FIRST(A)$, 但是$a\in FOLLOW(A)$中, 仍可以匹配</li>
<li>否则报错</li>
</ul>
<h3 id="LL-1-程序构造"><a href="#LL-1-程序构造" class="headerlink" title="LL(1)程序构造"></a>LL(1)程序构造</h3><h4 id="递归下降程序"><a href="#递归下降程序" class="headerlink" title="递归下降程序"></a>递归下降程序</h4><ul>
<li>每个递归过程对应一个非终结符</li>
</ul>
<h4 id="预测分析程序"><a href="#预测分析程序" class="headerlink" title="预测分析程序"></a>预测分析程序</h4><p>使用分析表和符号栈实现LL(1)分析</p>
<p>需要预先构造分析表</p>
<p>略</p>
<h2 id="规范规约"><a href="#规范规约" class="headerlink" title="规范规约"></a>规范规约</h2><p><strong>短语</strong>: </p>
<ul>
<li>$对于文法G, 开始符号S, 若\alpha\beta\delta是一个句型, 如果S\Rightarrow^*\alpha A\delta且A\Rightarrow^+\beta, 则称\beta是句型\alpha\beta\delta相对于A的短语$</li>
<li>$句型语法树中每棵子树的所有叶子结点左右到右排列起来构成一个该句型相对于子树根(A)的短语$</li>
</ul>
<p><strong>直接短语</strong>: </p>
<ul>
<li>$A\Rightarrow\beta$</li>
<li>$只有父子两代的子树形成的短语, 一步推导出终结符的子树$</li>
</ul>
<p><strong>句柄</strong>:</p>
<ul>
<li>$一个句型的最左直接短语$</li>
<li>$语法树中最左的只有父子两代的子树形成的短语$</li>
</ul>
<p><img src="parser/phrase.png" alt=""></p>
<p>句型<code>E+T*F</code>的</p>
<ul>
<li>短语为<code>E+T*F</code>(相对于E), <code>T*F</code>(相对于T)</li>
<li>直接短语为<code>T*F</code></li>
<li>句柄为<code>T*F</code></li>
</ul>
<h2 id="算符优先分析法"><a href="#算符优先分析法" class="headerlink" title="算符优先分析法"></a>算符优先分析法</h2><h3 id="算符优先文法"><a href="#算符优先文法" class="headerlink" title="算符优先文法"></a>算符优先文法</h3><p>算符文法: 任一产生式的右部都不包含两个<strong>相继(并列)的非终结符</strong></p>
<p>最多一个优先关系: 对任何一对终结符, (a,b)最多满足一个优先关系</p>
<p>算符优先文法: 满足最多一个优先关系的算符文法</p>
<h3 id="优先关系表"><a href="#优先关系表" class="headerlink" title="优先关系表"></a>优先关系表</h3><p>优先关系的表格</p>
<h3 id="FIRSTVT-LASTVT"><a href="#FIRSTVT-LASTVT" class="headerlink" title="FIRSTVT, LASTVT"></a>FIRSTVT, LASTVT</h3><p>$FIRSTVT(P)={a|P\Rightarrow^+a…或P\Rightarrow^+Qa…, a\in V_T而Q\in V_N}$</p>
<p>$LASTVT(P)={a|P\Rightarrow^+…a或P\Rightarrow^+…Qa, a\in V_T而Q\in V_N}$</p>
<h3 id="素短语"><a href="#素短语" class="headerlink" title="素短语"></a>素短语</h3><p>素短语: 至少含有一个终结符, 而且除它自身以外不含有任何更小的素短语</p>
<p>最左素短语: 句型最左边的素短语</p>
<h2 id="LR分析法"><a href="#LR分析法" class="headerlink" title="LR分析法"></a>LR分析法</h2><p>L: 从左到右扫描输入串<br>R: 构造最右推导的逆过程<br>LR分析法是严格的规范规约</p>
<p>原理: 在移进-规约过程中寻找句柄</p>
<p>模型: </p>
<ul>
<li>将历史和展望抽象成状态, 整体上是一个FA</li>
<li>一张分析表<ul>
<li>ACTION[s,a]: 状态s遇到输入a应该采取什么动作</li>
<li>GOTO[s,X]: 状态s遇到文法符号X时下一状态是什么, 构成了一个以文法符号为字母表的DFA</li>
</ul>
</li>
</ul>
<p>分类:</p>
<ul>
<li>总控程序: 所有的LR分析器都相同</li>
<li>分析表: 是自动生成语法分析器的关键<ul>
<li>LR(0)表: 基础但有局限性</li>
<li>SLR表: 简单LR表, 实用</li>
<li>规范LR表: 能力强, 代价大</li>
<li>LALR表: 向前LR表, 介于SLR和规范LR之间</li>
</ul>
</li>
</ul>
<p>ACTION表:</p>
<ol>
<li>移进$sN$: 将$N$和输入符号$a$进栈, 读取下一个输入</li>
<li>规约$rN$: 用$N$号产生式$A\Rightarrow\beta$进行规约, 出栈$|\beta|$项, 将$GOTO[s.top, A]$和$A$进栈(规约), <strong>输入不动</strong></li>
<li>接受$acc$: 分析成功结束</li>
<li>报错</li>
</ol>
<p>LR文法: 能够构造LR分析表, 使得每个入口都是唯一确定的文法</p>
<p>LR(k)文法: 每步至多向前检查k个输入符号就能用LR分析器进行分析的文法</p>
<ul>
<li>大多数PL符合LR(1)文法</li>
<li>k=0表示不需要展望</li>
</ul>
<h3 id="LR-0"><a href="#LR-0" class="headerlink" title="LR(0)"></a>LR(0)</h3><p>LR(0)项目: 在文法产生式右部中间间隔处加一个圆点</p>
<ul>
<li>指明了在分析过程的某一时刻看到了产生式的多大部分</li>
</ul>
<p>活前缀: 规范句型的最多到句柄(可以包括句柄)的前缀</p>
<ul>
<li>LR分析时栈里的符号应该始终构成活前缀</li>
</ul>
<h4 id="1-识别活前缀的NFA方法"><a href="#1-识别活前缀的NFA方法" class="headerlink" title="1. 识别活前缀的NFA方法:"></a>1. 识别活前缀的NFA方法:</h4><ul>
<li>只有项目1作为初态, 其他任何项目都认为是终态</li>
<li>连接非$\varepsilon$弧<ul>
<li>$状态i为X\rightarrow X<em>1…X</em>{i-1}\cdot X_i…X_n$</li>
<li>$状态j为X\rightarrow X<em>1…X</em>{i-1}X<em>i\cdot X</em>{i+1}…X_n$</li>
<li>则连接状态$i$到状态$j$, 标志为$X_i$</li>
</ul>
</li>
<li><p>连接$\varepsilon$弧</p>
<ul>
<li>$状态i为X\rightarrow \alpha\cdot A\beta$</li>
<li>则连接状态$i$到所有状态$A\rightarrow\cdot\gamma$, 标志为$\varepsilon$</li>
</ul>
<p><img src="parser/huoqianzhui.png" alt=""></p>
</li>
<li><p>确定化(NFA转DFA)</p>
<ul>
<li>(也可以直接看出来)</li>
</ul>
<p><img src="parser/huoqianzhui2.png" alt=""></p>
</li>
</ul>
<h4 id="2-LR-0-项目集规范族"><a href="#2-LR-0-项目集规范族" class="headerlink" title="2. LR(0)项目集规范族"></a>2. LR(0)项目集规范族</h4><ul>
<li><p>识别活前缀的DFA的项目集的全体称为文法的LR(0)项目集规范族</p>
<ul>
<li>规约项目: $A\rightarrow\alpha\cdot$</li>
<li>接受项目: $S\rightarrow\alpha\cdot$</li>
<li>移进项目: $A\rightarrow\alpha\cdot a\beta$</li>
<li>待约项目: $A\rightarrow\alpha\cdot B\beta$</li>
</ul>
</li>
<li><p>拓广文法</p>
<ul>
<li>构造一个新的文法$G’\supseteq G$</li>
<li>引进一个开始符号, 非终结符$S’$</li>
<li>增加一个产生式$S’\rightarrow S$</li>
<li>唯一接受态: $S’\rightarrow S\cdot$</li>
</ul>
</li>
<li>项目集的闭包$Closure(I)$:<ul>
<li>$I\in Closure(I)$</li>
<li>若$(A\rightarrow\alpha\cdot B\beta)\in Closure(I)$, 则对于任何$B\rightarrow\gamma$, $(B\rightarrow\cdot\gamma)\in Closure(I)$</li>
<li>与$I$同状态的项目集合, 包括子项目</li>
</ul>
</li>
<li>状态转换函数$GO(I,X)$:<ul>
<li>$GO(I, X)=Closure({A\rightarrow\alpha X\cdot\beta|(A\rightarrow\alpha\cdot X\beta)\in I})$</li>
<li>若$I$是对活前缀$\gamma$有效的项目集, 那么$GO(I, X)$就是对$\gamma X$有效的项目集</li>
<li>(接受$X$之后的$Closure$集合)</li>
</ul>
</li>
<li>构造DFA算法 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROCEDURE ITEMSETS(G&#39;)</span><br><span class="line">BEGIN</span><br><span class="line">  C:&#x3D;&#123;Closure(&#123;S&#39;\rightarrow\cdot S&#125;)&#125;</span><br><span class="line">  REPEAT</span><br><span class="line">    FOR C中每个项目集I和G&#39;的每个符号X DO</span><br><span class="line">      IF GO(I, X)非空且不属于C THEN</span><br><span class="line">        C +&#x3D; GO(I, X)</span><br><span class="line">  UNTIL C 不再增大</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>LR(0)文法:</p>
<ul>
<li>拓广文法的识别活前缀的dfa的项目集(LR(0)项目集规范族)不包含任何<strong>冲突</strong>的文法</li>
</ul>
<p>冲突</p>
<ul>
<li>既含移进项目又含规约项目 <ul>
<li><code>E-&gt;E·*E</code></li>
<li><code>E-&gt;E+E·</code></li>
</ul>
</li>
<li>含有多个规约项目 <ul>
<li><code>P-&gt;A·</code></li>
<li><code>Q-&gt;A·</code></li>
</ul>
</li>
</ul>
<p>构造LR(0)分析表:</p>
<ul>
<li>每个项目集为一个状态</li>
<li>包含$S’\rightarrow\cdot S$的集合为初态</li>
</ul>
<p><strong>构造LR(0)的ACTION和GOTO</strong>:</p>
<ul>
<li>若$(A\rightarrow\alpha\cdot a\beta)\in I_k$且$GO(I_k, a)=I_j$, 则$ACTION[k, a]=sj$</li>
<li>若$(A\rightarrow\alpha\cdot)\in I_k$, 则$ACTION[k, a]=rj$</li>
<li>若$(S’\rightarrow S)\in I_k$, 则$ACTION[k, a]=acc$</li>
<li>若$GO(I_k,A)=I_j$, 则$GOTO[k, a]=j$</li>
<li>其他均为报错</li>
</ul>
<p><img src="parser/lr0_table.png" alt=""></p>
<h3 id="SLR"><a href="#SLR" class="headerlink" title="SLR"></a>SLR</h3><p>LR(0)可能会误判: 即使存在项目冲突, 也不一定不合法</p>
<p>假定LR(0)规范族的一个项目集</p>
<script type="math/tex; mode=display">
\begin{aligned}
I=\{
&A_1\rightarrow\alpha\cdot a_1\beta_1,\\
&A_2\rightarrow\alpha\cdot a_2\beta_2,\\
&...\\
&A_m\rightarrow\alpha\cdot a_m\beta_m,\\ 
&B_1\rightarrow\alpha\cdot,\\
&B_2\rightarrow\alpha\cdot,\\
&...\\
&B_n\rightarrow\alpha\cdot\}
\end{aligned}</script><p>如果集合${a_1, …, a_m}, FOLLOW(B_1), …, FOLLOW(B_n)$两两不相交(包括不得有两个FOLLOW集合有#), 则</p>
<ol>
<li>若a是某个ai, i=1,2,…,m, 则移进</li>
<li>若$a\in FOLLOW(B_i), i=1,2,…,n$, 则用产生式$B_i\rightarrow\alpha$进行归约</li>
<li>此外, 报错。</li>
</ol>
<p>冲突性动作的这种解决办法叫做SLR(1)解决办法。上述方法构造出的ACTION与GOTO表如果不含多重入口，则称该文法为<strong>SLR(1)文法</strong></p>
<h3 id="LR-1"><a href="#LR-1" class="headerlink" title="LR(1)"></a>LR(1)</h3><h3 id="LALR"><a href="#LALR" class="headerlink" title="LALR"></a>LALR</h3><p>不考, 略</p>
<h2 id="二义文法的应用"><a href="#二义文法的应用" class="headerlink" title="二义文法的应用"></a>二义文法的应用</h2><h3 id="二义文法"><a href="#二义文法" class="headerlink" title="二义文法"></a>二义文法</h3><ul>
<li>不是LR文法</li>
<li>简洁、自然</li>
<li>可以用文法以外的信息来消除二义</li>
<li>语法分析的效率高（基于消除二义后得到的分析表）</li>
</ul>
<p>举例: E → E + E | E * E | (E) | id</p>
<p>消除二义性:</p>
<ol>
<li>使用文法以外信息来解决分析动作冲突</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>优化</title>
    <url>/compiler-principle/profile.html</url>
    <content><![CDATA[<h2 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h2><p><img src="profile/index.png" alt=""></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>优化：对程序进行各种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。</p>
<p>原则</p>
<ul>
<li>等价</li>
<li>有效</li>
<li>合算</li>
</ul>
<p>级别</p>
<ul>
<li>局部优化</li>
<li>循环优化</li>
<li>全局优化</li>
</ul>
<p>种类</p>
<ul>
<li>删除公用子表达式</li>
<li>复写传播</li>
<li>删除无用赋值</li>
<li>代码外提</li>
<li>强度削弱</li>
<li>变换循环控制条件</li>
<li>合并已知量</li>
</ul>
<h2 id="局部优化"><a href="#局部优化" class="headerlink" title="局部优化"></a>局部优化</h2><h3 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h3><p>基本块</p>
<ul>
<li>指程序中一顺序执行语句序列，其中只有一个入口和一个出口。入口就是其中第一个语句，出口就是其中最后一个语句。</li>
</ul>
<p>活跃</p>
<ul>
<li>基本块中的一个名字在某个给定点之后仍被引用, 则称该名字在给定点是活跃的</li>
</ul>
<p>局部优化</p>
<ul>
<li>局限在基本块范围内的优化</li>
</ul>
<p>划分基本块</p>
<ul>
<li>基本块入口<ul>
<li>程序第一条语句</li>
<li><strong>能</strong>转移到的语句</li>
<li>转移语句后面的语句</li>
</ul>
</li>
<li>基本块的出口(包括)<ul>
<li>基本块入口的前一条语句</li>
<li>转移语句(包括)</li>
<li>停语句(包括)</li>
</ul>
</li>
<li>不在基本块中的语句可以从程序中删除</li>
</ul>
<p><img src="profile/basic_block.png" alt=""></p>
<p>基本块中的优化</p>
<ul>
<li>删除公用子表达式</li>
<li>删除无用赋值</li>
<li>合并已知量: <code>T1=2; T2=4*T1;</code> =&gt; <code>T2=8;</code></li>
<li>临时变量改名</li>
<li>交换语句的位置</li>
<li>代数变换: 删除<code>x=x+0; x=x*1;</code>, <code>x=y^2;</code> =&gt; <code>x=y*y;</code></li>
</ul>
<h3 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h3><ul>
<li>把基本块编号后按执行顺序连接成一张图</li>
<li>入口语句是流图的首结点</li>
</ul>
<p>前驱和后继</p>
<ul>
<li>在程序序列中, 若A,B相邻而且A最后一条语句不是无条件跳转, 则称A是B的前驱, B为A的后继</li>
</ul>
<p><img src="profile/program_flow.png" alt=""></p>
<h3 id="基本块的DAG表示"><a href="#基本块的DAG表示" class="headerlink" title="基本块的DAG表示"></a>基本块的DAG表示</h3><ul>
<li>用带有标记或附加信息的DAG来表示变量间的关系</li>
<li>叶结点: 以<strong>标识符或常数</strong>作为标记</li>
<li>内部结点: 以<strong>运算符</strong>作为标记</li>
<li>每个结点可以有<strong>附加标识符</strong>: 表示附加标识符具有相同的值</li>
</ul>
<h3 id="基本块的DAG优化算法"><a href="#基本块的DAG优化算法" class="headerlink" title="基本块的DAG优化算法"></a>基本块的DAG优化算法</h3><p>基本块代码分类</p>
<ul>
<li>0型: 单纯赋值语句<code>A:=B</code></li>
<li>1型: 一元运算赋值<code>A:=op B</code></li>
<li>2型: 二元运算赋值<code>A:=B op C</code>/数组取值赋值<code>A:=B[C]</code></li>
</ul>
<p>对基本块中每一四元式，依次执行以下步骤:</p>
<ol>
<li>如果是0型, 记<code>NODE(B)</code>的值为<code>n</code>, 转4</li>
<li>如果存在任意一个操作数无定义, 则构造该操作数结点</li>
<li>如果所有操作数都是常数<ol>
<li>如果<code>NODE(B)</code>(或<code>NODE(C)</code>)是新构造的结点, 删除</li>
<li>计算<code>op</code>, 记为<code>P</code></li>
<li>如果<code>NODE(P)</code>无定义, 构造之, 记为<code>n</code></li>
</ol>
</li>
<li>否则<ol>
<li>检查DAG中是否已经存在结点<code>op</code>, 如果没有则构造之, 记为<code>n</code></li>
</ol>
</li>
<li>删除无用赋值<ol>
<li>如果<code>A</code>已经在某个结点处定义, 删除之, 把<code>A</code>附在<code>n</code>结点上, 令<code>NODE(A)=n</code></li>
</ol>
</li>
</ol>
<p>DAG优化算法</p>
<ul>
<li>执行上述算法</li>
<li>在基本块外被定值的标识符作为叶子结点上的标识符</li>
<li>在基本块内被定值且在基本块后被引用的标识符作为结点上的附加标识符</li>
</ul>
<h2 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h2><p>不考, 略</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-11-29.html</url>
    <content><![CDATA[<h1 id="用-Hexo-搭建了个人-blog"><a href="#用-Hexo-搭建了个人-blog" class="headerlink" title="用 Hexo 搭建了个人 blog"></a>用 Hexo 搭建了个人 blog</h1><h2 id="Hexo-基本操作"><a href="#Hexo-基本操作" class="headerlink" title="Hexo 基本操作"></a>Hexo 基本操作</h2><ul>
<li><p>安装</p>
<p>  <code>npm install -g hexo-cli</code></p>
</li>
<li><p>初始化hexo</p>
<p>  <code>hexo init</code></p>
<ul>
<li>当前目录必须是空的</li>
</ul>
</li>
<li><p>新建文章</p>
<p>  <code>hexo new [layout] name</code></p>
<ul>
<li><p>layout 可以是 post, page, draft 之一</p>
</li>
<li><p>分别保存至 source/_posts, source, source/_drafts 中</p>
</li>
<li><p>新建文件名可以在 _config.yml 里面指定, <code>new_post_name</code>, 默认为 <code>name.md</code></p>
</li>
</ul>
</li>
<li><p>临时开启 server</p>
<p>  <code>hexo server</code></p>
</li>
</ul>
<h1 id="React-入门"><a href="#React-入门" class="headerlink" title="React 入门"></a>React 入门</h1><h2 id="复习-JavaScript"><a href="#复习-JavaScript" class="headerlink" title="复习 JavaScript"></a>复习 JavaScript</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript">很好的文章</a></li>
</ul>
<h1 id="Vue-和-React-路由模块的区别"><a href="#Vue-和-React-路由模块的区别" class="headerlink" title="Vue 和 React 路由模块的区别"></a>Vue 和 React 路由模块的区别</h1><h2 id="Vue-路由"><a href="#Vue-路由" class="headerlink" title="Vue 路由"></a>Vue 路由</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes: [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/inspect&#x27;</span>,</span><br><span class="line">        component: Layout,</span><br><span class="line">        redirect: <span class="string">&#x27;/inspect/table1&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;报表&#x27;</span>,</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;报表&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;table&#x27;</span> &#125;,</span><br><span class="line">        children: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;table1&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;Table&#x27;</span>,</span><br><span class="line">            component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/table/index&#x27;</span>),</span><br><span class="line">            meta: &#123; <span class="attr">title</span>: <span class="string">&#x27;Table&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;table&#x27;</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Vue-深入-——-MVVM-框架"><a href="#Vue-深入-——-MVVM-框架" class="headerlink" title="Vue 深入 —— MVVM 框架"></a>Vue 深入 —— MVVM 框架</h1><ul>
<li><p>Observer 数据劫持</p>
</li>
<li><p>Dep/Watcher 发布订阅</p>
</li>
<li><p>Compiler 解析 <code>&#123;&#123; &#125;&#125;</code>, 创建watcher, 求解表达式</p>
</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-11-30.html</url>
    <content><![CDATA[<h1 id="Github-Developer-Settings"><a href="#Github-Developer-Settings" class="headerlink" title="Github Developer Settings"></a>Github Developer Settings</h1><ul>
<li><p>GitHub Apps</p>
</li>
<li><p>OAuth Apps</p>
<ul>
<li>需要用到Github API的App</li>
</ul>
</li>
<li><p>Personal access tokens</p>
<ul>
<li><p>Tokens you have generated that can be used to access the GitHub API. </p>
</li>
<li><p>权限类似于账号+密码登录</p>
</li>
</ul>
</li>
</ul>
<h1 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h1><ul>
<li><p>类似Travis-CI的持续集成平台</p>
</li>
<li><p>使用方法</p>
<ul>
<li><p>在项目根目录创建 .github/workflows</p>
</li>
<li><p>继续创建 pages.yml</p>
</li>
<li><p>关键字: jobs, runs-on, steps, name, uses, with等等</p>
</li>
</ul>
</li>
</ul>
<h1 id="Hexo博客评论系统"><a href="#Hexo博客评论系统" class="headerlink" title="Hexo博客评论系统"></a>Hexo博客评论系统</h1><ul>
<li><p>Gitalk</p>
<ul>
<li><p>利用Github Issues功能实现的评论系统, 开源</p>
</li>
<li><p>不支持回复评论</p>
</li>
<li><p>修改评论需要打开对应的Issue页修改</p>
</li>
<li><p>登录需要的Github权限太高(Github自身问题)</p>
</li>
</ul>
</li>
<li><p>Disqus</p>
<ul>
<li><p>界面好看</p>
</li>
<li><p>需要翻墙才能正常使用</p>
</li>
</ul>
</li>
</ul>
<h1 id="Code-Server"><a href="#Code-Server" class="headerlink" title="Code-Server"></a>Code-Server</h1><ul>
<li>浏览器端的vscode</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-01.html</url>
    <content><![CDATA[<h1 id="转换dos格式行尾为unix行尾"><a href="#转换dos格式行尾为unix行尾" class="headerlink" title="转换dos格式行尾为unix行尾"></a>转换dos格式行尾为unix行尾</h1><ul>
<li><p>工具: dos2unix</p>
</li>
<li><p>单文件: <code>dos2unix input output</code></p>
</li>
<li><p>递归转换: <code>find . -type f -print0 | xargs -0 dos2unix</code></p>
</li>
</ul>
<h1 id="Linux下-nodejs-环境配置"><a href="#Linux下-nodejs-环境配置" class="headerlink" title="Linux下 nodejs 环境配置"></a>Linux下 nodejs 环境配置</h1><ul>
<li><p>安装node(不是最新版): <code>sudo apt install nodejs</code></p>
</li>
<li><p>使用<code>n</code>来切换node版本: </p>
<ul>
<li><p><code>sudo npm install -g n</code></p>
</li>
<li><p><code>sudo n stable</code></p>
</li>
</ul>
</li>
<li><p>安装yarn: <code>sudo npm install -g yarn</code></p>
</li>
</ul>
<h1 id="Nodejs版本切换"><a href="#Nodejs版本切换" class="headerlink" title="Nodejs版本切换"></a>Nodejs版本切换</h1><ul>
<li><p>使用<code>n</code></p>
<ul>
<li><p>方法:</p>
<ul>
<li><p>安装: <code>sudo npm install -g n</code></p>
</li>
<li><p>切换版本: <code>sudo n stable</code></p>
</li>
</ul>
</li>
<li><p>缺点: 据说会导致node modules混乱</p>
</li>
</ul>
</li>
<li><p>使用<code>nvm</code></p>
</li>
</ul>
<h1 id="清理npm缓存"><a href="#清理npm缓存" class="headerlink" title="清理npm缓存"></a>清理npm缓存</h1><ul>
<li><p><code>npm cache clean --force</code></p>
</li>
<li><p>The default cache direconstructory is ~/.npm on Posix (mac or linux), or %AppData%/npm-cache on Windows.</p>
</li>
</ul>
<h1 id="Javascript-复习"><a href="#Javascript-复习" class="headerlink" title="Javascript 复习"></a>Javascript 复习</h1><ul>
<li><p>数据类型</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Symbol (new in ES2015)</li>
<li>Object<ul>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
</ul>
</li>
<li>null</li>
<li>undefined</li>
</ul>
</li>
<li><p>关于变量</p>
<ul>
<li><p>用<code>var</code>定义的变量具有<strong>函数</strong>作用域</p>
<ul>
<li><p>name hiding: <code>(function () &#123; ... &#125;)();</code></p>
</li>
<li><p>允许递归版(IIFEs): <code>(function foo() &#123; ...foo()... &#125;)();</code></p>
</li>
</ul>
</li>
<li><p>尽量使用<code>let</code>和<code>const</code></p>
</li>
</ul>
</li>
<li><p>关于Array:</p>
<ul>
<li><p>相当于一个下标是整数, 有一个length属性, 外表看起来像是数组的Object</p>
</li>
<li><p>数组的length属性是数组中最大的下标+1</p>
</li>
<li><p>当然作为Object, 也可以有非整数类型的下标</p>
</li>
<li><p>for…in…循环遍历实际存储的值, for…of…循环遍历下标</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = []</span><br><span class="line"></span><br><span class="line">a[<span class="number">100</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> a) <span class="built_in">console</span>.log(i) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> a) <span class="built_in">console</span>.log(i) <span class="comment">// undefined, undefined, ... , 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关于String</p>
<ul>
<li><p>String + any = String</p>
</li>
<li><p>any + String = String</p>
</li>
<li><p>注意结合性</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="string">&#x27;3&#x27;</span> <span class="comment">// &#x27;33&#x27;</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">2</span> + <span class="number">3</span> <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关于Object:</p>
<ul>
<li><p>对象字面量<code>&#123;&#125;</code>等效于<code>new Object()</code></p>
<ul>
<li><p>不过<code>Object()</code>可以被重载</p>
</li>
<li><p>对象字面量不能被重载</p>
</li>
</ul>
</li>
<li><p><code>new XXX()</code>: 相当于创建了一个类实例(实际上是个Object), <code>XXX()</code>函数可以对其进行进一步修饰</p>
</li>
</ul>
</li>
<li><p>关于<code>function</code>:</p>
<ul>
<li>函数是对象</li>
</ul>
</li>
<li><p>关于<code>new</code>:</p>
<ul>
<li><p>new的功能:</p>
<ul>
<li><p>创建一个空对象{}</p>
</li>
<li><p>设置空对象的<code>__proto__</code>(与浏览器实现有关)为构造函数的<code>prototype</code></p>
</li>
<li><p>让this指向空对象</p>
</li>
<li><p>执行构造函数, 传入参数this</p>
</li>
<li><p>如果构造函数不返回一个对象, 则返回this</p>
</li>
</ul>
</li>
<li><p>模仿一个new:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fake_new</span>(<span class="params">ctor, ...args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Object</span>.create(ctor.prototype); <span class="comment">// ES5 创建新对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">///* before ES5 */</span></span><br><span class="line">    <span class="comment">// function F() &#123;&#125;</span></span><br><span class="line">    <span class="comment">// F.prototype = ctor.prototype;</span></span><br><span class="line">    <span class="comment">// let x = new F();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = ctor.call(x, ...args); <span class="comment">//借用外部传入的构造器给obj设置属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? res : x; <span class="comment">//确保构造器总是返回一个对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关于<code>this</code>:</p>
<ul>
<li><p>如何正确绑定this</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123; ... &#125;, <span class="comment">// bad, `this` is bound to the object</span></span><br><span class="line">    foo = <span class="function">() =&gt;</span> &#123; ... &#125;, <span class="comment">// good, `this` is bound dynamically</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Javascript面向对象:</p>
<ul>
<li><p>不用<code>new</code>模拟对象, 利用闭包</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePerson</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        first: first,</span><br><span class="line">        last: last,</span><br><span class="line">        fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.first + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.last;</span><br><span class="line">        &#125;,</span><br><span class="line">        fullNameReversed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.last + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = makePerson(<span class="string">&#x27;Simon&#x27;</span>, <span class="string">&#x27;Willison&#x27;</span>);</span><br><span class="line">s.fullName(); <span class="comment">// &quot;Simon Willison&quot;</span></span><br><span class="line">s.fullNameReversed(); <span class="comment">// &quot;Willison, Simon&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>new</code></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.first = first;</span><br><span class="line">    <span class="built_in">this</span>.last = last;</span><br><span class="line">    <span class="built_in">this</span>.fullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.first + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.last;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.fullNameReversed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 每次创建对象时, 这个函数都会被拷贝</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.last + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.first;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Person(<span class="string">&#x27;Simon&#x27;</span>, <span class="string">&#x27;Willison&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化: 减少函数对象的拷贝, 利用原型链</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.first = first;</span><br><span class="line">    <span class="built_in">this</span>.last = last;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.fullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.first + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.last;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.fullNameReversed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.last + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="React-复习"><a href="#React-复习" class="headerlink" title="React 复习"></a>React 复习</h1></li>
</ul>
</li>
<li><p>JSX语法</p>
  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;h1 className=<span class="string">&quot;greeting&quot;</span> onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Hello, world!</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">    <span class="string">&#x27;h1&#x27;</span>, <span class="comment">// label type</span></span><br><span class="line">    &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>, <span class="attr">onClick</span>: <span class="built_in">this</span>.handleClick&#125;, <span class="comment">// attrs</span></span><br><span class="line">    <span class="string">&#x27;Hello, world!&#x27;</span> <span class="comment">// children</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>遇到<code>&lt;</code>开始解析HTML, 遇到<code>&#123;</code>开始解析Javascript</p>
</li>
<li><p>要比Vue的模板更加灵活</p>
</li>
</ul>
</li>
<li><p>数据流</p>
<ul>
<li><p>外层-&gt;内层组件: <code>props</code>, 只读</p>
</li>
<li><p>组件自己的状态: <code>state</code>, 可以修改</p>
<ul>
<li><p>初始化: 在构造函数内直接赋值</p>
</li>
<li><p>更新: 通过<code>this.setState(&#123;&#125;)</code></p>
</li>
<li><p>state可以被传递给子组件作为子组件的props</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>受控组件:</p>
<ul>
<li><p>不自己维护状态的组件</p>
</li>
<li><p>状态变化全部交给外部来做: props.value, props.onValueChanged()</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
        <tag>npm</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-02.html</url>
    <content><![CDATA[<ul>
<li><p>React</p>
<ul>
<li>children属性: 子元素构成的数组</li>
</ul>
</li>
<li><p>React-redux</p>
<ul>
<li><p>引入: <code>import &#123;...&#125; from &#39;react-redux&#39;</code></p>
</li>
<li><p><code>Store</code></p>
<ul>
<li><p>Redux maintains a <code>store</code>, which hold <code>state</code> and <code>reducer</code></p>
</li>
<li><p><code>createStore(reducer, initState)</code></p>
<ul>
<li><code>reducer</code> and <code>initState</code> should have the same keys</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Reducer</code>: (state, action) =&gt; (newstate)</p>
</li>
<li><p><code>&lt;Provider&gt;</code>: Inject global <code>state</code> to its children component </p>
</li>
<li><p><code>connect(mapStateToProps)(Component)</code></p>
<ul>
<li><p>map current states to <code>Component</code>‘s props</p>
</li>
<li><p><code>mapStateToProps</code>: is a function: (state) =&gt; { …someProp }</p>
</li>
<li><p>一般和<Provider>结合起来用</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>React-Router</p>
<ul>
<li><p>引入: <code>import &#123;&#125; from &#39;react-router-dom&#39;</code></p>
</li>
<li><p><code>&lt;Route path&gt;</code>: 当url与path匹配时, 渲染内容</p>
<ul>
<li><p><code>&lt;BrowserRouter&gt;, &lt;HashRouter&gt;</code>: <Route>的容器</p>
</li>
<li><p><code>&lt;Switch&gt;</code>: 保证其下的所有Route只会选中一个</p>
</li>
<li><p>参数化匹配</p>
<ul>
<li><p>参数定义: <code>path=&quot;/hsl/:h/:s/:l&quot;</code></p>
</li>
<li><p>参数获取: 在children组件中 <code>let &#123; h, s, l &#125; = useParams();</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>&lt;Link to&gt;</code>: 跳转到to的a标签</p>
<ul>
<li><code>&lt;Redirect&gt;</code>: 渲染时自动跳转</li>
</ul>
</li>
<li><p>嵌套使用: </p>
  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; path, url &#125; = useRouteMatch(); <span class="comment">// 获取上一级的path和url</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;Route path=&#123;<span class="string">`<span class="subst">$&#123;path&#125;</span>/next`</span>&#125;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Vue-Router</p>
<ul>
<li><p><code>&lt;router-link :to&gt;</code>: 跳转的a标签</p>
</li>
<li><p><code>&lt;router-view&gt;</code>: 匹配的路由内容会渲染到这里</p>
</li>
<li><p><code>Router</code>: 在这里定义全局路由表</p>
</li>
</ul>
</li>
<li><p>Ubuntu 安装 rpm 包</p>
<ul>
<li><p>sudo apt install alien</p>
</li>
<li><p>sudo alien packagename.rpm</p>
</li>
<li><p>sudo apt install ./packagename.deb</p>
</li>
<li><p>一步到位: sudo alien -i packagename.rpm</p>
</li>
</ul>
</li>
<li><p>Oracle 的连接方式</p>
<ul>
<li><p>SID/System IDentifier: 数据库实例的全局唯一ID, 每个实例都不一样</p>
</li>
<li><p>SERVICE_NAME: 用于对外提供服务的名字, 被客户端使用</p>
<ul>
<li>也可以被数据库端用来区分对不同客户端提供的服务</li>
</ul>
</li>
<li><p>TNS/Transparent Network Substrate: 由Oracle创造的, 专门用于Oracle数据库连接的, 基于TCP/IP, SDP和命名管道的, 同构p2p连接技术</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; STATE.WORLD是一个TNS Name</span><br><span class="line">STAGE.WORLD &#x3D;</span><br><span class="line">    (DESCRIPTION &#x3D;</span><br><span class="line">        (ADDRESS &#x3D;</span><br><span class="line">            (PROTOCOL &#x3D; TCP) </span><br><span class="line">            (PORT &#x3D; 1521)</span><br><span class="line">            (HOST &#x3D; LITTLECOMPUTER.ACME.ORG) &#x2F;&#x2F; 服务器地址</span><br><span class="line">        )</span><br><span class="line">        (CONNECT_DATA &#x3D; (SID &#x3D; MYSID)) &#x2F;&#x2F; 数据库标识, 可以使用SID或者SERVICE_NAME</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; PROD.WORLD也是一个TNS Name</span><br><span class="line">PROD.WORLD &#x3D;</span><br><span class="line">    (DESCRIPTION &#x3D;</span><br><span class="line">        (ADDRESS &#x3D;</span><br><span class="line">            (PROTOCOL &#x3D; TCP) </span><br><span class="line">            (PORT &#x3D; 1521)</span><br><span class="line">            (HOST &#x3D; BIGCOMPUTER.ACME.ORG)</span><br><span class="line">        )</span><br><span class="line">        (CONNECT_DATA &#x3D; (SERVICE_NAME &#x3D; MYNAME))</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-03.html</url>
    <content><![CDATA[<h1 id="秘书问题"><a href="#秘书问题" class="headerlink" title="秘书问题"></a>秘书问题</h1><ul>
<li><p>又称相亲问题、止步问题、见好就收问题、苏丹的嫁妆问题、挑剔的求婚者问题等</p>
</li>
<li><p>要聘请一名秘书，有 n 个应聘者。每次面试一人，面试后就要及时决定是否聘他，如果当时决定不聘他，他便不会回来。面试后总能清楚了解应聘者的合适程度，并能和之前的每个人做比较。问什么样的策略，才使最佳人选被选中的概率最大。 </p>
</li>
<li><p>答案:</p>
  <details>
  <summary>展开</summary>

  - 这个问题的最优解是一个停止规则。在这个规则里，面试官会拒绝头 r - 1 个应聘者 (令他们中的最佳人选为 应聘者 M)，然后选出第一个比 M 好的应聘者。可见最优策略包含于这个系列的策略中。 (如果M在所有n个应聘者中也是最好的一个，那么这个策略将选不出任何人选)对于任意的截断值 r，最佳人选被选中的概率是： 

      $${\displaystyle {\begin{aligned}P(r)&=\sum _{i=1}^{n}P\left({\text{applicant }}i{\text{ is selected}}\cap {\text{applicant }}i{\text{ is the best}}\right)\\&=\sum _{i=1}^{n}P\left({\text{applicant }}i{\text{ is selected}}|{\text{applicant }}i{\text{ is the best}}\right)\cdot P\left({\text{applicant }}i{\text{ is the best}}\right)\\&=\left[\sum _{i=1}^{r-1}0+\sum _{i=r}^{n}P\left(\left.{\begin{array}{l}{\text{the best of the first }}i-1{\text{ applicants}}\\{\text{is in the first }}r-1{\text{ applicants}}\end{array}}\right|{\text{applicant }}i{\text{ is the best}}\right)\right]\cdot {\frac {1}{n}}\\&=\left[\sum _{i=r}^{n}{\frac {r-1}{i-1}}\right]\cdot {\frac {1}{n}}\quad =\quad {\frac {r-1}{n}}\sum _{i=r}^{n}{\frac {1}{i-1}}.\end{aligned}}}$$

  - 当n趋近于无穷大时

      $${\displaystyle P(x)=x\int _{x}^{1}{\frac {1}{t}}\,dt=-x\ln(x).}$$

  - 求出最优的x值为

      $$\frac {1}{e}$$

  </details>


</li>
</ul>
<h1 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h1><ul>
<li><p>root: 表示去哪个目录下寻找对应url的文件, 实际上是添加前缀</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;aaaa&#x2F; &#123;</span><br><span class="line">    root &#x2F;home&#x2F;tom&#x2F;www&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>请求: <a href="http://(hostname">http://(hostname</a>)<span style="background-color: yellow;">/aaaa/</span>hello.txt</p>
</li>
<li><p>返回: <span style="background-color: #cdffd8;">/home/tom/www</span><span style="background-color: yellow;">/aaaa/</span>hello.txt</p>
</li>
</ul>
</li>
<li><p>alias: 表示把匹配成功的路径<strong>替换</strong>成alias</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;aaaa&#x2F; &#123;</span><br><span class="line">    alias &#x2F;home&#x2F;tom&#x2F;www&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>请求: <a href="http://(hostname">http://(hostname</a>)<span style="background-color: yellow;">/aaaa/</span>hello.txt </p>
</li>
<li><p>返回: <span style="background-color: #cdffd8;">/home/tom/www/</span>hello.txt</p>
</li>
</ul>
</li>
<li><p>PS: Nginx会自动将两个连续的斜杠替换成一个</p>
</li>
</ul>
<h1 id="Flask-嵌套路由配置"><a href="#Flask-嵌套路由配置" class="headerlink" title="Flask 嵌套路由配置"></a>Flask 嵌套路由配置</h1><ul>
<li><p>使用<code>register_blueprint</code>时的<code>url_prefix</code>参数</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create app, blueprints, etc.</span></span><br><span class="line">app.register_blueprint(myblueprint, url_prefix=<span class="string">&#x27;/somepath&#x27;</span>)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<h1 id="视频网站设计思考"><a href="#视频网站设计思考" class="headerlink" title="视频网站设计思考"></a>视频网站设计思考</h1></li>
<li><p>视频文件存储到哪里: OSS对象存储服务</p>
</li>
</ul>
<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><ol>
<li><p>读未提交(Read Uncommitted)</p>
</li>
<li><p>读已提交(Read Committed)/不可重复读 大多数数据库默认的隔离级别</p>
</li>
<li><p>可重复读(Repeatable-Read) mysql数据库所默认的级别</p>
</li>
<li><p>序列化(serializable)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Math</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-04.html</url>
    <content><![CDATA[<h1 id="Java-包-Package-Jar和模块-Module-的区别"><a href="#Java-包-Package-Jar和模块-Module-的区别" class="headerlink" title="Java 包(Package), Jar和模块(Module)的区别"></a>Java 包(Package), Jar和模块(Module)的区别</h1><ul>
<li><p>包 (Package)</p>
<ul>
<li><p>是Java源文件的集合, 包含Class/Interface/Annotation的定义</p>
</li>
<li><p>与文件系统中的目录对应</p>
</li>
<li><p>主要目的是<em>防止命名冲突</em></p>
</li>
</ul>
</li>
<li><p>Jar (Java Archive File)</p>
<ul>
<li><p>是编译后的Java代码(<code>.class</code>)的压缩包</p>
</li>
<li><p>实际上是一个zip格式文件</p>
</li>
<li><p>对Jar的操作用<code>jar</code>命令, 其语法类似Linux下的<code>tar</code></p>
<ul>
<li><p>创建Jar包: <code>jar cvf test.jar test</code></p>
</li>
<li><p>解压Jar包: <code>jar xvf test.jar</code></p>
</li>
<li><p>列举Jar包的内容: <code>jar tvf test.jar</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>模块 (Module)</p>
<ul>
<li><p>是Java语言内置的一种管理组件之间依赖关系的方法, 在Java 9被引入</p>
</li>
<li><p>Module 解决的问题:</p>
<ul>
<li><p>在Java 9之前, <strong>主要使用package作为封装方式，使用Jar作为模块, 封装方式由 package和访问修饰符 (private, protected, public,包私有) 控制</strong></p>
<ul>
<li><p>任何模块都能访问其他模块的public的代码，不同Jar下的同名包可以相互访问包私有的代码。</p>
</li>
<li><p>无法控制非平台开发者对平台内部包的访问，如应用代码可以访问sun.misc、com.sun.security这样和具体平台绑定的包。</p>
</li>
<li><p>没有明确的依赖信息，模块开发者无法设置必须的依赖，模块使用者不清楚该模块必须依赖哪些模块。只能使用外部的工具，如Maven、Gradle、OSGI等。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Module 的优势</p>
<ul>
<li><p>明确的依赖配置，JPMS会在编译和运行之前检查当前环境是否满足依赖的要求。JPMS会检查版本冲突，即当有两个模块暴露了相同的包名时，系统会抛出异常。JPMS支持传递性依赖。</p>
</li>
<li><p>强大的封装，模块可以明确指定哪些包能暴露给哪些模块，JPMS不允许代码使用反射的方式访问不对外开放的包。</p>
</li>
<li><p>性能优化，JPMS完全清楚哪些模块是需要的，所以不需要的模块不会被JVM载入。</p>
</li>
</ul>
</li>
<li><p>Module 的不足:</p>
<ul>
<li>缺乏对模块的版本的支持</li>
</ul>
</li>
<li><p>特点:</p>
<p>  <img src="https://cdn.7c00h.xyz/images/2020-12-04-java-module.jpg" alt=""></p>
</li>
</ul>
</li>
</ul>
<h1 id="Linux-Ubuntu-硬件管理"><a href="#Linux-Ubuntu-硬件管理" class="headerlink" title="Linux (Ubuntu) 硬件管理"></a>Linux (Ubuntu) 硬件管理</h1><ul>
<li><p>通用</p>
<ul>
<li><code>lshw -short</code>: 列举所有硬件信息</li>
</ul>
</li>
<li><p>CPU</p>
<ul>
<li><p><code>lscpu</code>: 查看CPU信息</p>
</li>
<li><p><code>cat /proc/cpuinfo</code>: 查看每个CPU的信息</p>
</li>
</ul>
</li>
<li><p>内存</p>
<ul>
<li><p><code>free [-m|-g|-k|-b|-h]</code>: 查看内存使用情况</p>
</li>
<li><p><code>cat /proc/meminfo</code>: 查看内存详细使用情况</p>
</li>
<li><p><code>dmidecode -t memory</code>: 查看内存硬件信息</p>
</li>
</ul>
</li>
<li><p>硬盘</p>
<ul>
<li><p><code>lsblk</code>: 查看硬盘和分区信息</p>
</li>
<li><p><code>fdisk -l</code>: 查看详细分区表</p>
</li>
<li><p><code>df -h</code>: 查看硬盘剩余空间</p>
</li>
</ul>
</li>
<li><p>主板 BIOS</p>
<ul>
<li><code>dmidecode -t bios</code>: 查看bios信息</li>
</ul>
</li>
<li><p>PCI设备</p>
<ul>
<li><code>lspci</code></li>
</ul>
</li>
<li><p>网卡</p>
<ul>
<li><p><code>lspci | grep -i &#39;Ethernet&#39;</code>: 查看网卡硬件信息 (Ethernet 以太网)</p>
</li>
<li><p><code>lspci | grep -i &#39;Wireless&#39;</code>: 查看无线网卡硬件信息</p>
</li>
<li><p><code>ifconfig -a</code>: 查看系统的所有网络接口</p>
</li>
</ul>
</li>
<li><p>USB 设备</p>
<ul>
<li><code>lsusb</code></li>
</ul>
</li>
</ul>
<h1 id="apt-remove-与-apt-purge-的区别"><a href="#apt-remove-与-apt-purge-的区别" class="headerlink" title="apt remove 与 apt purge 的区别"></a>apt remove 与 apt purge 的区别</h1><ul>
<li>purge会删除配置文件, 而remove只会删除程序文件</li>
</ul>
<h1 id="Java-学习"><a href="#Java-学习" class="headerlink" title="Java 学习"></a>Java 学习</h1><ul>
<li><p>Java多线程</p>
<ul>
<li>interrupt() 向该进程发送中断信号, 具体怎么处理由该进程实现</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-05.html</url>
    <content><![CDATA[<h1 id="Java-Spring-框架学习"><a href="#Java-Spring-框架学习" class="headerlink" title="Java Spring 框架学习"></a>Java Spring 框架学习</h1><p>Spring框架，它最主要的功能就是管理一堆使App（应用）发挥功能的类，这些作为整个App的基石、主干的类，就叫做bean。</p>
<p>要管理bean，也即是这堆发挥业务功能的类，就不能直接把它们new出来，这样缺乏统一的调度。所以，Spring使用.xml配置文件作为媒介，以IoC（Inversion of Control 控制反转）作为工具，将这些bean拿给Spring container作统一管理。</p>
<h1 id="Git-submodule-使用"><a href="#Git-submodule-使用" class="headerlink" title="Git submodule 使用"></a>Git submodule 使用</h1><ul>
<li><p>添加子模块</p>
<ul>
<li><code>git submodule add &lt;url&gt; &lt;path&gt;</code></li>
</ul>
</li>
<li><p>设置子模块的分支</p>
<ul>
<li><code>git submodule set-branch --branch &lt;branch&gt; &lt;path&gt;</code></li>
</ul>
</li>
<li><p>克隆下来的项目包含子模块</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git submodule init</span><br><span class="line">$ git submodule update</span><br></pre></td></tr></table></figure>
<p>  或者</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure></li>
<li><p>子模块的更新</p>
<ol>
<li><p>在子模块内部, 作为一般的git项目更新(<code>pull</code>)</p>
</li>
<li><p>在项目目录下<code>git add</code></p>
</li>
</ol>
</li>
<li><p>子模块的删除</p>
<ul>
<li><p><code>rm -rf 子模块目录</code> 删除子模块目录及源码</p>
</li>
<li><p>删除项目目录下.gitmodules文件中子模块相关条目</p>
</li>
<li><p>vi .git/config 删除配置项中子模块相关条目</p>
</li>
<li><p><code>rm .git/module/*</code> 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可</p>
</li>
</ul>
</li>
</ul>
<h1 id="Github-开源项目包含不想公开的密码-Token等怎么处理"><a href="#Github-开源项目包含不想公开的密码-Token等怎么处理" class="headerlink" title="Github 开源项目包含不想公开的密码/Token等怎么处理"></a>Github 开源项目包含不想公开的密码/Token等怎么处理</h1><p>可以将隐私数据包含在项目的Secret设置中, 在Github Action中使用脚本将隐私数据注入到文件中</p>
<h1 id="YAML-语言"><a href="#YAML-语言" class="headerlink" title="YAML 语言"></a>YAML 语言</h1><p>基本类型:</p>
<blockquote>
<ul>
<li><p>String</p>
</li>
<li><p>Bool: <code>true</code>, <code>false</code></p>
</li>
<li><p>Int</p>
</li>
<li><p>Number</p>
</li>
<li><p>null: <code>~</code></p>
</li>
<li><p>Time: ISO8601 格式, 例<code>2001-12-14t21:59:43.10-05:00</code></p>
</li>
<li><p>Date: <code>1976-07-31</code></p>
</li>
</ul>
</blockquote>
<p>注释: <code>#</code></p>
<p>使用左端对齐的键值对表示对象:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">key1:</span> <span class="string">abc</span></span><br><span class="line">  <span class="attr">key2:</span> <span class="number">123</span></span><br><span class="line">  <span class="attr">key3:</span> <span class="string">sss</span></span><br></pre></td></tr></table></figure><br>使用以<code>-</code>开头的对齐的值表示数组:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fruits:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">orange</span></span><br></pre></td></tr></table></figure><br>数组套对象:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">objs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">object</span> <span class="string">A</span></span><br><span class="line">    <span class="attr">desp:</span> <span class="string">I&#x27;am</span> <span class="string">an</span> <span class="string">object</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Object</span> <span class="string">B</span></span><br><span class="line">    <span class="attr">desp:</span> <span class="string">I&#x27;am</span> <span class="string">another</span> <span class="string">object</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Object</span> <span class="string">C</span></span><br><span class="line">    <span class="attr">desp:</span> <span class="string">I&#x27;am</span> <span class="string">still</span> <span class="string">an</span> <span class="string">object</span></span><br></pre></td></tr></table></figure><br>数组套数组:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">matrix:</span> </span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">a11</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a12</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a13</span></span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">a21</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a22</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a23</span></span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">a31</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a32</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a33</span></span><br></pre></td></tr></table></figure><br>对象套数组:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">frezcirno</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Boy</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Handsome</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Student</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Cool</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-06.html</url>
    <content><![CDATA[<h1 id="学习Oracle使用"><a href="#学习Oracle使用" class="headerlink" title="学习Oracle使用"></a>学习Oracle使用</h1><p><a href="../oracledb/index">OracleDB</a></p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-07.html</url>
    <content><![CDATA[<h1 id="Visio-画图如何添加自定义连接点"><a href="#Visio-画图如何添加自定义连接点" class="headerlink" title="Visio 画图如何添加自定义连接点"></a>Visio 画图如何添加自定义连接点</h1><p>在工具栏选中”连接点”</p>
<p>按住<kbd>Ctrl</kbd>键, 在画布上点击即可</p>
<p>有时候可能需要多点几次</p>
<h1 id="为什么校园网这么卡"><a href="#为什么校园网这么卡" class="headerlink" title="为什么校园网这么卡"></a>为什么校园网这么卡</h1><h1 id="Linux-创建用户时忘了使用-m参数创建用户目录怎么办"><a href="#Linux-创建用户时忘了使用-m参数创建用户目录怎么办" class="headerlink" title="Linux 创建用户时忘了使用-m参数创建用户目录怎么办"></a>Linux 创建用户时忘了使用<code>-m</code>参数创建用户目录怎么办</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mkhomedir_helper &lt;username&gt;</span><br></pre></td></tr></table></figure>
<h1 id="xargs-命令"><a href="#xargs-命令" class="headerlink" title="xargs 命令"></a>xargs 命令</h1><p>xargs命令用于将上一个命令通过管道输出的内容, 作为命令行参数传递给下一个命令</p>
<p>xargs后面的命令默认是echo</p>
<p>即: stdin -&gt; **argv</p>
<h1 id="tee-命令"><a href="#tee-命令" class="headerlink" title="tee 命令"></a>tee 命令</h1><p>tee命令用于将标准输入复制多份, 分别输出到不同的文件, 并输出到标准输出中去</p>
<p>可以用来复制文件</p>
<ul>
<li>输出管道中某一段的内容:<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">... | tee &gt;(xargs <span class="built_in">echo</span>) &gt;/dev/null | ...</span><br></pre></td></tr></table></figure></li>
<li>不退出vim使用sudo保存文件</li>
</ul>
<p>命令<code>:w !&#123;cmd&#125;</code>表示把当前缓冲区的内容传给后面的命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:w !sudo tee % </span><br></pre></td></tr></table></figure>
<h1 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h1><p>echo命令用于将命令行参数输出到标准输出</p>
<p>即: stdin -&gt; stdout</p>
<h1 id="awk-命令"><a href="#awk-命令" class="headerlink" title="awk 命令"></a>awk 命令</h1><p>强大的字符串处理工具</p>
<p>最基本的用法:<br><code>awk &#39;&#123;print$1,$2&#125;&#39;</code></p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Visio</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-09.html</url>
    <content><![CDATA[<h1 id="Spring学习"><a href="#Spring学习" class="headerlink" title="Spring学习"></a>Spring学习</h1><h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><p>Spring类似一个类实例的工厂, 我们提供配置文件(.Java, .xml), Spring按照配置文件装配产品.</p>
<p>Spring的核心IoC容器接口是<code>ApplicationContext</code>，并提供了多种实现类:<br>例如读取xml文件的<code>ClassPathXmlApplicationContext</code>, 使用注解的<code>AnnotationConfigApplicationContext</code></p>
<h2 id="Java的Web框架"><a href="#Java的Web框架" class="headerlink" title="Java的Web框架"></a>Java的Web框架</h2><ul>
<li><p>Struts: 最古老的一个MVC框架，目前版本是2，和1.x有很大的区别；</p>
</li>
<li><p>WebWork(Struts 2.0): 一个比Struts设计更优秀的MVC框架；</p>
</li>
<li><p>Turbine: 一个重度使用Velocity，强调布局的MVC框架；</p>
</li>
<li><p>其他100+MVC框架……（略）</p>
</li>
</ul>
<p>Spring本身也开发了一个MVC框架，就叫Spring MVC。</p>
<h2 id="Spring连接数据库"><a href="#Spring连接数据库" class="headerlink" title="Spring连接数据库"></a>Spring连接数据库</h2><ul>
<li><p>使用jdbcTemplate</p>
</li>
<li><p>使用Hibernate集成框架</p>
</li>
<li><p>使用MyBatis集成框架</p>
</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-10.html</url>
    <content><![CDATA[<h1 id="Java的ORM框架-vs-Python的ORM框架"><a href="#Java的ORM框架-vs-Python的ORM框架" class="headerlink" title="Java的ORM框架 vs Python的ORM框架"></a>Java的ORM框架 vs Python的ORM框架</h1><p>TODO: 待更新</p>
<h1 id="为什么需要CORS-CORS是为了保护谁"><a href="#为什么需要CORS-CORS是为了保护谁" class="headerlink" title="为什么需要CORS? CORS是为了保护谁?"></a>为什么需要CORS? CORS是为了保护谁?</h1><p>CORS标准允许服务器指定谁可以访问该服务器上的资源, 以及该如何访问这些资源</p>
<p>所以说其实是保护服务器端, 防止恶意网站窃取数据</p>
<h1 id="信息安全之盲水印"><a href="#信息安全之盲水印" class="headerlink" title="信息安全之盲水印"></a>信息安全之盲水印</h1><p><a href="https://www.zhihu.com/question/50735753">妙啊</a></p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ORM框架</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-11.html</url>
    <content><![CDATA[<h1 id="Linux-内核提权"><a href="#Linux-内核提权" class="headerlink" title="Linux 内核提权"></a>Linux 内核提权</h1><ul>
<li>获取内核版本</li>
</ul>
<p><code>uname -a</code></p>
<p><code>lsb_release -a</code></p>
<ul>
<li>查询可用的exploit</li>
</ul>
<p>在Kali中 <code>searchsploit Linux x.x.xx priv</code></p>
<p>人工筛选</p>
<ul>
<li>传到目标机器上碰运气</li>
</ul>
<h1 id="gcc编译参数"><a href="#gcc编译参数" class="headerlink" title="gcc编译参数"></a>gcc编译参数</h1><p>目标机器上的header/lib可能不能正常使用, 此时可以下载一套header/lib放在用户目录, 用下面的方式指定</p>
<p>指定include目录: <code>-I&lt;path&gt;</code></p>
<p>指定连接库目录: <code>-L&lt;path&gt; -l&lt;libname&gt;</code></p>
<h1 id="忘了报名NCRE-难过"><a href="#忘了报名NCRE-难过" class="headerlink" title="忘了报名NCRE, 难过"></a>忘了报名NCRE, 难过</h1>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>GCC使用</tag>
        <tag>NCRE</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-12.html</url>
    <content><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-13.html</url>
    <content><![CDATA[<h1 id="C-STL中unique的用法"><a href="#C-STL中unique的用法" class="headerlink" title="C++ STL中unique的用法"></a>C++ STL中unique的用法</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line">  <span class="function">ForwardIterator <span class="title">unique</span> <span class="params">( ForwardIterator first, ForwardIterator last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="keyword">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line">  <span class="function">ForwardIterator <span class="title">unique</span> <span class="params">( ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BinaryPredicate pred )</span></span>;</span><br></pre></td></tr></table></figure>
<p>将[first, last)之间, <strong>相邻</strong>的多个相同元素合并为一个, 返回指向不重复部分末尾的迭代器. 多和sort函数一起使用</p>
<p>例: 使用unique实现<a href="https://oi-wiki.org/misc/discrete/">离散化</a>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector&lt;int&gt; array;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> disc = <span class="built_in">array</span>;</span><br><span class="line">sort(disc.begin(), disc.end());</span><br><span class="line">disc.erase(unique(disc.begin(), disc.end()), disc.end())</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disc.size(); i++) &#123;</span><br><span class="line">  disc[i] = lower_bound(<span class="built_in">array</span>.begin(), <span class="built_in">array</span>.end(), disc[i]) - <span class="built_in">array</span>.begin();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 那么disc就可以作为离散化之后的索引</span></span><br><span class="line"><span class="comment">// disc[i] = array中第i种元素的最小下标</span></span><br></pre></td></tr></table></figure>
<h1 id="CCFCSP"><a href="#CCFCSP" class="headerlink" title="CCFCSP"></a>CCFCSP</h1><p>今天考了CCF CSP.</p>
<h1 id="区间树-Interval-Tree-和线段树-Segment-Tree"><a href="#区间树-Interval-Tree-和线段树-Segment-Tree" class="headerlink" title="区间树(Interval Tree)和线段树(Segment Tree)"></a>区间树(Interval Tree)和线段树(Segment Tree)</h1>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>CCFCSP</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-14.html</url>
    <content><![CDATA[<h1 id="满课-摸了"><a href="#满课-摸了" class="headerlink" title="满课, 摸了"></a>满课, 摸了</h1>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-15.html</url>
    <content><![CDATA[<h1 id="为什么要使用mongodb"><a href="#为什么要使用mongodb" class="headerlink" title="为什么要使用mongodb"></a>为什么要使用mongodb</h1><ul>
<li><p>不需要预先定义schema即可存储数据, 适合于快速原型开发, 以及需求经常变更的情况</p>
</li>
<li><p>存储使用的BSON格式非常灵活, 可以表示像数组, 字典这样的数据, 而在RDB中需要拆分成多个表</p>
</li>
</ul>
<h1 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h1><blockquote>
<p>站点地图（英语：Sitemaps，旧称Google Sitemaps，也写为Sitemap；又称网站地图）是一种列有某个网站所有网址（URL）的XML文件，由Google最先发起。利用Sitemaps协议，网站管理员可以列出网站上可以供搜索引擎抓取的URL，并通知给后者。Sitemaps中包含有关每个URL的其他信息，如URL上次更新的时间、更新的频率以及相对于网站其他URL的重要性。搜索引擎的爬虫可以通过Sitemaps更有效地抓取网站内容，并找到可能与网站其他内容没有相互链接的URL。Sitemaps协议是对robots.txt的补充。</p>
</blockquote>
<p>简单来说就是列举了网站所有页面的一个xml文件, 附带了一些meta信息, 有利于搜索引擎抓取, SEO方法之一.</p>
<p>一般通过程序生成</p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Sitemap</tag>
        <tag>SEO</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-16.html</url>
    <content><![CDATA[<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-17.html</url>
    <content><![CDATA[<h1 id="Spring-doc-OpenAPI-注解"><a href="#Spring-doc-OpenAPI-注解" class="headerlink" title="Spring-doc OpenAPI 注解"></a>Spring-doc OpenAPI 注解</h1><p>@Operation<br>@Response<br>@Parameter</p>
<h1 id="Ubuntu设置代理"><a href="#Ubuntu设置代理" class="headerlink" title="Ubuntu设置代理"></a>Ubuntu设置代理</h1><p>启动clash for linux</p>
<ul>
<li><p>配置代理地址配置文件</p>
</li>
<li><p>配置restAPI地址和访问密码</p>
</li>
<li><p>将clash作为一个daemon进程:</p>
<ul>
<li><p>使用systemd:</p>
<p>  先创建配置文件<code>/etc/systemd/system/clash.service</code></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash Daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/clash -d /etc/clash/</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>  然后clash就成为了一个service, 可以通过systemctl命令启动, 通过journalctl命令查看日志等</p>
</li>
<li><p>使用pm2: <code>pm2 start clash</code></p>
</li>
</ul>
</li>
<li><p>在.bashrc或者.zshrc文件底部设置</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> all_proxy=<span class="string">&#x27;socks5://localhost:7891&#x27;</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&#x27;http://localhost:7890&#x27;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&#x27;http://localhost:7890&#x27;</span></span><br><span class="line"><span class="built_in">export</span> ftp_proxy=<span class="string">&#x27;http://localhost:7890&#x27;</span></span><br><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">&#x27;localhost,127.0.0.1&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="Shell的类型"><a href="#Shell的类型" class="headerlink" title="Shell的类型"></a>Shell的类型</h1><h2 id="shell的类型"><a href="#shell的类型" class="headerlink" title="shell的类型"></a>shell的类型</h2><p>常见的shell有sh, bash, zsh等, </p>
<p>查看当前使用的shell: <code>echo $SHELL</code></p>
<p>查看系统中的所有shell: <code>cat /etc/shells</code></p>
<h2 id="登录shell和非登录shell"><a href="#登录shell和非登录shell" class="headerlink" title="登录shell和非登录shell"></a>登录shell和非登录shell</h2><h2 id="交互式shell和非交互式shell"><a href="#交互式shell和非交互式shell" class="headerlink" title="交互式shell和非交互式shell"></a>交互式shell和非交互式shell</h2><h2 id="profile-和-xxshrc"><a href="#profile-和-xxshrc" class="headerlink" title=".profile 和 .xxshrc"></a>.profile 和 .xxshrc</h2><ul>
<li><p>/etc/profile 为系统的每个用户设置环境信息,当第一个用户登录时, 该文件被执行, 并从/etc/profile.d目录的配置文件中搜集shell的设置</p>
</li>
<li><p>/etc/xxshrc 为每一个运行xx shell的用户执行此文件. 当xx shell被打开时, 该文件被读取。有些linux版本中的/etc目录下已经没有了该文件。</p>
</li>
<li><p>~/.profile 每个用户都可使用该文件输入专用于自己使用的shell信息, 当用户登录时,该文件仅仅执行一次 默认情况下,它设置一些环境变量,然后执行用户的.xxshrc文件.</p>
</li>
<li><p>~/.xxshrc 该文件包含专用于某个用户的xx shell的配置, 当该用户登录时以及每次打开新的xx shell时,该文件被读取.</p>
</li>
</ul>
<h1 id="Hexo-layout"><a href="#Hexo-layout" class="headerlink" title="Hexo layout"></a>Hexo layout</h1><p>hexo中每种不同的页面样式称为一个layout</p>
<p>根据md放置的位置不同, 使用的layout也不同</p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-18.html</url>
    <content><![CDATA[<h1 id="Oracle-Apex怎么调用procedure"><a href="#Oracle-Apex怎么调用procedure" class="headerlink" title="Oracle Apex怎么调用procedure"></a>Oracle Apex怎么调用procedure</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">  ANALYSIS(<span class="number">6</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-19.html</url>
    <content><![CDATA[<h1 id="Spring中Filter和Interceptor的区别"><a href="#Spring中Filter和Interceptor的区别" class="headerlink" title="Spring中Filter和Interceptor的区别"></a>Spring中Filter和Interceptor的区别</h1><p>Filter和Interceptor都可以实现对请求的拦截</p>
<h2 id="功能定位"><a href="#功能定位" class="headerlink" title="功能定位"></a>功能定位</h2><p>都可以用来实现用户认证</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>定义规范不同</p>
<p>  Filter是Servlet的规范; 而Interceptor是Spring框架提供的类似的拦截器</p>
</li>
<li><p>拦截范围不同</p>
<p>  Filter的拦截范围是Servlet层; Interceptor的拦截范围是Controller层</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    │   ▲</span><br><span class="line">    ▼   │</span><br><span class="line">    ┌───────┐</span><br><span class="line">    │Filter1│</span><br><span class="line">    └───────┘</span><br><span class="line">    │   ▲</span><br><span class="line">    ▼   │</span><br><span class="line">    ┌───────┐</span><br><span class="line">    │Filter2│</span><br><span class="line">    └───────┘</span><br><span class="line">    │   ▲</span><br><span class="line">    ▼   │</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│DispatcherServlet│&lt;───┐</span><br><span class="line">└─────────────────┘    │</span><br><span class="line">│              ┌────────────┐</span><br><span class="line">│              │ModelAndView│</span><br><span class="line">│              └────────────┘</span><br><span class="line">│ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ▲</span><br><span class="line">│    ┌───────────┐    │</span><br><span class="line">├─┼─&gt;│Controller1│──┼─┤</span><br><span class="line">│    └───────────┘    │</span><br><span class="line">│ │                 │ │</span><br><span class="line">│    ┌───────────┐    │</span><br><span class="line">└─┼─&gt;│Controller2│──┼─┘</span><br><span class="line">    └───────────┘</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure></li>
<li><p>管理方式不同</p>
<p>  Filter由Servlet容器管理, 需要使用<code>DelegatingFilterProxy</code>代理类才能被Spring集成; Interceptor直接由Spring IoC容器管理</p>
</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-20.html</url>
    <content><![CDATA[<h1 id="昨天通宵，今天摸了"><a href="#昨天通宵，今天摸了" class="headerlink" title="昨天通宵，今天摸了"></a>昨天通宵，今天摸了</h1>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-23.html</url>
    <content><![CDATA[<h1 id="做Java项目"><a href="#做Java项目" class="headerlink" title="做Java项目"></a>做Java项目</h1>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-25.html</url>
    <content><![CDATA[<h1 id="Java-答辩结束了-Yeah"><a href="#Java-答辩结束了-Yeah" class="headerlink" title="Java 答辩结束了, Yeah!"></a>Java 答辩结束了, Yeah!</h1><p>今天开始刷题</p>
<h1 id="Hash-Map-Hash-Set-vs-Tree-Map-Tree-Set"><a href="#Hash-Map-Hash-Set-vs-Tree-Map-Tree-Set" class="headerlink" title="Hash Map, Hash Set vs Tree Map, Tree Set"></a>Hash Map, Hash Set vs Tree Map, Tree Set</h1><p>c++中的<code>map</code>, <code>set</code>默认是treemap和treeset, 底层基于红黑树, 元素始终保持有序</p>
<p>而<code>unordered_map</code>, <code>unordered_set</code>底层基于哈希表</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>查询/插入/删除</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据结构</th>
<th>底层</th>
<th>find/get/contain</th>
<th>set</th>
<th>delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>map</td>
<td>tree</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>unordered_map</td>
<td>hash</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据结构</th>
<th>底层</th>
<th>find/contain</th>
<th>insert</th>
<th>delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>set</td>
<td>tree</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>unordered_set</td>
<td>hash</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
</tbody>
</table>
</div>
<p>遍历</p>
<p><code>map</code>和<code>set</code>都支持按序遍历, 而<code>unordered_map</code>, <code>unordered_set</code>天生就不适合按序遍历(底层不是按序存储), 但是可以无序遍历</p>
<h1 id="Java-项目总结"><a href="#Java-项目总结" class="headerlink" title="Java 项目总结"></a>Java 项目总结</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="Java-Web项目的基本结构"><a href="#Java-Web项目的基本结构" class="headerlink" title="Java Web项目的基本结构"></a>Java Web项目的基本结构</h3><p>Controller层: 前端实际调用的接口, 包括用户鉴权, 页面跳转等等, 接口内部调用Service层来实现功能.</p>
<p>Service层: 实际的业务逻辑, 一般按照功能分包, 尽量做到与Controller层脱钩, 一般都是些无状态函数(对环境不做任何假设)</p>
<p>DAO层: 与数据库相关的代码, 也被称为持久层</p>
<h3 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h3><p>Spring框架的核心:</p>
<ol>
<li><p>通过依赖注入来降低代码之间的耦合(IoC控制反转)</p>
<p> 例如: <code>@Autowired</code>, <code>@Bean</code>, <code>@Resource</code></p>
</li>
<li><p>对AOP的支持</p>
<p> 这个没怎么用到</p>
</li>
<li><p>对各种工具的集成和支持</p>
<p> 例如: Spring Data JPA, Spring Security等等</p>
</li>
</ol>
<h3 id="Spring-Boot框架"><a href="#Spring-Boot框架" class="headerlink" title="Spring Boot框架"></a>Spring Boot框架</h3><p>Spring Boot能够自动识别项目中开启的功能(通过扫描安装的依赖包or配置文件?)</p>
<p>项目配置全部写在<code>application.[properties|yml]</code>中, 框架会自动识别</p>
<p>也可以自己定义一些key, 在代码中通过<code>@Value(&quot;xxx.yyy&quot;)</code>注入</p>
<h3 id="JWT鉴权"><a href="#JWT鉴权" class="headerlink" title="JWT鉴权"></a>JWT鉴权</h3><p><a href="https://jwt.io/">JWT</a>的三部分: <code>Header.Payload.Signature</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Header = &#123;<span class="string">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span>,<span class="string">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">Payload = &#123;<span class="string">&quot;sub&quot;</span>:<span class="string">&quot;1234567890&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;John Doe&quot;</span>,<span class="string">&quot;iat&quot;</span>:<span class="number">1516239022</span>&#125;</span><br><span class="line"></span><br><span class="line">_Header64 = base64UrlEncode(Header)</span><br><span class="line">_Payload64 = base64UrlEncode(Payload)</span><br><span class="line"></span><br><span class="line">Signature = HMACSHA256(<span class="string">`<span class="subst">$&#123;_Header64&#125;</span>.<span class="subst">$&#123;_Payload64&#125;</span>`</span>, $&#123;your-<span class="number">256</span>-bit-secret&#125;)</span><br><span class="line"></span><br><span class="line">JWT = <span class="string">`<span class="subst">$&#123;_Header64&#125;</span>.<span class="subst">$&#123;_Payload64&#125;</span>.<span class="subst">$&#123;Signature&#125;</span>`</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>答辩</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-27.html</url>
    <content><![CDATA[<h1 id="配环境心得"><a href="#配环境心得" class="headerlink" title="配环境心得"></a>配环境心得</h1><p>放平心态</p>
<h1 id="Linux之图形化界面"><a href="#Linux之图形化界面" class="headerlink" title="Linux之图形化界面"></a>Linux之图形化界面</h1><h2 id="X-vs-Wayland"><a href="#X-vs-Wayland" class="headerlink" title="X vs. Wayland"></a>X vs. Wayland</h2><p>X是最广泛使用的linux显示服务器, 是底层的图形化界面显示标准</p>
<h2 id="Display-Manager"><a href="#Display-Manager" class="headerlink" title="Display Manager"></a>Display Manager</h2><p>显示管理器(或登录管理器)是一个在启动最后显示的图形界面. 负责管理用户登录, 启动X等等. 有些集成在桌面环境中. </p>
<p>用户一般直接与显示管理器打交道.</p>
<p>常见的显示管理器有:</p>
<ul>
<li>GDM(GNOME)</li>
<li>LXDM(LXDE)</li>
<li>lightDM(支持多种DE)<br>等等</li>
</ul>
<h2 id="Desktop-Environment"><a href="#Desktop-Environment" class="headerlink" title="Desktop Environment"></a>Desktop Environment</h2><p>桌面环境通过汇集使用相同组件库的程序, 为用户提供了完全的图形用户界面. </p>
<p>常见的桌面环境有:</p>
<ul>
<li>GNOME</li>
<li>KDE</li>
<li>Xfce<br>等等</li>
</ul>
<h2 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h2><ul>
<li>xdmcp</li>
<li>vnc</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-28.html</url>
    <content><![CDATA[<h1 id="su-user-和-su-user的区别"><a href="#su-user-和-su-user的区别" class="headerlink" title="su user 和 su - user的区别"></a>su user 和 su - user的区别</h1><p><code>$ su user</code>启动nologin shell</p>
<p><code>$ su - user</code>启动login shell</p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2020-12-30.html</url>
    <content><![CDATA[<h1 id="计网答辩顺利"><a href="#计网答辩顺利" class="headerlink" title="计网答辩顺利"></a>计网答辩顺利</h1><p>开心!</p>
<h1 id="WiFi协议-802-11-扫盲"><a href="#WiFi协议-802-11-扫盲" class="headerlink" title="WiFi协议(802.11)扫盲"></a>WiFi协议(802.11)扫盲</h1><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><ol>
<li><p>有线与无线网络</p>
<p> 当前有线网络中最著名的是以太网(Ethernet), 无线网络中最有前景的是WiFi.</p>
<p> 无线网络的缺点:</p>
<ul>
<li>通信双方因为是通过无线进行通信，所以通信之前需要建立连接；而有线网络就直接用线缆连接，不用这个过程了。</li>
<li>通信双方通信方式是半双工的通信方式；而有线网络可以是全双工。</li>
<li>通信时在网络层以下出错的概率非常高，所以帧的重传概率很大，需要在网络层之下的协议添加重传的机制（不能只依赖上面TCP/IP的延时等待重传等开销来保证）；而有线网络出错概率非常小，无需在网络层有如此复杂的机制。</li>
<li>数据是在无线环境下进行的，所以抓包非常容易，存在安全隐患。</li>
<li>因为收发无线信号，所以功耗较大，对电池来说是一个考验。</li>
<li>相对有线网络吞吐量低，这一点正在逐步改善，802.11n协议可以达到600Mbps的吞吐量。</li>
</ul>
</li>
<li><p>协议</p>
<p>Ethenet和Wifi采用的协议都属于IEEE 802协议集。其中，Ethenet以802.3协议做为其网络层以下的协议；而Wifi以802.11做为其网络层以下的协议。无论是有线网络，还是无线网络，其网络层以上的部分，基本一样。</p>
</li>
<li><p>术语</p>
<p> 讲述之前，我们需要对无线网络中一些常用的术语有所了解。这里先列出一些，后面描述中出现的新的术语，将会在描述中解释。</p>
<ul>
<li><p>LAN：即局域网，是路由和主机组成的内部局域网，一般为有线网络。</p>
</li>
<li><p>WAN：即广域网，是外部一个更大的局域网。</p>
</li>
<li><p>WLAN（Wireless LAN，即无线局域网）：前面我们说过LAN是局域网，其实大多数指的是有线网络中的局域网，无线网络中的局域网，一般用WLAN。</p>
</li>
<li><p>AP（Access point的简称，即访问点，接入点）：是一个无线网络中的特殊节点，通过这个节点，无线网络中的其它类型节点可以和无线网络外部以及内部进行通信。这里，AP和无线路由都在一台设备上（即Cisco E3000）。</p>
</li>
<li><p>Station（工作站）：表示连接到无线网络中的设备，这些设备通过AP，可以和内部其它设备或者无线网络外部通信。</p>
</li>
<li><p>Assosiate：连接。如果一个Station想要加入到无线网络中，需要和这个无线网络中的AP关联（即Assosiate）。</p>
</li>
<li><p>SSID：用来标识一个无线网络，后面会详细介绍，我们这里只需了解，每个无线网络都有它自己的SSID。</p>
</li>
<li><p>BSSID：用来标识一个BSS，其格式和MAC地址一样，是48位的地址格式。一般来说，它就是所处的无线接入点的MAC地址。某种程度来说，它的作用和SSID类似，但是SSID是网络的名字，是给人看的，BSSID是给机器看的，BSSID类似MAC地址。</p>
</li>
<li><p>BSS（Basic Service Set）：由一组相互通信的工作站组成，是802.11无线网络的基本组件。主要有两种类型的IBSS和基础结构型网络。IBSS又叫ADHOC，组网是临时的，通信方式为Station&lt;-&gt;Station，这里不关注这种组网方式；我们关注的基础结构形网络，其通信方式是Station&lt;-&gt;AP&lt;-&gt;Station，也就是所有无线网络中的设备要想通信，都得经过AP。在无线网络的基础形网络中，最重要的两类设备：AP和Station。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>答辩</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年度总结</title>
    <url>/daily/2020-final.html</url>
    <content><![CDATA[<h2 id="进步"><a href="#进步" class="headerlink" title="进步"></a>进步</h2><h3 id="装备升级"><a href="#装备升级" class="headerlink" title="装备升级"></a>装备升级</h3><ul>
<li><p>新增显示器</p>
</li>
<li><p>新增一个Pad</p>
</li>
</ul>
<h3 id="技术进步"><a href="#技术进步" class="headerlink" title="技术进步"></a>技术进步</h3><ul>
<li><p>新开了Blog!</p>
</li>
<li><p>开始刷算法题, 并已经刷了一些</p>
</li>
<li><p>前端技术更加熟练了</p>
<ul>
<li><p>Vue/React双线操作</p>
</li>
<li><p>简单页面能够快速开发</p>
</li>
</ul>
</li>
<li><p>Python更加熟练了</p>
<ul>
<li><p>爬虫技术</p>
</li>
<li><p>数据处理技术</p>
</li>
<li><p>AI/DL</p>
</li>
</ul>
</li>
<li><p>Java语言入门</p>
<ul>
<li>Spring框架</li>
</ul>
</li>
<li><p>iOS应用开发入门</p>
<ul>
<li><p>Swift语言入门</p>
</li>
<li><p>SpriteKit游戏 * 1</p>
</li>
</ul>
</li>
</ul>
<h3 id="综合能力"><a href="#综合能力" class="headerlink" title="综合能力"></a>综合能力</h3><ul>
<li><p>表达能力略微提升</p>
</li>
<li><p>管理能力略微提升</p>
</li>
</ul>
<h3 id="人际关系"><a href="#人际关系" class="headerlink" title="人际关系"></a>人际关系</h3><ul>
<li>认识了很多新朋友!</li>
</ul>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><ul>
<li>时间利用率不高, 为完成项目曾多次通宵</li>
</ul>
<h3 id="管理-组织能力"><a href="#管理-组织能力" class="headerlink" title="管理, 组织能力"></a>管理, 组织能力</h3><ul>
<li>小组合作时, 作为组长, 任务分配还有待优化</li>
</ul>
<h3 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h3><ul>
<li>有时候会比较焦虑</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2021-01-04.html</url>
    <content><![CDATA[<h1 id="iOS答辩"><a href="#iOS答辩" class="headerlink" title="iOS答辩"></a>iOS答辩</h1><h1 id="数据仓库答辩"><a href="#数据仓库答辩" class="headerlink" title="数据仓库答辩"></a>数据仓库答辩</h1><h2 id="答辩心得"><a href="#答辩心得" class="headerlink" title="答辩心得:"></a>答辩心得:</h2><h3 id="关于PPT"><a href="#关于PPT" class="headerlink" title="关于PPT"></a>关于PPT</h3><ol>
<li>Explicit is better than Implicit!</li>
</ol>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>答辩</tag>
        <tag>PPT制作</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2021-01-05.html</url>
    <content><![CDATA[<h1 id="关于DDL的疑惑"><a href="#关于DDL的疑惑" class="headerlink" title="关于DDL的疑惑"></a>关于DDL的疑惑</h1><p>为什么ddl推迟, 开始肝ddl的时间也跟着推迟? </p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>摸鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2021-01-07.html</url>
    <content><![CDATA[<h2 id="关于URL末尾的斜杠"><a href="#关于URL末尾的斜杠" class="headerlink" title="关于URL末尾的斜杠"></a>关于URL末尾的斜杠</h2><p>URL末尾有无斜杠会对按相对路径加载的资源造成影响</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径</th>
<th>当前渲染的文件</th>
<th>当前目录</th>
</tr>
</thead>
<tbody>
<tr>
<td>foobar.com/example<b>/</b></td>
<td><strong>/example/index.html</strong></td>
<td><strong>/example</strong></td>
</tr>
<tr>
<td>foobar.com/example</td>
<td><strong>/example.html</strong></td>
<td><strong>/</strong></td>
</tr>
</tbody>
</table>
</div>
<p>按绝对路径加载的资源不会受到影响</p>
<h2 id="uwsgi作为daemon启动"><a href="#uwsgi作为daemon启动" class="headerlink" title="uwsgi作为daemon启动"></a>uwsgi作为daemon启动</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>添加<code>-d</code>参数</p>
<p><code>$ uwsgi -d --ini app.ini</code></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>在ini文件中添加<code>daemonize = /var/log/uwsgi.log</code></p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>uwsgi</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2021-01-08.html</url>
    <content><![CDATA[<h2 id="没什么成果的一天"><a href="#没什么成果的一天" class="headerlink" title="没什么成果的一天"></a>没什么成果的一天</h2><p>复习线代</p>
<p>配Oracle, timesten</p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>摸鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2021-01-09.html</url>
    <content><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>重叠子问题</li>
<li>最优子结构</li>
<li>状态转移方程</li>
<li>状态压缩</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>找出所有的<strong>状态</strong></li>
<li>列举dp数组</li>
<li>找出状态转移方程</li>
</ol>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2021-01-10.html</url>
    <content><![CDATA[<h2 id="模运算的性质-程序设计版"><a href="#模运算的性质-程序设计版" class="headerlink" title="模运算的性质(程序设计版)"></a>模运算的性质(程序设计版)</h2><p>模运算与基本四则运算有些相似，但是除法例外。其规则如下：</p>
<script type="math/tex; mode=display">(a + b)\bmod p = (a\bmod p + b\bmod p)\bmod p</script><script type="math/tex; mode=display">(a - b)\bmod p = (a\bmod p - b\bmod p)\bmod p</script><script type="math/tex; mode=display">(a \times b)\bmod p = (a\bmod p \times b\bmod p)\bmod p</script><script type="math/tex; mode=display">(a^b)\bmod p = ((a\bmod p)^b)\bmod p</script>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2021-01-12.html</url>
    <content><![CDATA[<h2 id="c-11-新-特性之右值引用"><a href="#c-11-新-特性之右值引用" class="headerlink" title="c++11(新?)特性之右值引用"></a>c++11(新?)特性之右值引用</h2><h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>不能放到赋值表达式左侧的值</p>
<p>例如: </p>
<ul>
<li>字面量 <code>1, &quot;Hello&quot;, &#39;c&#39;</code></li>
<li>返回值而非引用的函数调用 <code>foo()</code></li>
<li>运算结果 <code>a + b</code></li>
</ul>
<p>右值不能被直接赋值给一个<strong>非常</strong>引用, 只能先赋给一个变量再取引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; ref = <span class="number">9</span>; <span class="comment">// error, “invalid initialization of non-const reference of type int&amp; from an rvalue of type int”</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; const_ref = <span class="number">9</span>; <span class="comment">// only allow this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nine = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = nine; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>上述特性在泛型函数重载时会带来一些问题, 这导致我们不得不对有无const两种情况分别重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A1&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">factory</span><span class="params">(A1&amp; a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(a1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factory&lt;foo&gt;(<span class="number">5</span>); <span class="comment">// error, a1-&gt;int&amp;, can not bind to literal 5 </span></span><br></pre></td></tr></table></figure>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>顾名思义, 就是对右值的引用</p>
<h3 id="增加右值引用的好处"><a href="#增加右值引用的好处" class="headerlink" title="增加右值引用的好处"></a>增加右值引用的好处</h3><p>增加了右值引用之后, 我们具备了识别和重载右值的能力</p>
<h4 id="进一步消除不必要的复制"><a href="#进一步消除不必要的复制" class="headerlink" title="进一步消除不必要的复制"></a>进一步消除不必要的复制</h4><p>在c++11之前, 临时变量的创建一直是难以处理的问题. 有时这些临时变量可以被编译器优化（例如返回值优化）, 但是这并不总是可行的, 通常这会导致高昂的对象复制成本. </p>
<p>考虑下面的代码, 理论上这里最多可能发生两次复制操作:</p>
<ol>
<li><p>返回临时变量</p>
</li>
<li><p>vector赋值</p>
</li>
</ol>
<p>其中, 第一次的复制操作可能会被编译器优化掉(RVO), 然而第二次复制是不可避免的</p>
<p>当然我们可以通过其他方法来避免这次复制, 比如通过指针或者传递一个已经填充好的vector</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">make_poem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; lines;</span><br><span class="line">    lines.push_back(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    lines.push_back(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> lines; <span class="comment">// 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; poem;</span><br><span class="line">    poem = make_poem(); <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了右值引用之后, 我们可以就可以对右值进行特殊化处理, 从而避免多余的复制(移动构造函数和=运算符重载), 例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copy</span></span><br><span class="line">foo(foo <span class="keyword">const</span>&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;length = other.length;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ptr = <span class="keyword">new</span> <span class="keyword">int</span>[other.length];</span><br><span class="line">    copy(other.ptr, other.ptr + other.length, <span class="keyword">this</span>-&gt;ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与之对应的move</span></span><br><span class="line">foo(foo&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;length = other.length;</span><br><span class="line">   <span class="keyword">this</span>-&gt;ptr = other.ptr;</span><br><span class="line">   other.length = <span class="number">0</span>;</span><br><span class="line">   other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移动语义的引入"><a href="#移动语义的引入" class="headerlink" title="移动语义的引入"></a>移动语义的引入</h4><p>可以显式指定某个资源被移交给另一个函数, 自己不再需要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Resource resource;</span><br><span class="line">foo(move(resource)); <span class="comment">// 不再需要resource, 可以全权交给foo函数, 将会调用foo(Resource&amp;&amp;)</span></span><br></pre></td></tr></table></figure>
<p>对于有些不能被复制的资源(如<code>std::unique_ptr</code>, <code>std::thread</code>等等), 这是很有用的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">another</span><span class="params">(s)</span></span>;           <span class="comment">// calls std::string(const std::string&amp;);</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">more</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>(s))</span></span>; <span class="comment">// calls std::string(std::string&amp;&amp;);</span></span><br></pre></td></tr></table></figure>
<h4 id="模板的完美转发"><a href="#模板的完美转发" class="headerlink" title="模板的完美转发"></a>模板的完美转发</h4><p>(TODO)</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><code>move</code>函数: 提醒编译器重载时选择移动构造函数</p>
<p>利用移动交换两个变量:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_swap</span><span class="params">(Res &amp;a, Res &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Res t = move(a);</span><br><span class="line">    a = move(b);</span><br><span class="line">    b = move(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RVO和NRVO"><a href="#RVO和NRVO" class="headerlink" title="RVO和NRVO"></a>RVO和NRVO</h2><p>返回值优化（Return value optimization，缩写为RVO）是C++的一项编译优化技术。即删除保持函数返回值的临时对象。这可能会省略两次复制构造函数，<strong>即使复制构造函数有副作用</strong>。</p>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2021-01-19.html</url>
    <content><![CDATA[<h2 id="近期任务"><a href="#近期任务" class="headerlink" title="近期任务"></a>近期任务</h2><ul>
<li>内存数据库最终项目</li>
<li>计算机网络实验报告</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
  </entry>
  <entry>
    <title>每日小结</title>
    <url>/daily/2021-01-22.html</url>
    <content><![CDATA[<p>考试结束</p>
<p>假期的一些计划</p>
<ul>
<li>完善<code>codepass</code>项目</li>
<li>刷算法题目</li>
<li>深入学习c++</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
  </entry>
  <entry>
    <title>shell脚本编程</title>
    <url>/daily/2021-01-29.html</url>
    <content><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>以<code>#</code>开始, 从<code>#</code>开始直到行尾都会被当做注释</p>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p><code>EOF</code>可以换成任意内容</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p><code>变量名=值</code></p>
<p>注意等号前后不能有空格</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=<span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>读取变量的值时需要在前面添加<code>$</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br></pre></td></tr></table></figure>
<h2 id="修改变量"><a href="#修改变量" class="headerlink" title="修改变量"></a>修改变量</h2><p>再次修改变量的值时不需要添加<code>$</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=2</span><br><span class="line">b=<span class="string">&quot;World Hello&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p><code>readonly 变量名</code></p>
<p>可以将一个变量设置为只读</p>
<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p><code>unset 变量名</code></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>可以用单引号括起来也可以用双引号, 区别是单引号括起来的字符串不会转义</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$a\&quot;\&quot;b&#x27;</span>  <span class="variable">$a</span>\&quot;\&quot;b</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span>\&quot;\&quot;b&quot;</span>  1<span class="string">&quot;&quot;</span>b</span><br></pre></td></tr></table></figure>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">greeting=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">name=<span class="string">&quot;world&quot;</span></span><br><span class="line">msg=<span class="string">&quot;<span class="variable">$greeting</span> <span class="variable">$name</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$msg</span>  hello world</span><br></pre></td></tr></table></figure>
<h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#msg&#125;</span>  11</span><br></pre></td></tr></table></figure>
<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><p>格式见示例, 两个参数分别为起始位置和长度</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;msg:4:3&#125;</span>  o w</span><br></pre></td></tr></table></figure>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><code>数组名=(元素1 元素2 ... 元素n)</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=(1 2 3)</span><br><span class="line">b=(<span class="string">&quot;Hello&quot;</span> <span class="string">&quot;,&quot;</span> <span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>也可以单独定义数组的各个分量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">arr[0]=1</span><br><span class="line">arr[1]=<span class="string">&quot;2&quot;</span></span><br><span class="line">arr[5]=3</span><br><span class="line">arr[100]=4</span><br></pre></td></tr></table></figure>
<p>shell中数组的下标从0开始, 可以不是连续的</p>
<h2 id="读取数组元素"><a href="#读取数组元素" class="headerlink" title="读取数组元素"></a>读取数组元素</h2><p><code>$&#123;数据名[下标]&#125;</code></p>
<p>下标使用 <code>@</code> 符号可以获取数组中的所有元素</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[0]&#125;</span> <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[3]&#125;</span> <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span> <span class="comment"># 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<h2 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[@]&#125;</span>  或</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[*]&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>for-in循环</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> 1 2 3 4 5; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$index</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>for-i循环</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=0; i&lt;5; i++)); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>while循环</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$i</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;i++&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h1 id="调用参数"><a href="#调用参数" class="headerlink" title="调用参数"></a>调用参数</h1><p>调用脚本时可以传递一些参数, 在脚本内可以通过如下转义表达式获取参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$#</code></td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td><code>$n</code></td>
<td>传递到脚本的第n个参数, 0为脚本文件名</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>以一个单字符串显示所有向脚本传递的参数。</td>
</tr>
<tr>
<td>$$$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td><code>$!</code></td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>与<code>$*</code>相同，但是每个参数都会带引号。</td>
</tr>
<tr>
<td><code>$-</code></td>
<td>显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Shell 传递参数实例！&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;参数个数为: <span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;执行的文件名: <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第一个参数为: <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第二个参数为: <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第三个参数为: <span class="variable">$3</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;所有参数为: $*&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前进程: $$&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy, SciPy, Matplotlib 和 Pandas 学习</title>
    <url>/daily/2021-03-14.html</url>
    <content><![CDATA[<p>时间过的真快啊，转眼间已经是 <del>3</del> 4 月了！</p>
<h1 id="Python-数据科学常用的库"><a href="#Python-数据科学常用的库" class="headerlink" title="Python 数据科学常用的库"></a>Python 数据科学常用的库</h1><p><img src="https://cdn.7c00h.xyz/images/v2-297731bd359ebc14978967a92f1716cb_r-1.jpg" alt=""></p>
<h1 id="Numpy-使用"><a href="#Numpy-使用" class="headerlink" title="Numpy 使用"></a>Numpy 使用</h1><h2 id="array-对象"><a href="#array-对象" class="headerlink" title="array 对象"></a>array 对象</h2><h1 id="Matplotlib-使用"><a href="#Matplotlib-使用" class="headerlink" title="Matplotlib 使用"></a>Matplotlib 使用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<h1 id="Pandas-使用"><a href="#Pandas-使用" class="headerlink" title="Pandas 使用"></a>Pandas 使用</h1><h2 id="Series-对象"><a href="#Series-对象" class="headerlink" title="Series 对象"></a>Series 对象</h2><h2 id="Dataframe-对象"><a href="#Dataframe-对象" class="headerlink" title="Dataframe 对象"></a>Dataframe 对象</h2><p>博客更新日志：</p>
<ul>
<li>日记分类名字从「每日小结」改为「每日小结 Day Day Up」</li>
<li>日记文章标题从今往后将取有意义的名字</li>
<li>日记文件名改成更加标准的 ISO-8601 命名法</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
        <tag>matplotlib</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>python 自定义 JSON Encoder</title>
    <url>/daily/2021-06-15.html</url>
    <content><![CDATA[<h1 id="python-自定义-JSON-Encoder"><a href="#python-自定义-JSON-Encoder" class="headerlink" title="python 自定义 JSON Encoder"></a>python 自定义 JSON Encoder</h1><p>继承 json.JSONEncoder 类, 重载 default 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_time</span>(<span class="params">dt: DateTime</span>):</span></span><br><span class="line">    pdt = datetime(dt.year, dt.month, dt.day, dt.hour, dt.minute,</span><br><span class="line">                   <span class="built_in">int</span>(dt.second), <span class="built_in">int</span>(dt.second * <span class="number">1000000</span> % <span class="number">1000000</span>))</span><br><span class="line">    <span class="keyword">return</span> pdt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomJSONEncoder</span>(<span class="params">JSONEncoder</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span>(<span class="params">self, o</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(o, DateTime):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>(CustomJSONEncoder, self).encode(convert_time(o).isoformat())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(CustomJSONEncoder, self).default(o)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabin-Karp 算法</title>
    <url>/daily/2021-07-02.html</url>
    <content><![CDATA[<h1 id="Rabin-Karp-算法"><a href="#Rabin-Karp-算法" class="headerlink" title="Rabin-Karp 算法"></a>Rabin-Karp 算法</h1><p>字符串匹配算法之一，利用哈希进行匹配比较，利用滚动哈希优化哈希函数</p>
<h2 id="滚动哈希"><a href="#滚动哈希" class="headerlink" title="滚动哈希"></a>滚动哈希</h2><p>将滑动窗口中的字符串哈希成一个数字</p>
<script type="math/tex; mode=display">
h_i = \sum_{p = 0}^{L - 1}{s_{i + p} b^{L - 1 - p}}</script><p>其中$L$为滑动窗口大小，$s$为探针字符串，$b$为基数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>index</th>
<th></th>
<th>-1</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td>……</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td></td>
<td>……</td>
</tr>
<tr>
<td>$h_{i-1}$</td>
<td></td>
<td>$b^5$</td>
<td>$b^4$</td>
<td>$b^3$</td>
<td>$b^2$</td>
<td>$b$</td>
<td>$1$</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$h_{i}$</td>
<td></td>
<td></td>
<td>$b^5$</td>
<td>$b^4$</td>
<td>$b^3$</td>
<td>$b^2$</td>
<td>$b$</td>
<td>$1$</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>则有递推公式</p>
<script type="math/tex; mode=display">
\begin{aligned}
h_i &= \sum_{p = 0}^{L - 1}{s_{i + p} b^{L - 1 - p}}\\
&= b \cdot \sum_{p = 0}^{L - 1}{s_{i + p - 1} b^{L - 1 - p}} - s_{i-1} b^{L} + s_{i+L-1}\\
&= (h_{i-1} - s_{i-1} b^{L-1}) b + s_{i+L-1}
\end{aligned}</script><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rk_hash</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> base, <span class="keyword">int</span> L, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = (hash * base) % mod;</span><br><span class="line">        hash = (hash + s[start + i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">powmod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> powmod((<span class="keyword">long</span> <span class="keyword">long</span>)a * a % m, n / <span class="number">2</span>, m) % m;</span><br><span class="line">    <span class="keyword">return</span> ((powmod((<span class="keyword">long</span> <span class="keyword">long</span>)a * a % m, n / <span class="number">2</span>, m) % m) * ((<span class="keyword">long</span> <span class="keyword">long</span>)a % m)) % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rk_cont_hash</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> last_h, <span class="keyword">int</span> base, <span class="keyword">int</span> L, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = last_h - s[start - <span class="number">1</span>] * powmod(base, L - <span class="number">1</span>, mod);</span><br><span class="line">    hash = (hash * base) % mod;</span><br><span class="line">    hash = (hash + s[start + L - <span class="number">1</span>]) % mod;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2021目标计划</title>
    <url>/daily/2021-start.html</url>
    <content><![CDATA[<h1 id="2021年目标"><a href="#2021年目标" class="headerlink" title="2021年目标"></a>2021年目标</h1><h2 id="学习上"><a href="#学习上" class="headerlink" title="学习上"></a>学习上</h2><ul>
<li>先把期末考试完美解决</li>
</ul>
<h2 id="技术上"><a href="#技术上" class="headerlink" title="技术上"></a>技术上</h2><ul>
<li><p>想深入学习一下C++!</p>
</li>
<li><p>多刷算法题目!</p>
</li>
<li><p>多写Blog!</p>
</li>
<li><p>学习Android开发</p>
</li>
<li><p>实现大的后端架构</p>
</li>
<li><p>学习新语言: Go/Julia/Ruby/…</p>
</li>
</ul>
]]></content>
      <categories>
        <category>每日小结 Day Day Up</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/eda/index.html</url>
    <content><![CDATA[<hr>
<p>title: 数字电子系统的设计自动化-笔记<br>date: 2021-05-05 23:40:44<br>category: </p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags: "></a>tags: </h2><p>计算机辅助硬件设计的问题：排查存储的成本过高，设计：芯片测试：印刷电路板：最终机器=1：10：100：1000</p>
]]></content>
  </entry>
  <entry>
    <title>日本语1</title>
    <url>/japanese/1.html</url>
    <content><![CDATA[<h1 id="What-is-Japanese"><a href="#What-is-Japanese" class="headerlink" title="What is Japanese"></a>What is Japanese</h1><h2 id="Japanese-Sound-System"><a href="#Japanese-Sound-System" class="headerlink" title="Japanese Sound System"></a>Japanese Sound System</h2><p>23 consonant sounds + 5 vowel sounds, with pitch accent</p>
<p>When spoken, the Japanese language is formed using either vowels or a consonant-vowel pair, except the “n” sound (single consonant sound)</p>
<h2 id="Japanese-Writing-System"><a href="#Japanese-Writing-System" class="headerlink" title="Japanese Writing System"></a>Japanese Writing System</h2><p>Come around 1500 years age from China</p>
<p>Currentlt has 3 types of writing: hiragana, katakana, kanji</p>
<p>Kanji were imported from China, traditionally used for both meaning and sound.</p>
<p>Hiragana: 46 characters with two diacritical marks that are used to denote the sounds</p>
<p>Each hiragana symbolizes with a vowel or a consonant combined with a vowel.</p>
<p>Hiraganas are in particular used for function words and inflectional endings, as well as in some content words.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Hiragana</th>
<th>ん</th>
<th>w</th>
<th>r</th>
<th>y</th>
<th>m</th>
<th>h</th>
<th>n</th>
<th>t</th>
<th>s</th>
<th>k</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>ん</td>
<td>わ</td>
<td>ら</td>
<td>や</td>
<td>ま</td>
<td>は</td>
<td>な</td>
<td>た</td>
<td>さ</td>
<td>か</td>
<td>あ</td>
</tr>
<tr>
<td>i</td>
<td></td>
<td></td>
<td>り</td>
<td></td>
<td>み</td>
<td>ひ</td>
<td>に</td>
<td>ち</td>
<td>し</td>
<td>き</td>
<td>い</td>
</tr>
<tr>
<td>u</td>
<td></td>
<td></td>
<td>る</td>
<td>ゆ</td>
<td>む</td>
<td>ふ</td>
<td>ぬ</td>
<td>つ</td>
<td>す</td>
<td>く</td>
<td>う</td>
</tr>
<tr>
<td>e</td>
<td></td>
<td></td>
<td>れ</td>
<td></td>
<td>め</td>
<td>へ</td>
<td>ね</td>
<td>て</td>
<td>せ</td>
<td>け</td>
<td>え</td>
</tr>
<tr>
<td>o</td>
<td></td>
<td>を</td>
<td>ろ</td>
<td>よ</td>
<td>も</td>
<td>ほ</td>
<td>の</td>
<td>と</td>
<td>そ</td>
<td>こ</td>
<td>お</td>
</tr>
</tbody>
</table>
</div>
<p>Katagana is also a syllabary, is used for loan words, onomatopoeic words and scientific words. </p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>考研总结1</title>
    <url>/kaoyan/index.html</url>
    <content><![CDATA[<h2 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享:"></a>经验分享:</h2><ul>
<li><a href="http://www.cskaoyan.com/thread-659004-1-1.html">2020浙江大学计算机考研初试428分经验分享（风华注：初试状元）</a></li>
</ul>
<h2 id="考试内容"><a href="#考试内容" class="headerlink" title="考试内容"></a>考试内容</h2><div class="table-container">
<table>
<thead>
<tr>
<th>科目</th>
<th></th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>政治</td>
<td>101全国统一</td>
<td>100分</td>
</tr>
<tr>
<td>英语</td>
<td>英语一/英语二</td>
<td>100分</td>
</tr>
<tr>
<td>数学</td>
<td>数学一/数学二</td>
<td>150分</td>
</tr>
<tr>
<td>专业课</td>
<td>408/自主命题</td>
<td>150分</td>
</tr>
</tbody>
</table>
</div>
<p>408 = 数据结构 + 计组 + 操作系统 + 计算机网络</p>
<h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发布招生计划       9-10月</span><br><span class="line">报名时间           9-10月</span><br><span class="line">[!]考试(笔试)时间  12月末(大四上学期期末)</span><br><span class="line">初试成绩           2-3月</span><br><span class="line">复试时间           3-5月</span><br><span class="line">[!]offer发放       5-6月</span><br></pre></td></tr></table></figure>
<h2 id="考研趋势"><a href="#考研趋势" class="headerlink" title="考研趋势"></a>考研趋势</h2><p>报考人数逐年升高</p>
<p>报考地区: 北上广,江苏湖北</p>
<p>专硕:学硕=7:3</p>
<p>77%的人来自双非院校</p>
<p>往届生比例与应届生几乎持平</p>
<p>2020报录比 4:1 20%</p>
<h2 id="考研择校"><a href="#考研择校" class="headerlink" title="考研择校"></a>考研择校</h2><h2 id="学硕和专硕"><a href="#学硕和专硕" class="headerlink" title="学硕和专硕"></a>学硕和专硕</h2><ul>
<li><p>学术型硕士</p>
<p>  面向学术科研</p>
</li>
<li><p>专业型硕士</p>
<p>  面向工作, 考试较为容易</p>
<p>  学费贵, 奖学金少</p>
</li>
</ul>
<h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>择校: 目标院校的历年报录比, 历年分数线, 推免人数</p>
<p>择专业: 参考书, 真题, 招生简章, 报考指南</p>
<p>经验: 网络</p>
<p>怎么搜集: </p>
<ul>
<li>目标院校招生信息网</li>
<li>研招网</li>
<li>论坛类(院校论坛等)</li>
<li>知乎豆瓣微信QQ群</li>
</ul>
<h2 id="备考计划"><a href="#备考计划" class="headerlink" title="备考计划"></a>备考计划</h2><!-- 
2018.9 入学, 大一开始
 2019.3 大一下开始
2019.9 大二开始
 2020.3 大二下开始
2020.9 大三开始
-> 2021.3 大三下开始
2021.9 大四开始
=> 2021.12 考研!!
 2022.3 大四下开始
2022.9 毕业
 -->
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1-6月     数学 + 英语基础 + 专业课基础知识</span><br><span class="line">7-8月     数学刷题 + 专业课强化 + 政治基础课&amp;非主观题一刷 + 英语真题</span><br><span class="line">9-10月    (毕业)数学真题 + 政治非主观题二刷 + 专业课刷题&amp;知识点 + 英语真题</span><br><span class="line">11-12月   政治主观题 + 各科查缺补漏</span><br><span class="line">英语贯穿始终, 单词每日看</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">政治: 到3月甚至7月后准备都可</span><br><span class="line">英语: 某些企业对四六级成绩有要求, 背单词!</span><br><span class="line">数学: 先看同济高数&#x2F;辅导书, 做课后习题, 特别是前几章, 刷题</span><br><span class="line">专业课: 刷OJ(如leetcode), 认真做课程项目(整理), 写代码实现常用数据结构, 对以后复试或者就业有帮助</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Learning Sciences —— 学习的科学</title>
    <url>/learn-sci/index.html</url>
    <content><![CDATA[<h1 id="学习的科学"><a href="#学习的科学" class="headerlink" title="学习的科学"></a>学习的科学</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>你是否有过这样的经历：</p>
<ul>
<li>同样是学习，不同的人的效率相差甚远</li>
<li>班级里，某个同学的成绩突飞猛进</li>
<li>背单词毫无章法</li>
<li>想学习一门新技能却感觉无从下手，最后不了了之</li>
</ul>
<p>如果你对上一个问题的回答“是”，那么你是否想要知道其中的原因？既然知识可以被分门别类地总结，那么世界上有没有关于学习的知识呢？</p>
<p>我们从小到大做的最多也是最熟悉的一件事情就是“学习”。一直以来，我们都认为学习是一件简单的事情，但是事实真的如此吗，学习有没有什么方法呢。</p>
<p>目前可能要从以下几个方面入手：</p>
<ul>
<li>心理学方面</li>
<li>记忆规律方面</li>
<li>学习工具</li>
</ul>
<h2 id="教学主义"><a href="#教学主义" class="headerlink" title="教学主义"></a>教学主义</h2><p>我们今天的学校体系实际上是基于从未经过科学验证的常识性假设设计的，例如：</p>
<ul>
<li>知识（Knowledge）是一系列关于世界的事实（Facts）和解决问题的程序（Procedures）的集合。</li>
<li>学校教育的目标是使学生了解这些事实和程序。让一个人拥有大量这样的事实和程序时，他们就被认为是受过教育的。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>10. 正则表达式匹配</title>
    <url>/leetcode/10.html</url>
    <content><![CDATA[<p>实现支持.和*的正则表达式匹配.</p>
<p>思路: 动态规划</p>
<p>用 $f[i][j]$ 表示$s$中的前 $i$ 个字母能否与 $p$ 中的前 $j$ 个字母匹配, 按照$p[j]$是否为*分为两种情况</p>
<p>存在*时的转移方程可以这样考虑: </p>
<ol>
<li><p>匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；($f[i-1][j]$)</p>
</li>
<li><p>不匹配字符，将该组合扔掉，不再进行匹配。($f[i][j - 2]$)</p>
</li>
</ol>
<p>最终的状态转移方程:</p>
<script type="math/tex; mode=display">
f[i][j] = \begin{cases}
f[i - 1][j - 1], & p[j] \neq '*' ~and~ s[i] = p[j] \\
false, & p[j] \neq '*' ~and~ s[i] \neq p[j] \\
f[i][j - 2] ~or~ f[i-1][j], & p[j] = '*' ~and~ s[i] = p[j-1] \\
f[i][j - 2], & p[j] = '*' ~and~ s[i] \neq p[j-1]
\end{cases}</script><p>代码:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size();</span><br><span class="line">        <span class="keyword">int</span> n = p.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> matches = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (matches(i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matches(i, j)) &#123;</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>1018. 可被 5 整除的二进制前缀</title>
    <url>/leetcode/1018.html</url>
    <content><![CDATA[<p>找规律题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">prefixesDivBy5</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp;a:A)&#123;</span><br><span class="line">            res = res * <span class="number">2</span> + a;</span><br><span class="line">            res %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(res % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ret.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ret.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1202. 交换字符串中的元素</title>
    <url>/leetcode/1202.html</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一些可以任意交换位置的组, 求整个字符串的最小字典序</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>用并查集把所有组关联在一起</li>
<li>对于每个可交换组, 把所有候选字母依次填入</li>
</ol>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol>
<li>unordered_map的使用</li>
<li>c++的for-range语法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;[i,group]:groups)&#123;</span><br><span class="line">    sort(group.begin(),group.end(),greater());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>重温并查集</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>参考官方题解优化完毕</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;parents,rank;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dj_root</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (parents[i]==i ? i : parents[i]=dj_root(parents[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dj_union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        a=dj_root(a);</span><br><span class="line">        b=dj_root(b);</span><br><span class="line">        <span class="keyword">if</span>(a==b)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[a]&lt;rank[b])swap(a,b);</span><br><span class="line">        rank[a]+=rank[b];</span><br><span class="line">        parents[a]=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.size();</span><br><span class="line">        parents.resize(n);</span><br><span class="line">        rank.resize(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parents[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp;<span class="built_in">pair</span>:pairs)&#123;</span><br><span class="line">            dj_union(<span class="built_in">pair</span>[<span class="number">0</span>],<span class="built_in">pair</span>[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;groups;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> r=dj_root(i);</span><br><span class="line">            groups[r].push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;[i,group]:groups)&#123;</span><br><span class="line">            sort(group.begin(),group.end(),greater());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> g=dj_root(i);</span><br><span class="line">            s[i]=groups[g].back();</span><br><span class="line">            groups[g].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1203. 项目管理</title>
    <url>/leetcode/1203.html</url>
    <content><![CDATA[<p>双重拓扑排序: 组内 &amp; 组间</p>
<p>拓扑排序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deg, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; items)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item: items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deg[item] == <span class="number">0</span>) &#123;</span><br><span class="line">            Q.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front(); </span><br><span class="line">        Q.pop();</span><br><span class="line">        res.emplace_back(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v: graph[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--deg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.size() == items.size() ? res : <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/xiang-mu-guan-li-by-leetcode-solution-3e7j/">官方题解</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>123. 买卖股票的最佳时机 III</title>
    <url>/leetcode/123.html</url>
    <content><![CDATA[<p>最多可以交易两次</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划, 用四个状态变量</p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/">官方题解</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1395. 统计作战单位数</title>
    <url>/leetcode/1395.html</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">rating</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numTeams = <span class="function"><span class="keyword">function</span> (<span class="params">rating</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; rating.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> ri = rating[i];</span><br><span class="line">        <span class="keyword">let</span> countx1 = <span class="number">0</span>, countx2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> county1 = <span class="number">0</span>, county2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; i; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rating[x] &lt; ri) countx1++;</span><br><span class="line">            <span class="keyword">if</span> (rating[x] &gt; ri) countx2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> x = i + <span class="number">1</span>; x &lt; rating.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rating[x] &lt; ri) county1++;</span><br><span class="line">            <span class="keyword">if</span> (rating[x] &gt; ri) county2++;</span><br><span class="line">        &#125;</span><br><span class="line">        count += countx1 * county2 + countx2 * county1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1584. 连接所有点的最小费用</title>
    <url>/leetcode/1584.html</url>
    <content><![CDATA[<p>实际上是最小生成树</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1833. 雪糕的最大数量</title>
    <url>/leetcode/1833.html</url>
    <content><![CDATA[<p>排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">costs</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">coins</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxIceCream = <span class="function"><span class="keyword">function</span> (<span class="params">costs, coins</span>) </span>&#123;</span><br><span class="line">    costs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (costs[i] &lt;= coins) &#123;</span><br><span class="line">            coins -= costs[i];</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>189. 旋转数组</title>
    <url>/leetcode/189.html</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>使用O(n)时间和O(1)空间旋转数组</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>数学题, GCD</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>下次遇到这种题画个图会更好理解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">if</span>(!n || n == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(k %= n))<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>, _gcd=gcd(n,k); c&lt;_gcd; c++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[c];</span><br><span class="line">            <span class="keyword">int</span> x=c,_x;</span><br><span class="line">            <span class="keyword">while</span>((_x=(x-k+n)%n)!=c)&#123;</span><br><span class="line">                nums[x]=nums[_x];</span><br><span class="line">                x=_x;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[x]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 两数相加</title>
    <url>/leetcode/2.html</url>
    <content><![CDATA[<p>指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode*p1=l1,*p2=l2,*p3,*last=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> up=<span class="number">0</span>;</span><br><span class="line">        ListNode* root=<span class="keyword">new</span> ListNode();</span><br><span class="line">        p3=root;</span><br><span class="line">        <span class="keyword">while</span>(p1 || p2 || up)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1=<span class="number">0</span>,n2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(p1)&#123;n1=p1-&gt;val;p1=p1-&gt;next;&#125;</span><br><span class="line">            <span class="keyword">if</span>(p2)&#123;n2=p2-&gt;val;p2=p2-&gt;next;&#125;</span><br><span class="line">            up+=n1+n2;</span><br><span class="line">            p3-&gt;val=up%<span class="number">10</span>;</span><br><span class="line">            last=p3;</span><br><span class="line">            p3=p3-&gt;next=<span class="keyword">new</span> ListNode();</span><br><span class="line">            up/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> last-&gt;next;</span><br><span class="line">        last-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>205. 同构字符串</title>
    <url>/leetcode/205.html</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt;M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ss = s[i], tt = t[i];</span><br><span class="line">            <span class="keyword">if</span>(M.find(ss)==M.end())&#123;</span><br><span class="line">                <span class="keyword">if</span>(find_if(M.begin(),M.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt;::iterator&amp;it)&#123;<span class="keyword">return</span> it-&gt;second==tt;&#125;)!=M.end())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    M[ss]=tt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(M[ss]!=tt)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>217. 存在重复元素</title>
    <url>/leetcode/217.html</url>
    <content><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>没啥好说的:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> unique(nums.begin(),nums.end())!=nums.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>228. 汇总区间</title>
    <url>/leetcode/228.html</url>
    <content><![CDATA[<p>水题, 注意边界情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">summaryRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> last = (n&gt;<span class="number">0</span>?nums[<span class="number">0</span>]:<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n || nums[i]!=nums[i<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (last==nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    res.push_back(to_string(last));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.push_back(to_string(last)+<span class="string">&quot;-&gt;&quot;</span>+to_string(nums[i<span class="number">-1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;n) last=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>23. 合并K个升序链表</title>
    <url>/leetcode/23.html</url>
    <content><![CDATA[<p>思路类似归并排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode newList;</span><br><span class="line">        ListNode*head=&amp;newList;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> min=<span class="number">-1</span>,minval=<span class="number">0x3fffffff</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.size();i++)&#123;</span><br><span class="line">                ListNode*l=lists[i];</span><br><span class="line">                <span class="keyword">if</span>(l &amp;&amp; l-&gt;val &lt; minval)&#123;</span><br><span class="line">                    min=i;</span><br><span class="line">                    minval=l-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            head-&gt;next=lists[min];</span><br><span class="line">            lists[min]=lists[min]-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newList.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>25. K 个一组翻转链表</title>
    <url>/leetcode/25.html</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseKGroup</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode _header(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *last = &amp;_header;</span><br><span class="line">        head = last;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (head &amp;&amp; count == k) &#123;</span><br><span class="line">                count -= k;</span><br><span class="line">                ListNode *tmp_last_next = last-&gt;next;</span><br><span class="line">                reverseK(last, k);</span><br><span class="line">                head = last = tmp_last_next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _header.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseK</span><span class="params">(ListNode *start, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *cur = start, *next = start-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; k) &#123;</span><br><span class="line">            ListNode *tmp = next-&gt;next;</span><br><span class="line">            next-&gt;next = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">            next = tmp;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        start-&gt;next-&gt;next = next;</span><br><span class="line">        start-&gt;next = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>290. 单词规律</title>
    <url>/leetcode/290.html</url>
    <content><![CDATA[<p>判断给定<em>字符串</em>是不是按照给定<em>模式</em>的短语, 例如”dog dog cat cat”就是”aabb”式的短语</p>
<p>思路: 用map记录模式字母与单词的对应关系, 如果发现不一致, 返回false, 否则返回true</p>
<p>注意: 模式中不同字母对应的单词不能相同</p>
<p>提示: </p>
<p>按照key查询map可以使用map自带的find()函数</p>
<p>按照value查询map可以使用find_if()函数</p>
<p>两者都返回迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">M.find(someKey);</span><br><span class="line">find_if(M.begin(), M.end(), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; kv)&#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; M;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; S;</span><br><span class="line">        <span class="keyword">char</span> *p = strtok((<span class="keyword">char</span> *)s.c_str(), <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="keyword">do</span> &#123;</span><br><span class="line">            S.push_back(p);</span><br><span class="line">        &#125; <span class="keyword">while</span> (p = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.size() != S.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = pattern[i];</span><br><span class="line">            <span class="keyword">if</span> (M.find(ch) == M.end()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (find_if(M.begin(),M.end(),[&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp;p)&#123;<span class="keyword">return</span> p.second==S[i];&#125;)!=M.end())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;S[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                M[ch] = S[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (M[ch] != S[i]) &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;M[ch]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;S[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <url>/leetcode/3.html</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>滑动窗口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; cur_group;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.size() &amp;&amp; cur_group.find(s[end]) == cur_group.end()) &#123;</span><br><span class="line">            cur_group.insert(s[end++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> max_length = cur_group.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            cur_group.erase(s[i]);</span><br><span class="line">            <span class="keyword">while</span> (end &lt; s.size() &amp;&amp; cur_group.find(s[end]) == cur_group.end()) &#123;</span><br><span class="line">                cur_group.insert(s[end++]);</span><br><span class="line">            &#125;</span><br><span class="line">            max_length = <span class="built_in">std</span>::max(max_length, cur_group.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>37. 解数独</title>
    <url>/leetcode/37.html</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>DFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        solveSudoku1(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solveSudoku1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">9</span>||j&gt;=<span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j]==<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">used_numbers</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][k]!=<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    used_numbers[board[i][k]-<span class="string">&#x27;1&#x27;</span>]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[k][j]!=<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    used_numbers[board[k][j]-<span class="string">&#x27;1&#x27;</span>]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> grid_i = i / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> grid_j = j / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">3</span>*grid_i;m&lt;<span class="number">3</span>+<span class="number">3</span>*grid_i;m++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">3</span>*grid_j;n&lt;<span class="number">3</span>+<span class="number">3</span>*grid_j;n++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[m][n]!=<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        used_numbers[board[m][n]-<span class="string">&#x27;1&#x27;</span>]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">9</span>;ii++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (used_numbers[ii]==<span class="literal">false</span>) &#123;</span><br><span class="line">                    board[i][j] = ii+<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (solveSudoku1(board, i+(j+<span class="number">1</span>)/<span class="number">9</span>, (j+<span class="number">1</span>)%<span class="number">9</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> solveSudoku1(board, i+(j+<span class="number">1</span>)/<span class="number">9</span>, (j+<span class="number">1</span>)%<span class="number">9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>376. 摆动序列</title>
    <url>/leetcode/376.html</url>
    <content><![CDATA[<p>思路: 先差分, 然后把所有0和相邻同号的数字(之一)去掉, 剩下的元素数量+2既是最终答案</p>
<p>注意: 元素个数为0, 元素个数为1, 差分后有0出现</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123; <span class="keyword">return</span> size + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            nums[i] -= nums[i + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// find first not zero</span></span><br><span class="line">            <span class="keyword">if</span> (start == <span class="number">-1</span> &amp;&amp; nums[i] != <span class="number">0</span>) &#123; start = i; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// none</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>, want = nums[start];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i] &gt; <span class="number">0</span> &amp;&amp; want &lt; <span class="number">0</span>) ||</span><br><span class="line">                (nums[i] &lt; <span class="number">0</span> &amp;&amp; want &gt; <span class="number">0</span>)) &#123;  <span class="comment">// different sign and no zero</span></span><br><span class="line">                want = nums[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看过题解: 复杂了, 只要统计波峰和波谷的数量就行了</p>
<p>别人的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, prev_diff = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev_diff &gt;= <span class="number">0</span>)</span><br><span class="line">                    count++;</span><br><span class="line">                prev_diff = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev_diff &lt;= <span class="number">0</span>)</span><br><span class="line">                    count++;</span><br><span class="line">                prev_diff = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：lincs</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/wiggle-subsequence/solution/java-on-solution-by-lincs-6l5r/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>389. 找不同</title>
    <url>/leetcode/389.html</url>
    <content><![CDATA[<p>送分题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp;c:s)&#123;</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp;c:t)&#123;</span><br><span class="line">            count[c]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find_if(count.begin(),count.end(),[&amp;](<span class="keyword">auto</span> it)&#123;<span class="keyword">return</span> it.second!=<span class="number">0</span>;&#125;)-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>4. 寻找两个正序数组的中位数</title>
    <url>/leetcode/4.html</url>
    <content><![CDATA[<p>思路: 先归并排序, 再寻找中间位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1=nums1.size(),len2=nums2.size(),len=len1+len2;</span><br><span class="line">        <span class="keyword">int</span> t, lastt;</span><br><span class="line">        <span class="keyword">while</span>(i+j&lt;=len/<span class="number">2</span>)&#123;</span><br><span class="line">            lastt=t;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;len1 &amp;&amp; j&lt; len2)&#123;</span><br><span class="line">                <span class="keyword">int</span> n1=nums1[i];</span><br><span class="line">                <span class="keyword">int</span> n2=nums2[j];</span><br><span class="line">                <span class="keyword">if</span>(n1&lt;n2)&#123;</span><br><span class="line">                    t=n1;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    t=n2;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;len1)&#123;</span><br><span class="line">                t=nums1[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t=nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i+j&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (len%<span class="number">2</span>?t:(t+lastt)/<span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>455. 分发饼干</title>
    <url>/leetcode/455.html</url>
    <content><![CDATA[<p>排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.begin(),g.end()); <span class="comment">// 1 2 3</span></span><br><span class="line">        sort(s.begin(),s.end()); <span class="comment">// 1 1</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.size()<span class="number">-1</span>, gg=g.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;gg&gt;=<span class="number">0</span>;i--,gg--,count++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ss=s[i];</span><br><span class="line">            <span class="keyword">while</span>(gg&gt;=<span class="number">0</span>&amp;&amp;g[gg]&gt;ss)&#123;</span><br><span class="line">                gg--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(gg&lt;<span class="number">0</span>) count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>49. 字母异位词分组</title>
    <url>/leetcode/49.html</url>
    <content><![CDATA[<p>思路: 字符串排序后作为key, 存到map中再转成vector返回, AC</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.size();i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> s=strs[i];</span><br><span class="line">            sort(s.begin(),s.end());</span><br><span class="line">            m[s].push_back(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;k:m)&#123;</span><br><span class="line">            res.push_back(k.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>5. 最长回文子串</title>
    <url>/leetcode/5.html</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划 &lt; 中心扩展算法 &lt; manacher</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> maximum = <span class="number">1</span>, maxI = <span class="number">0</span>, maxJ = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                    <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == j - i - <span class="number">1</span> &amp;&amp; s[i] == s[j])</span><br><span class="line">                        dp[i][j] = max(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; maximum) &#123;</span><br><span class="line">                    maximum = dp[i][j];</span><br><span class="line">                    maxI = i;</span><br><span class="line">                    maxJ = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(s.begin() + maxI, s.begin() + maxJ + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>547. 省份数量</title>
    <url>/leetcode/547.html</url>
    <content><![CDATA[<p>无向图给出邻接表, 计算连通分量个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = isConnected.size();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;flag(len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;found;</span><br><span class="line">                found.push(i);</span><br><span class="line">                flag[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(!found.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> cur = found.front(); found.pop();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!flag[j]&amp;&amp;isConnected[cur][j])&#123;</span><br><span class="line">                            found.push(j);</span><br><span class="line">                            flag[j]=<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>645. 错误的集合</title>
    <url>/leetcode/645.html</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findErrorNums = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ex = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length);</span><br><span class="line">    <span class="keyword">let</span> dup,lost;</span><br><span class="line">    <span class="keyword">for</span>(num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ex[num-<span class="number">1</span>])&#123;</span><br><span class="line">            ex[num-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dup=num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ex[i])&#123;</span><br><span class="line">            lost=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [dup, lost]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>684. 冗余连接</title>
    <url>/leetcode/684.html</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有环无向图中找出环上最后出现的边</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parents;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dj_root</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==parents[a]? a: parents[a]=dj_root(parents[a]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dj_union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        a=dj_root(a);</span><br><span class="line">        b=dj_root(b);</span><br><span class="line">        <span class="keyword">if</span> (a!=b) parents[a]=b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge: edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[<span class="number">0</span>] &gt; n) n = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (edge[<span class="number">1</span>] &gt; n) n = edge[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        parents.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge: edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edge[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> b = edge[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dj_root(a) == dj_root(b)) &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            dj_union(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>738. 单调递增的数字</title>
    <url>/leetcode/738.html</url>
    <content><![CDATA[<p>思路: 对于数字<code>x = an ... ai+1 ai ... a1 a0</code>, 如果任意相邻的<code>ai+1</code>,<code>ai</code>不符合单调递增, 就给原数字减去<code>(ai + 1) * 10 ^ i</code>, 减去之后得到的新数字即为<code>y</code></p>
<p>可以发现, 若<code>x</code>与<code>y</code>不完全相同, 则最终结果在第一个不相同位之后的位必定全是<code>9</code>, 按此规律修正结果即可.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(N);</span><br><span class="line">        <span class="built_in">string</span> olds=s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> bor=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.size()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bor)&#123;</span><br><span class="line">                s[i]--;</span><br><span class="line">                s[i+<span class="number">1</span>]+=<span class="number">10</span>;</span><br><span class="line">                bor=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;s[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="comment">// -s[i]-1</span></span><br><span class="line">                s[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                s[i<span class="number">-1</span>]--;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]&lt;<span class="string">&#x27;0&#x27;</span>) bor = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fix</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;olds[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.size();j++)&#123;</span><br><span class="line">                    s[j]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// restore</span></span><br><span class="line">        <span class="keyword">int</span> val =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            val=val*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>每日 leetcode</title>
    <url>/leetcode/index.html</url>
    <content><![CDATA[<h1 id="决定开始刷leetcode了"><a href="#决定开始刷leetcode了" class="headerlink" title="决定开始刷leetcode了"></a>决定开始刷leetcode了</h1><p>目标:<br><del>每天一道</del><br><del>如果每日一题是easy, 就加一道hard</del><br>如果每日一题是easy, 就加一道medium</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/linear-algebra/index.html</url>
    <content><![CDATA[<h1 id="线性代数笔记"><a href="#线性代数笔记" class="headerlink" title="线性代数笔记"></a>线性代数笔记</h1><h2 id="1-行列式"><a href="#1-行列式" class="headerlink" title="1. 行列式"></a>1. 行列式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>二阶行列式</p>
<p>三阶行列式</p>
<p>全排列</p>
<p>对换</p>
<p>n阶行列式</p>
<p>上下三角行列式</p>
<p>对角行列式</p>
<p>转置行列式</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>转置行列式, 行列式不变</li>
<li><strong>对换行(列), 行列式变号</strong><ul>
<li>两行(列)完全相同, 行列式=0</li>
<li>两行(列)成比例, 行列式=0</li>
</ul>
</li>
<li>一行(列)乘k = 整体乘k<ul>
<li><strong>行(列)系数提到外面, 行列式不变</strong></li>
</ul>
</li>
<li>可以按照某一行(列)分成两个行列式相加</li>
<li><strong>一行乘k加到另一行, 行列式不变</strong></li>
</ul>
<h3 id="按行-列-展开"><a href="#按行-列-展开" class="headerlink" title="按行(列)展开"></a>按行(列)展开</h3><ul>
<li>余子式 $M_{ij}$</li>
<li>代数余子式 $A<em>{ij}=(-1)^{i+j}{M</em>{ij}}$</li>
</ul>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul>
<li><p>按行(列)展开法则 $D=\sum<em>{i=1}^{n}{a</em>{ij}A<em>{ij}}, (j=1,2,…,n)=\sum</em>{j=1}^{n}{a<em>{ij}A</em>{ij}}, (i=1,2,…,n)$</p>
</li>
<li><p>如果上式中$a$和$A$的$j(i)$错开, 则结果为0</p>
</li>
</ul>
<h4 id="范德蒙德行列式"><a href="#范德蒙德行列式" class="headerlink" title="范德蒙德行列式"></a>范德蒙德行列式</h4><script type="math/tex; mode=display">
D_n=\begin{vmatrix}
1&1&...&1 \\
x_1&x_2&...&x_n \\
x_1^2&x_2^2&...&x_n^2 \\
:&:& &: \\
x_1^{n-1}&x_2^{n-1}&...&x_n^{n-1}
\end{vmatrix} 
=\prod_{n\ge i\ge j\ge 1}{(x_i-x_j)}
(注意顺序)</script><h2 id="2-矩阵及其运算"><a href="#2-矩阵及其运算" class="headerlink" title="2. 矩阵及其运算"></a>2. 矩阵及其运算</h2><p>线性方程组</p>
<p>非齐次线性方程组</p>
<p>齐次线性方程组</p>
<p>齐次线性方程组的零解</p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>同型矩阵</p>
<p>系数矩阵</p>
<p>未知数矩阵</p>
<p>常数项矩阵</p>
<p>增广矩阵</p>
<p>线性变换</p>
<h4 id="按性质"><a href="#按性质" class="headerlink" title="按性质"></a>按性质</h4><ul>
<li>非奇异矩阵/可逆矩阵/满秩矩阵</li>
<li>奇异矩阵/不可逆矩阵/降秩矩阵</li>
</ul>
<h4 id="按形状"><a href="#按形状" class="headerlink" title="按形状"></a>按形状</h4><ul>
<li>对角矩阵</li>
<li>单位矩阵</li>
<li>对称矩阵</li>
</ul>
<h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><ul>
<li>矩阵加法<ul>
<li>负矩阵</li>
</ul>
</li>
<li>数乘</li>
<li>矩阵乘法<ul>
<li>可交换</li>
<li>纯量阵: 一定可交换</li>
</ul>
</li>
<li>幂</li>
<li>转置</li>
<li>行列式</li>
<li>伴随矩阵</li>
<li>矩阵多项式</li>
</ul>
<h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h4><h5 id="转置性质"><a href="#转置性质" class="headerlink" title="转置性质"></a>转置性质</h5><ul>
<li>自反性 $(A^{T})^{T}=A$</li>
<li>线性 $(\lambda A+B)^{T}=\lambda A^{T}+B^{T}$</li>
<li>嵌套 $(AB)^{T}=B^{T}A^{T}$</li>
<li>判零 $A^TA=O\Leftrightarrow A=O$</li>
</ul>
<h5 id="行列式性质"><a href="#行列式性质" class="headerlink" title="行列式性质"></a>行列式性质</h5><ul>
<li>常数放大 $\left|\lambda A\right|=\lambda^n\left|A\right|$</li>
<li>可乘性 $\left|AB\right|=\left|A\right|\left|B\right|$</li>
</ul>
<h5 id="伴随矩阵性质"><a href="#伴随矩阵性质" class="headerlink" title="伴随矩阵性质"></a>伴随矩阵性质</h5><ul>
<li>与转置可交换 $(A^T)^<em>=(A^</em>)^T$</li>
<li>与逆可交换 $(A^{-1})^<em>=(A^</em>)^{-1}$</li>
<li>嵌套 $(AB)^<em>=B^</em>A^*$</li>
<li>常数部分放大 $(\lambda A)^<em>=\lambda^{n-1}A^</em>$</li>
</ul>
<h5 id="伴随矩阵的行列式和秩"><a href="#伴随矩阵的行列式和秩" class="headerlink" title="伴随矩阵的行列式和秩"></a>伴随矩阵的行列式和秩</h5><ul>
<li>$\left|A^*\right|=\left|A\right|^{n-1}$</li>
<li>$R(A^<em>)=\begin{cases}n,R(A)=n~(满秩不变)\1,R(A)=n-1~(差1补1)\0,R(A)&lt;n-1~(否则为0, A^</em>=0)\end{cases}$</li>
</ul>
<h3 id="矩阵分块法"><a href="#矩阵分块法" class="headerlink" title="矩阵分块法"></a>矩阵分块法</h3><p>分块矩阵</p>
<p>子块</p>
<p>分块对角矩阵</p>
<ul>
<li>性质<ul>
<li>行列式 $\left|A\right|=\left|A_1\right|\left|A_2\right|…\left|A_n\right|$</li>
<li>逆</li>
</ul>
</li>
</ul>
<h2 id="3-初等变换与线性方程组"><a href="#3-初等变换与线性方程组" class="headerlink" title="3. 初等变换与线性方程组"></a>3. 初等变换与线性方程组</h2><h3 id="初等变换"><a href="#初等变换" class="headerlink" title="初等变换"></a>初等变换</h3><p>行(列)变换 $\Leftrightarrow$ 左(右)乘同样变化之后的$E$</p>
<ul>
<li>对换两行(列)</li>
<li>缩放某一行(列)加到另一行(列)上去 (源和目标可以一样)</li>
</ul>
<p>初等矩阵: 施加一次初等行(列)变换的E</p>
<h3 id="矩阵等价"><a href="#矩阵等价" class="headerlink" title="矩阵等价"></a>矩阵等价</h3><p>A和B等价: A经若干次初等变化可以变为B</p>
<p>等价关系: 自反性, 对称性, 传递性</p>
<p>推论: $A\sim (r)\sim E\Leftrightarrow{A可逆}$</p>
<h4 id="充要条件"><a href="#充要条件" class="headerlink" title="充要条件"></a>充要条件</h4><p>$A\sim (r)\sim B\Leftrightarrow PA=B (P, Q可逆)$</p>
<p>$A\sim (c)\sim B\Leftrightarrow AQ=B (P, Q可逆)$</p>
<p>$A\sim B\Leftrightarrow PAQ=B (P, Q可逆)$</p>
<h3 id="行阶梯形矩阵"><a href="#行阶梯形矩阵" class="headerlink" title="行阶梯形矩阵"></a>行阶梯形矩阵</h3><p>左下角的0组成了一个从右下到左上的阶梯, 这个阶梯的宽度任意, 但是每一级的高度必定为1(两边不算)</p>
<p>非零首元: 非零行的首个非零元素</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
 x & . & . & . & .\\
 0 & x & . & . & .\\
 0 & 0 & x & . & .\\
 0 & 0 & 0 & x & .
\end{pmatrix}
\begin{pmatrix}
 x & . & . & . & .\\
 0 & 0 & 0 & x & .\\
 0 & 0 & 0 & 0 & 0\\
 0 & 0 & 0 & 0 & 0
\end{pmatrix}</script><h3 id="行最简形矩阵"><a href="#行最简形矩阵" class="headerlink" title="行最简形矩阵"></a>行最简形矩阵</h3><p>在行阶梯型矩阵的基础上, 非零首元都是1, 非零首元的上下都是0, 则为行最简形矩阵</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
 1 & 0 & 0 & 0 & .\\
 0 & 1 & 0 & 0 & .\\
 0 & 0 & 1 & 0 & .\\
 0 & 0 & 0 & 1 & .
\end{pmatrix}
\begin{pmatrix}
 1 & . & . & 0 & .\\
 0 & 0 & 0 & 1 & .\\
 0 & 0 & 0 & 0 & 0\\
 0 & 0 & 0 & 0 & 0
\end{pmatrix}</script><ul>
<li>一个矩阵的行最简形矩阵是唯一的</li>
</ul>
<h3 id="标准形"><a href="#标准形" class="headerlink" title="标准形"></a>标准形</h3><p>对行最简形矩阵施加初等列变换, 是非零首元依次排列在左边, 右边全0</p>
<p>特点是左上角是个E</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
 1 & 0 & 0 & 0 & 0\\
 0 & 1 & 0 & 0 & 0\\
 0 & 0 & 1 & 0 & 0\\
 0 & 0 & 0 & 1 & 0
\end{pmatrix}
\begin{pmatrix}
 1 & 0 & 0 & 0 & 0\\
 0 & 1 & 0 & 0 & 0\\
 0 & 0 & 0 & 0 & 0\\
 0 & 0 & 0 & 0 & 0
\end{pmatrix}</script><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="P-A-B-A’-B’"><a href="#P-A-B-A’-B’" class="headerlink" title="$P(A,B)=(A’,B’)$"></a>$P(A,B)=(A’,B’)$</h4><ul>
<li>$P(A, E)=(E, A^{-1})$, 求A逆常用方法</li>
<li>$P(A, B)=(E, A^{-1}B)$, 解方程常用方法</li>
</ul>
<h3 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h3><p>子式: 从行中选出一个子序列, 再从列中选出一个子序列, 得到的结果</p>
<p>秩: 最高阶非零子式的阶数</p>
<h4 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h4><ol>
<li>秩一定小于行(列)数</li>
<li>转置不改变秩</li>
<li>等价矩阵的秩一样: $A\sim B\Leftrightarrow{R(A)=R(B)}$</li>
<li>乘可逆矩阵不改变秩</li>
<li>拼接矩阵的秩可能比原秩要大: $max{R(A),R(B)}\le{R(A~~B)}$</li>
<li>拼接矩阵的秩不会大于原秩之和: $R(A~~B)\le{R(A)+R(B)}$</li>
<li><hr>
</li>
<li>秩和大于和秩(由上一条可证): $R(A+B)\le{R(A)+R(B)}$</li>
<li>矩阵积的秩不大于任何一个原秩(从变换角度看): $R(AB)\le{min{R(A),R(B)}}$</li>
<li>$A<em>{m\times n}B</em>{n\times l}=O\Rightarrow{R(A)+R(B)\le{n}}$</li>
<li><hr>
<p>列满秩: 秩等于列数, 对应的行最简形矩阵为$\begin{pmatrix}E<em>{n} \ O\end{pmatrix}</em>{m\times n}$</p>
</li>
<li><p>乘法消去律: $AB=O, A列满秩\Rightarrow B=O$</p>
</li>
</ol>
<h3 id="秩与线性方程组的解"><a href="#秩与线性方程组的解" class="headerlink" title="秩与线性方程组的解"></a>秩与线性方程组的解</h3><p>相容: 有解</p>
<p>不相容: 无解</p>
<p>判断条件$Ax=b$</p>
<ul>
<li>$无解\Leftrightarrow{R(A)\lt{R(A~~b)}}$</li>
<li>$有解\Leftrightarrow{R(A)={R(A~~b)}}$<ul>
<li>$有唯一解(齐次就是零解)\Leftrightarrow{R(A)=R(A~~b)=n}$</li>
<li>$有无穷解(齐次有非零解)\Leftrightarrow{R(A)=R(A~~b)\lt n}$</li>
</ul>
</li>
</ul>
<h2 id="4-向量组-线性相关性"><a href="#4-向量组-线性相关性" class="headerlink" title="4. 向量组, 线性相关性"></a>4. 向量组, 线性相关性</h2><p>n维向量</p>
<p>实向量</p>
<p>复向量</p>
<p>单位坐标向量: E的列向量</p>
<h3 id="向量组"><a href="#向量组" class="headerlink" title="向量组"></a>向量组</h3><h3 id="线性表示"><a href="#线性表示" class="headerlink" title="线性表示"></a>线性表示</h3><p>线性组合</p>
<p><strong>线性表示</strong>: 一个向量(组)能被另一个向量组线性表示</p>
<p>向量组等价: 两个向量组能互相线性表示</p>
<h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><ul>
<li>$向量b能被向量组A线性表示\Leftrightarrow{R(A)=R(A~~b)}$</li>
<li>$向量组A能被向量组B线性表示\Leftrightarrow R(A)=R(A~~B)$</li>
<li>$向量组A, B能相互线性表示(等价)\Leftrightarrow{R(A)=R(B)=R(A~~B)}$</li>
</ul>
<hr>
<ul>
<li>$若AB=C, 则C的列向量组能被A的列向量组线性表示, 表示的系数为B$</li>
<li><p>$同理, C的行向量组能被B的行向量组线性表示, 表示的系数为A$</p>
</li>
<li><p>$向量组B能被向量组A线性表示\Leftrightarrow R(B)=R(B~~A)\Rightarrow{R(B)\le R(A)}$</p>
</li>
</ul>
<h3 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h3><p>线性相关: 存在一个系数非全零的线性组合=0的向量组</p>
<p>线性无关</p>
<h4 id="性质-4"><a href="#性质-4" class="headerlink" title="性质"></a>性质</h4><ul>
<li>$线性相关\Leftrightarrow{R(A)\lt m}$</li>
<li>$线性无关\Leftrightarrow{R(A)=m}$</li>
<li>$线性相关具有保持性质$</li>
<li>$秩\lt向量个数\Leftrightarrow{线性相关}$</li>
<li>$向量维数\lt向量个数\Rightarrow{线性相关}$</li>
<li>$线性无关向量组A+b变线性相关\Rightarrow{b能被A唯一线性表示}$</li>
</ul>
<h3 id="向量组的秩"><a href="#向量组的秩" class="headerlink" title="向量组的秩"></a>向量组的秩</h3><p>向量组</p>
<p>最大(线性)无关(向量)组</p>
<p>秩: 最大无关组的向量个数</p>
<h4 id="性质见上节"><a href="#性质见上节" class="headerlink" title="性质见上节"></a>性质见上节</h4><h3 id="线性方程组解的结构"><a href="#线性方程组解的结构" class="headerlink" title="线性方程组解的结构"></a>线性方程组解的结构</h3><h4 id="齐次的解-Ax-O"><a href="#齐次的解-Ax-O" class="headerlink" title="齐次的解$Ax=O$"></a>齐次的解$Ax=O$</h4><ul>
<li>齐次: 解的线性组合仍是解</li>
<li>因此只要找到解集的一个最大无关组即可得出所有解</li>
</ul>
<p>基本解系: 齐次的解集的一个最大无关组</p>
<p>基本解系的秩: </p>
<ul>
<li>$对于方程组A_{m\times n}x=0, R_S=n-R(A)$</li>
</ul>
<p>求解步骤:</p>
<ol>
<li>对A进行行变换变成行最简形矩阵</li>
<li>得到x之间的关系</li>
<li>给每个自由变量赋值一个线性无关的向量(一般取单位向量)</li>
</ol>
<p>例题:</p>
<p><img src="index/qiutongjie.png" alt=""></p>
<h5 id="性质-5"><a href="#性质-5" class="headerlink" title="性质"></a>性质</h5><ul>
<li>$Ax=O和Bx=O同解\Rightarrow R(A)=R(B)$</li>
</ul>
<h4 id="非齐次的解-Ax-b"><a href="#非齐次的解-Ax-b" class="headerlink" title="非齐次的解$Ax=b$"></a>非齐次的解$Ax=b$</h4><ul>
<li>非齐次: 利用齐次</li>
<li>找到一个特解, 加上齐次的通解即为最终解</li>
</ul>
<h3 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h3><p>向量空间: 对线性运算封闭的集合</p>
<p>子空间: 含于另一个向量空间的向量空间</p>
<p>基: 在向量空间中, 可以线性表示空间中任一向量的线性无关的向量组</p>
<p>自然基: $R^n$中的单位坐标向量组</p>
<p>维数: 基的向量个数(固定)</p>
<p>坐标: 一个向量在某一个基下的表示</p>
<p><strong>基变换公式</strong>: 用一个基来表示另一个基的坐标(没啥用)</p>
<script type="math/tex; mode=display">
B=AP=AA^{-1}B</script><p><strong>过渡矩阵</strong>: 旧基逆乘新基, 可以用初等变换的方法快速求</p>
<script type="math/tex; mode=display">
P=A^{-1}B</script><p><strong>坐标变换公式</strong>: 一个向量在两个不同基下的坐标的关系式</p>
<script type="math/tex; mode=display">
新坐标~Z=P^{-1}Y</script><h2 id="5-相似矩阵与二次型"><a href="#5-相似矩阵与二次型" class="headerlink" title="5. 相似矩阵与二次型"></a>5. 相似矩阵与二次型</h2><p>内积: 数量积的推广, $[A,B]=A^TB$</p>
<p>长度(范数): 模的推广, $\left|\left|x\right|\right|=\sqrt{[x,x]}$</p>
<p>投影: $c=\frac{[a,b]}{[b,b]}b$</p>
<p>单位向量</p>
<p>单位化</p>
<p>夹角: $\theta=\arccos{\frac{[x,y]}{\left|\left|x\right|\right|~\left|\left|y\right|\right|}}$</p>
<h3 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h3><p>正交: 夹角为0</p>
<p>正交向量组: 一组向量两两正交, 必定线性无关</p>
<p>标准正交基: 单位向量组成的正交向量组</p>
<p>标准正交化, 施密特正交化</p>
<p>正交(矩)阵: 单位正交向量组构成的矩阵</p>
<ul>
<li>$AA^T=E=A^TA$</li>
<li>$A^T=A^{-1}$</li>
<li>$\left|A\right|=1或-1$</li>
<li>正交矩阵的逆(转置)也是正交矩阵</li>
<li>正交矩阵的积还是正交矩阵</li>
</ul>
<p>正交变换: $若P是正交矩阵, 则线性变换y=Px称为正交变换$</p>
<ul>
<li>特性</li>
<li>变换前后的长度不变 $||y||=\sqrt{y^Ty}=\sqrt{x^TP^TPx}=\sqrt{x^Tx}=||x||$</li>
</ul>
<h3 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h3><p>特征多项式: $f(\lambda)=\left|A-\lambda E\right|$</p>
<p>特征值/特征向量: $A为n阶矩阵, 满足Ax=\lambda x, (A-\lambda E)x=0的\lambda和x$</p>
<p>个数: $f(\lambda)=0是一元n次方程, \lambda必有n个根, 所以方程有n个解$</p>
<h4 id="性质-6"><a href="#性质-6" class="headerlink" title="性质"></a>性质</h4><ul>
<li>特征值之和等于矩阵的迹</li>
<li>特征值之积等于矩阵的行列式</li>
<li>矩阵多项式的特征值等于矩阵特征值的多项式: $f(\lambda)是f(A)的特征值$</li>
<li>$特征值各不相等\Rightarrow特征向量线性无关$</li>
<li>对角矩阵的对角元就是其特征值</li>
</ul>
<h4 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h4><ol>
<li>根据特征多项式=0求出特征值</li>
<li>将每个特征值代回原方程, 写出特征向量(个数=n-特征值重数)</li>
</ol>
<h3 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h3><p>相似矩阵: $P^{-1}AP=B$</p>
<p>相似变换: $P^{-1}AP$</p>
<h4 id="性质-7"><a href="#性质-7" class="headerlink" title="性质"></a>性质</h4><ul>
<li>特征多项式($f(\lambda)=\left|A-\lambda E\right|$)相同</li>
<li>特征值相同</li>
<li>迹相同</li>
<li><strong>计算矩阵多项式</strong>: $\varphi(A)=P\varphi(B)P^{-1}$<ul>
<li>一般B是对角矩阵, 从而可以快速计算B的幂:</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
\varphi(\Lambda)=\begin{pmatrix}
\varphi(\lambda_1)&&&\\
&\varphi(\lambda_2)&&\\
&&...&\\
&&&\varphi(\lambda_n)
\end{pmatrix}</script><h4 id="对角化"><a href="#对角化" class="headerlink" title="对角化"></a>对角化</h4><p>对角化: 寻找相似变换矩阵P来使$P^{-1}AP=\Lambda$为对角矩阵</p>
<p>能对角化的条件: $A有n个线性无关的特征向量$</p>
<ul>
<li>常用条件:</li>
<li>$有n个各不相同的特征值$</li>
<li>$如果特征值有重根, 则可以判断特征矩阵的秩$</li>
</ul>
<h4 id="对称矩阵的对角化"><a href="#对称矩阵的对角化" class="headerlink" title="对称矩阵的对角化"></a>对称矩阵的对角化</h4><p>对称矩阵的性质:</p>
<ul>
<li>特征值为实数</li>
<li>不相等的特征值对应的特征向量正交</li>
<li>一定存在正交矩阵P使得A<strong>可以被对角化</strong>为以特征值为对角元的对角矩阵</li>
</ul>
<p>求法:</p>
<ol>
<li>求出A的特征值</li>
<li>求出所有特征向量</li>
<li>把这些特征向量正交化, 单位化</li>
<li>排列得到$P$和$\Lambda$, 注意两者对应</li>
</ol>
<p><img src="index/duijiaohua.png" alt=""></p>
<h3 id="二次型-标准形"><a href="#二次型-标准形" class="headerlink" title="二次型, 标准形"></a>二次型, 标准形</h3><p>二次型: 含n个变量的<strong>二次齐次</strong>函数</p>
<p>$f(x<em>1,x_2,…,x_n)=\sum{a</em>{i,j}x<em>{i}x</em>{j}}$</p>
<p>标准形(法式): 只含<strong>平方项</strong>的二次型</p>
<p>$f(x<em>1,x_2,…,x_n)=\sum{k</em>{i}x_{i}^2}$</p>
<p>规范形: 系数只在-1,0,1中取值的标准形</p>
<p>二次型的矩阵表示: 二次型可以用系数组成的对称矩阵唯一表示</p>
<script type="math/tex; mode=display">
\begin{aligned}
f&=\sum{a_{ij}x_{i}x_{j}}, (a_{ij}=a_{ji})\\
&=\begin{pmatrix}
x_1&x_2&...&x_n
\end{pmatrix}
\begin{pmatrix}
a_{11}&a_{12}&...&a_{1n}\\
a_{21}&a_{22}&...&a_{2n}\\
...&...&...&...\\
a_{n1}&a_{n2}&...&a_{nn}
\end{pmatrix}
\begin{pmatrix}
x_1\\
x_2\\
...\\
x_n
\end{pmatrix}\\
&=x^TAx
\end{aligned}</script><p>二次型的秩: 对应矩阵的秩</p>
<h3 id="合同对角化"><a href="#合同对角化" class="headerlink" title="合同对角化"></a>合同对角化</h3><p><strong>合同</strong>: $若存在可逆矩阵C使得B=C^TAC, 则称B与A合同$</p>
<p>性质</p>
<ul>
<li>对阵矩阵的合同矩阵也对称</li>
</ul>
<p><strong>合同对角化</strong>: $寻找可逆矩阵C, 使得C^TAC为对角矩阵, 从而使二次型A通过x=Cy变换成标准形$</p>
<script type="math/tex; mode=display">
\begin{aligned}
f&=x^TAx\\
&=y^T(C^TAC)y
\end{aligned}</script><p>可以证明(由对称矩阵性质)这个矩阵一定存在, 而且是正交矩阵, 变换后的$C^TAC$由特征值构成</p>
<h3 id="正定二次型"><a href="#正定二次型" class="headerlink" title="正定二次型"></a>正定二次型</h3><p>惯性定理: 同一个二次型的两种标准化结果中正负系数的个数相同</p>
<p>正(负)惯性指数: 其中的正(负)系数的个数</p>
<p>正(负)定二次型, 正(负)定矩阵: 如果二次型的值恒大(小)于零(x=0除外), 则称f为正(负)定二次型, 称A是正(负)定的</p>
<ul>
<li>$正定\Leftrightarrow正惯性指数=n\Leftrightarrow特征值全正\\Leftrightarrow各阶主子式都为正\Leftrightarrow存在可逆P,使得P^TAP=E(与E合同)$</li>
<li>$负定\Leftrightarrow奇数阶主子式为负, 偶数阶为正$</li>
</ul>
<h2 id="6-线性空间与线性变换"><a href="#6-线性空间与线性变换" class="headerlink" title="6. 线性空间与线性变换"></a>6. 线性空间与线性变换</h2><p>向量空间(线性空间): 定义了线性运算且封闭, 且满足以下运算规律的非空集合</p>
<ol>
<li>加法交换律</li>
<li>加法结合律</li>
<li>加法零元</li>
<li>加法逆元</li>
<li>乘法单位元</li>
<li>乘法交换律</li>
<li>乘法结合律</li>
<li>乘法对加法分配律</li>
</ol>
<p>向量: 线性空间中的元素</p>
<p>子空间: 线性空间的仍是线性空间的非空子集</p>
<p>基, 维数, 坐标: 同线性空间</p>
<p>过渡矩阵 $P=A^{-1}B$</p>
<p>基变换公式, 坐标变换公式 </p>
<h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>映射(变换): 表示为$\beta=T(\alpha)或\beta=T\alpha$</p>
<p>定义域A, 值域B, 像集T(A): $T(A)={\beta=T(\alpha)|\alpha\in A} \subseteq B$</p>
<p>线性映射(线性变换): 从Vn到Um的保持线性组合的对应关系的映射. 特别地, 如果Vn=Um, 称T为线性空间Vn中的线性变换</p>
<ul>
<li>$T(a+b)=T(a)+T(b)$</li>
<li>$T(\lambda b)=\lambda T(b)$</li>
</ul>
<p>线性变换的性质:</p>
<ol>
<li>T(0)=0</li>
<li>线性组合的变换等于变换的线性组合</li>
<li>变换前线性相关=&gt;变换后也线性相关</li>
<li>像集$T(V_n)$也是线性空间, 称为<strong>像空间</strong></li>
<li>$N_T={\alpha|\alpha\in V_n, T\alpha=0}$构成线性空间, 称为线性变换T的<strong>核</strong></li>
</ol>
<h3 id="线性变换的矩阵表示"><a href="#线性变换的矩阵表示" class="headerlink" title="线性变换的矩阵表示"></a>线性变换的矩阵表示</h3><p>线性变换的矩阵: 在Vn中取定一个基, 这个基的像的线性表示的系数矩阵称为线性变换在这个基下的矩阵, 即</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
T(\alpha_1)=\sum_{j=1}^{n}{a_{j1}\alpha_j}\\
T(\alpha_2)=\sum_{j=1}^{n}{a_{j2}\alpha_j}\\
...\\
T(\alpha_n)=\sum_{j=1}^{n}{a_{jn}\alpha_j}
\end{matrix}\right.</script><p>令</p>
<script type="math/tex; mode=display">
A=\begin{pmatrix}
a_{11}& a_{12}& ...& a_{1n}\\  
a_{21}& a_{22}& ...& a_{2n}\\  
:& :& & :\\  
a_{n1}& a_{n2}& ...& a_{nn}\\  
\end{pmatrix}\\</script><p>则</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(\alpha_1, \alpha_2, ..., \alpha_n)&=(\alpha_1, \alpha_2, ..., \alpha_n)A
\end{aligned}</script><h4 id="性质-8"><a href="#性质-8" class="headerlink" title="性质"></a>性质</h4><ul>
<li>同一个变换在不同基下的矩阵<strong>相似</strong>, 且相似变换矩阵就是两个基的过渡矩阵P</li>
</ul>
<h4 id="相似-合同与等价"><a href="#相似-合同与等价" class="headerlink" title="相似, 合同与等价"></a>相似, 合同与等价</h4><ul>
<li><p>等价$\Leftrightarrow$AB秩相同</p>
</li>
<li><p>合同=等价+正负惯性系数相同</p>
</li>
<li><p>相似=合同+特征值相同+主对角线元素之和相同+矩阵的值相同</p>
</li>
</ul>
<p>由此可见，等价到合同到相似，条件越来越苛刻，AB共同点越来越多</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>线性代数</category>
      </categories>
  </entry>
  <entry>
    <title>Bash使用</title>
    <url>/shell/bash.html</url>
    <content><![CDATA[<h1 id="Bash基本使用"><a href="#Bash基本使用" class="headerlink" title="Bash基本使用"></a>Bash基本使用</h1><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">^c   终止当前进程</span><br><span class="line">^z   将当前进程挂起到后台</span><br><span class="line">^d   退出, 等价于<span class="built_in">exit</span></span><br><span class="line">^l   清屏</span><br><span class="line">^r   搜索历史命令</span><br><span class="line">^a   光标移到开头</span><br><span class="line">^e   光标移到结尾</span><br><span class="line">^u   删除光标前所有内容</span><br><span class="line">^k   删除光标后所有内容</span><br></pre></td></tr></table></figure>
<h2 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*                       匹配前面的内容任意次</span><br><span class="line">?                       匹配前面的内容0-1次</span><br><span class="line">[list]                  list中任意一个字符</span><br><span class="line">&#123;string1,string2,...&#125;   string1,string2或者更多字符串</span><br></pre></td></tr></table></figure>
<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><ul>
<li>双引号<code>&quot;&quot;</code>  把引号中的内容作为一个整体, 允许通过$符号来引用其他变量值</li>
<li>单引号<code>&#39;&#39;</code>  把引号中的内容作为一个整体, 禁止通过$符号来引用其他变量值, 其中的shell特殊符号都视为普通字符</li>
<li>反引号      与$()相同, 先执行引号中的内容, 不能嵌套</li>
</ul>
<h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>HashBang</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure>
<ul>
<li>命令</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><ul>
<li>标准方式</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod +x script.sh</span><br><span class="line">./script.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>非标准方式</li>
</ul>
<ol>
<li>直接指定解释器执行</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash script.sh</span><br><span class="line"><span class="comment"># -x 显示脚本的执行过程, 用于debug</span></span><br><span class="line"><span class="comment"># -n 检查语法是否有问题</span></span><br></pre></td></tr></table></figure>
<ol>
<li>使用source命令执行</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> script.sh</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>变量名不能由数字开头</li>
<li>区分大小写</li>
</ul>
<h2 id="读取用户输入"><a href="#读取用户输入" class="headerlink" title="读取用户输入"></a>读取用户输入</h2><p>语法：<code>read [选项] 变量名</code></p>
<ul>
<li><code>-p</code> 提示信息</li>
<li><code>-n</code> 输入长度</li>
<li><code>-s</code> 不回显</li>
<li><code>-t</code> 超时时间, 单位s</li>
</ul>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$$      当前进程号</span><br><span class="line">$?      上一条命令的返回值</span><br><span class="line"><span class="variable">$_</span>      上一条命令的最后一个参数</span><br><span class="line"><span class="variable">$0</span>      当前执行的程序（脚本文件）名</span><br><span class="line"><span class="variable">$&#123;x&#125;</span>    第x个参数</span><br><span class="line">$*      所有参数</span><br><span class="line"><span class="variable">$@</span>      所有参数</span><br><span class="line"><span class="variable">$#</span>      执行时所带的参数个数</span><br><span class="line">$!      后台运行的最后一个进程的进程号</span><br></pre></td></tr></table></figure>
<h2 id="简单四则运算"><a href="#简单四则运算" class="headerlink" title="简单四则运算"></a>简单四则运算</h2><div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$(( ))</code></td>
<td><code>echo $((1+1))</code></td>
</tr>
<tr>
<td><code>$[ ]</code></td>
<td><code>echo $[10-5]</code></td>
</tr>
<tr>
<td><code>expr</code></td>
<td><code>expr 10 / 5</code></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/shell/commands.html</url>
    <content><![CDATA[<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h2><p>按下Ctrl+l</p>
<h2 id="快速清空文件内容"><a href="#快速清空文件内容" class="headerlink" title="快速清空文件内容"></a>快速清空文件内容</h2><p>利用文件写入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; filename</span><br></pre></td></tr></table></figure>
<h1 id="实用程序"><a href="#实用程序" class="headerlink" title="实用程序"></a>实用程序</h1><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>显示文件内容, 如果输入是多个文件也可以用于文件拼接</p>
<ul>
<li><code>-n</code> 显示行号</li>
</ul>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>行过滤</p>
<ul>
<li><code>-n</code> 显示行号</li>
<li><code>-i</code> 忽略大小写</li>
<li><code>-c</code> 统计结果行数</li>
<li><code>-A</code> 显示匹配处后多少行</li>
<li><code>-B</code> 显示匹配处前多少行</li>
<li><code>-C</code> 显示匹配处前后多少行</li>
<li><code>--color=auto</code> 彩色显示</li>
<li><code>^</code> 行开头</li>
<li><code>$</code> 行末尾</li>
</ul>
<h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>列截取</p>
<ul>
<li><code>-d</code> 分隔符</li>
<li><code>-f</code> 分割后取出哪些列</li>
</ul>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>对标准输入进行排序, 默认是升序排列</p>
<ul>
<li><code>-r</code> 逆序排列, 即按降序排列</li>
<li></li>
</ul>
<h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>连续行去重, 即对标准输入中连续重复的行只保留一个</p>
<h2 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h2><p>把标准输入写入到标准输出和一个文件中, 即: 双向<strong>覆盖</strong>重定向(屏幕+文件输出)</p>
<ul>
<li><code>-a</code> 双向<strong>追加</strong>重定向</li>
</ul>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>描述怎样改变第一个文件使之与第二个文件匹配</p>
<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>基于diff的结果修改一个文件</p>
<h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><p>将两个文件逐行拼接, 与cut相反</p>
<ul>
<li><code>-d</code> 指定分割符, 默认是tab</li>
<li><code>-s</code> 将结果转置</li>
</ul>
<h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p>字符转换, 替换和删除. 主要用于删除文件中的控制字符, 或者进行字符转换</p>
<p>格式:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tr set1 set2 &lt; stdin</span><br></pre></td></tr></table></figure>
<p>把字符集1中的字符替换成字符集2中的字符</p>
<p>例:</p>
<ul>
<li>小写转大写 <code>tr a-z A-Z &lt; package.json</code></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程</title>
    <url>/software-engineer/index.html</url>
    <content><![CDATA[<ol>
<li>软件的本质<ol>
<li>软件的本质<ol>
<li>定义<ol>
<li>有很多种定义, 以书上(P3)的定义为准, 指令的集合+数据结构+软件描述信息</li>
</ol>
</li>
<li>软件应用的领域<ol>
<li>系统软件/应用软件/工业软件/嵌入式软件/产品线软件/Web移动应用程序/AI软件</li>
</ol>
</li>
<li>遗留软件<ol>
<li>挑战: <ol>
<li>生命周期长</li>
<li>质量差</li>
<li>原有功能质量不符合现代的要求</li>
</ol>
</li>
<li>需要演化的情况<ol>
<li>适应性调整, 满足新的环境/技术</li>
<li>升级, 实现新的商业需求</li>
<li>拓展, 与新的系统或数据库互操作</li>
<li>改建, 适应不断演化的计算环境</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>软件的变更本质<ol>
<li>是生命体, 在生长</li>
<li>四大类占主导地位的软件<ol>
<li>WebApp/移动App/云计算/产品线软件</li>
</ol>
</li>
</ol>
</li>
<li>软件失效率曲线<ol>
<li>理想曲线: 未知的缺陷将在软件生命周期的前期造成高失效率, 但随着错误的纠正, 曲线将趋于平缓, 软件不会磨损, 但是会退化</li>
<li>事实曲线: 软件会面临变更, 每次变更都会导致失效率陡然上升, 在曲线回到最初的状态前, 新的变化又会再次导致曲线上升, 最终导致最小的失效率点沿斜线的形状逐渐上升</li>
<li>不断的变更是导致软件失效的根本原因</li>
</ol>
</li>
<li>云计算<ol>
<li>应用软件: 监控/内容/协作/通信/财务</li>
<li>平台: 对象存储/身份/运行时/队列/数据库</li>
<li>基础设施: 计算/块存储/网络</li>
</ol>
</li>
</ol>
</li>
<li>软件工程<ol>
<li><strong>软件工程的定义</strong><ol>
<li>以书上为准 IEEE<ol>
<li>将(系统化, 规范的, 可量化的)工程化方法应用于软件的开发,运行和维护</li>
<li>对上述方法的研究</li>
</ol>
</li>
<li>软件工程层次<ol>
<li>工具on方法on过程on质量关注点</li>
<li>过程process<ol>
<li>包括<ol>
<li>活动activities<ol>
<li>实现宽泛的目标</li>
</ol>
</li>
<li>动作actions<ol>
<li>主要工作产品生产过程中的一系列任务</li>
</ol>
</li>
<li>任务tasks<ol>
<li>小而明确的目标, 实际产品</li>
</ol>
</li>
</ol>
</li>
<li>过程框架<ol>
<li><strong>沟通/策划/建模/构建/部署</strong></li>
<li>软件工程: 过程框架/普适性活动/框架活动i/软件工程动作i.j/任务集</li>
</ol>
</li>
</ol>
</li>
<li>方法method:</li>
<li>工具tool:</li>
</ol>
</li>
</ol>
</li>
<li><strong>软件开发神话</strong>: 为什么需要软件工程</li>
<li>注意思考题</li>
</ol>
</li>
<li>软件过程<ol>
<li>通用过程框架<ol>
<li>每个框架活动由一系列动作构成, 每个动作由任务集来定义</li>
<li>任务集明确了将要完成的工作任务,将要产生的工作产品,需要的质量保证点,用于表明过程状态的里程碑</li>
</ol>
</li>
<li>过程流图<ol>
<li>线性过程流</li>
<li>迭代过程流</li>
<li>演化过程流</li>
<li>并行过程流</li>
</ol>
</li>
<li>明确任务集(细胞)<ol>
<li>注意<img src="index/3.3.png" alt="3.3信息栏"></li>
</ol>
</li>
<li>过程模式<ol>
<li>注意<img src="index/3.4.png" alt="3.4信息栏"></li>
<li>模板process pattern<ol>
<li>模式名称</li>
<li>驱动力</li>
<li>类型<ol>
<li>步骤模式</li>
<li>任务模式</li>
<li>阶段模式</li>
</ol>
</li>
<li>启动条件</li>
<li>问题</li>
<li>解决方案</li>
<li>结果</li>
<li>相关模式</li>
<li>已知应用和实例</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>过程模型: 1,2个, 也可能简答题<ol>
<li>分类: 传统的/敏捷的</li>
<li>各种模型的特点</li>
<li>瀑布模型是基础<ol>
<li>沟通/策划/建模/构建/部署</li>
</ol>
</li>
<li>V模型</li>
<li>增量模型<ol>
<li>特点 <ol>
<li><strong>第一个增量是核心产品</strong></li>
</ol>
</li>
</ol>
</li>
<li>螺旋模型<ol>
<li>结合原型的选代性质和瀑布模型的可控性和系统性特点</li>
<li>特点<ol>
<li>风险识别和应对</li>
</ol>
</li>
</ol>
</li>
<li>UP统一过程<ol>
<li><img src="index/4.7.png" alt="4.7"></li>
</ol>
</li>
</ol>
</li>
<li><p>敏捷</p>
<ol>
<li>定义</li>
<li>敏捷宣言</li>
<li>XP<ol>
<li>特征<ol>
<li>保持KIS原则</li>
<li>鼓励使用CRC</li>
<li>先单元测试后代码</li>
<li>结对编程</li>
<li>重构: 以不改变其外部功能或行为而改进设计（或源代码）的内部结构。</li>
</ol>
</li>
<li>用户故事: 描述将要开发的软件所需要的输出, 特征以及功能</li>
</ol>
</li>
<li>Scrum<ol>
<li>特征<ol>
<li>待定项backlog</li>
<li>冲刺sprint</li>
<li>每日站会</li>
</ol>
</li>
<li>人员<ol>
<li>Product Owner：杜老师</li>
<li>Scrum Master：邱博</li>
<li>Team：三个组员</li>
</ol>
</li>
<li>步骤<ol>
<li>我们首先要确定一个Product Backlog（按优先顺序排列的一个产品需求列表）</li>
<li>团队根据product backlog做工作量的估算</li>
<li>通过Sprint Planning meeting，来从中挑选出一个Story作为本次迭代完成的目标，时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog </li>
<li>在Sprint backlog再细化成更小的任务，成员领取任务（2天的工作量左右）</li>
<li>过程中要进行每日站立会议，控制在15分钟左右，汇报昨天完成了什么，今天要做什么，遇到了哪些问题</li>
<li>做到每日集成，每天都可以有一个成功编译，并且可以演示的版本。</li>
<li>当一个Story完成，业绩就是Sprint backlog完成，表示一次Sprint的完成，这时，要进行Sprint review meeting。</li>
<li>最后就是Spring Retrospective Meeting，总结会议，每个人总结并讨论改进，放入到下一次Sprint的产品需求中。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>__</p>
</li>
<li><p>指导实践的原则</p>
<ol>
<li>软件工程知识</li>
<li>核心原则</li>
<li>指导每个框架活动的原则</li>
</ol>
</li>
<li><p>需求工程</p>
<ol>
<li>需求工程过程: 开始/获取/细化/协商/<strong>规格说明(SRS)</strong>/确认/需求管理</li>
<li>用例模板<ol>
<li>用例</li>
<li>主/次要参与者, 使用方式</li>
<li>何时可用/使用频率</li>
</ol>
</li>
<li>需求的建立(开始): 利益相关者/协同合作</li>
<li>收集需求(获取)</li>
<li>开发用例: 编写<strong>用例规约</strong></li>
<li>构建<strong>分析模型</strong>: <ol>
<li>元素: 基于场景的元素(活动图)/基于类的元素(类图)/行为元素(状态图)<ol>
<li>状态图: [状态名|状态变量|状态活动]</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>需求建模: 基于场景</p>
<ol>
<li>域分析: 查找或创建广泛应用的分析类或分析模式, 进行复用<ol>
<li>输入: 技术资料/已有的应用系统/客户调查/专家建议/当前,未来需求</li>
<li>输出: 类的分类/复用标准/功能模型/域语言</li>
</ol>
</li>
<li>用例图, 活动图</li>
<li>泳道图</li>
</ol>
</li>
<li><p>需求建模: 类</p>
<ol>
<li>识别分析类, 属性, 操作</li>
<li>语法分析法<ol>
<li>名词: 类/属性</li>
<li>动词: 操作</li>
</ol>
</li>
<li>CRC</li>
</ol>
</li>
<li><p>需求建模: 行为和模式</p>
<ol>
<li>识别行为模型: 相对前面的建模是动态的</li>
<li>识别用例事件</li>
<li>状态表达: <ol>
<li><strong>状态图</strong></li>
<li>顺序图(序列图)</li>
</ol>
</li>
<li>Web/移动App的需求建模<ol>
<li>类型: <ol>
<li>内容模型<ol>
<li>包含所有内容对象和分析类</li>
<li></li>
</ol>
</li>
<li>交互模型<ol>
<li>功能, 内容和行为之间的交流</li>
<li>包括用例/时序图/状态图/UI原型</li>
</ol>
</li>
<li>功能模型</li>
<li>导航模型</li>
<li>配置模型 </li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>设计<ol>
<li>作用<ol>
<li>产生设计模型: 数据/类设计,体系结构设计,接口设计,构建级设计</li>
<li><img src="index/12.1.png" alt=""></li>
</ol>
</li>
<li>设计概念定义<ol>
<li>抽象/体系结构/模式/关注点分离/模块化/信息隐蔽/功能独立/逐步求精/方面/重构/OOP/设计类/依赖倒置/测试设计</li>
</ol>
</li>
<li>设计模型<ol>
<li>xx设计元素: 数据/体系结构/接口/构建级/部署级</li>
</ol>
</li>
</ol>
</li>
<li>架构级设计<ol>
<li>软件体系结构: 系统的一个或者多个结构，它包括软件构件、构件的外部可见属性以及它们之间的相互关系。</li>
<li>体系结构环境图ACD</li>
</ol>
</li>
<li>构件级设计<ol>
<li>构件<ol>
<li>系统中模块化的, 可部署的和可替换的部件, 该部件封装了实现并对外提供一组接口</li>
</ol>
</li>
<li>设计原则<ol>
<li>OCP/LSP/DIP/ISP/REP/CCP/CRP</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="最后一题-UML的五类图-40分"><a href="#最后一题-UML的五类图-40分" class="headerlink" title="最后一题: UML的五类图 40分"></a>最后一题: UML的五类图 40分</h2><ol>
<li>用例图</li>
<li>静态图<ol>
<li>类图</li>
<li>对象图</li>
<li>包图</li>
</ol>
</li>
<li>行为图<ul>
<li>状态图和活动图格式完全一样, 起点用黑点, 终点是带圈黑点</li>
<li>活动图可以带泳道</li>
</ul>
<ol>
<li>状态图<ul>
<li>仅为那些有多个状态其行为受外界环境的影响并且发生改变的类画状态图</li>
<li><img src="index/state_diagram.png" alt=""></li>
</ul>
</li>
<li>活动图<ul>
<li><img src="index/activity_diagram.png" alt=""></li>
</ul>
</li>
</ol>
</li>
<li>交互图<ol>
<li>顺序图(序列图)<ul>
<li>强调时间和顺序</li>
<li><img src="index/sequence_diagram.png" alt=""></li>
</ul>
</li>
<li>协作图(通讯图)<ul>
<li>强调上下级关系</li>
<li><img src="index/comm_diagram.png" alt=""></li>
</ul>
</li>
</ol>
</li>
<li>实现图<ol>
<li>构件图<ul>
<li><img src="index/comp_diagram.png" alt=""></li>
</ul>
</li>
<li>配置图<ul>
<li><img src="index/deploy_diagram.png" alt=""></li>
</ul>
</li>
</ol>
</li>
</ol>
<p>CMM: 一级为初始级，二级为可重复级，三级为已定义级，四级为已管理级，五级为优化级</p>
<p>P179 构建细化</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>每日上报自动打卡</title>
    <url>/tools/auto_check.html</url>
    <content><![CDATA[<h1 id="每日上报自动打卡程序"><a href="#每日上报自动打卡程序" class="headerlink" title="每日上报自动打卡程序"></a>每日上报自动打卡程序</h1><figure class="highlight python"><figcaption><span>auto_check.py</span><a href="/downloads/code/auto_check.py">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse, error</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">token, param: <span class="built_in">dict</span> = {}</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;每日上报&#x27;&#x27;&#x27;</span></span><br><span class="line">    req = request.Request(<span class="string">&#x27;https://tjxsfw.chisai.tech/api/school_tjxsfw_student/yqfkLogDailyreport/v2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    req.add_header(<span class="string">&#x27;User-Agent&#x27;</span>, <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:78.0) Gecko/20100101 Firefox/78.0&#x27;</span>)</span><br><span class="line">    req.add_header(<span class="string">&#x27;Accept-Language&#x27;</span>, <span class="string">&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;</span>)</span><br><span class="line">    req.add_header(<span class="string">&#x27;Host&#x27;</span>, <span class="string">&#x27;tjxsfw.chisai.tech&#x27;</span>)</span><br><span class="line">    req.add_header(<span class="string">&#x27;Referer&#x27;</span>, <span class="string">&#x27;https://servicewechat.com/wx427cf6b5481c866a/27/page-frame.html&#x27;</span>)</span><br><span class="line">    req.add_header(<span class="string">&#x27;Authorization&#x27;</span>, <span class="string">f&#x27;Bearer <span class="subst">{token}</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    payload = parse.urlencode([</span><br><span class="line">        (<span class="string">&#x27;studentPid&#x27;</span>, param.get(<span class="string">&#x27;studentPid&#x27;</span>)),  <span class="comment"># pid</span></span><br><span class="line">        (<span class="string">&#x27;studentName&#x27;</span>, param.get(<span class="string">&#x27;studentName&#x27;</span>)),  <span class="comment"># 姓名</span></span><br><span class="line">        (<span class="string">&#x27;studentStudentno&#x27;</span>, param.get(<span class="string">&#x27;studentStudentno&#x27;</span>)),  <span class="comment"># 学号</span></span><br><span class="line">        (<span class="string">&#x27;studentCollege&#x27;</span>, param.get(<span class="string">&#x27;studentCollege&#x27;</span>, <span class="string">&#x27;软件学院&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locLat&#x27;</span>, param.get(<span class="string">&#x27;locLat&#x27;</span>, <span class="string">&#x27;31.37482&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locLng&#x27;</span>, param.get(<span class="string">&#x27;locLng&#x27;</span>, <span class="string">&#x27;121.26621&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locNation&#x27;</span>, param.get(<span class="string">&#x27;locNation&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locProvince&#x27;</span>, param.get(<span class="string">&#x27;locProvince&#x27;</span>, <span class="string">&#x27;上海市&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locCity&#x27;</span>, param.get(<span class="string">&#x27;locCity&#x27;</span>, <span class="string">&#x27;上海市&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locDistrict&#x27;</span>, param.get(<span class="string">&#x27;locDistrict&#x27;</span>, <span class="string">&#x27;嘉定区&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;healthy&#x27;</span>, param.get(<span class="string">&#x27;healthy&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;source&#x27;</span>, param.get(<span class="string">&#x27;source&#x27;</span>, <span class="string">&#x27;weixin,windows&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;reportDatetime&#x27;</span>, datetime.strftime(datetime.now(), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)),</span><br><span class="line">        (<span class="string">&#x27;hasMoved&#x27;</span>, param.get(<span class="string">&#x27;hasMoved&#x27;</span>, <span class="string">&#x27;false&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;leaveReason&#x27;</span>, param.get(<span class="string">&#x27;leaveReason&#x27;</span>, <span class="string">&#x27;&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locNation1&#x27;</span>, param.get(<span class="string">&#x27;locNation1&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locProvince1&#x27;</span>, param.get(<span class="string">&#x27;locProvince1&#x27;</span>, <span class="string">&#x27;上海市&#x27;</span>)),</span><br><span class="line">        (<span class="string">&#x27;locCity1&#x27;</span>, param.get(<span class="string">&#x27;locCity1&#x27;</span>, <span class="string">&#x27;上海市&#x27;</span>))</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    res = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> request.urlopen(req, data=payload.encode()) <span class="keyword">as</span> f:</span><br><span class="line">            res = json.loads(f.read()) <span class="keyword">if</span> f.status == <span class="number">200</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&quot;请求失败&quot;</span>, e)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    token = <span class="string">&#x27;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjEyMzQ1Njc4OSwidXNlcl9uYW1lIjoic3dpZDB4eHh4eHh4eDZjNiIsImF1dGhvcml0aWVzIjpbImFwcF91c2VyIl0sImp0aSI6ImVjY3h4eHgteHh4eC14eHh4LTllN2IteHh4eHhkODRmYjgiLCJjbGllbnRfaWQiOiJhcHAiLCJzY29wZSI6WyJhbGwiXX0.xxxxxxxxxxxxxxxxxxxxxxxxr6d8D4&#x27;</span></span><br><span class="line"></span><br><span class="line">    param = {</span><br><span class="line">        <span class="string">&#x27;studentPid&#x27;</span>: <span class="string">&#x27;9999999&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;studentName&#x27;</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;studentStudentno&#x27;</span>: <span class="string">&#x27;1888888&#x27;</span></span><br><span class="line">    }</span><br><span class="line">    res = check(token, param)</span><br><span class="line"></span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>考研201 英语一 大纲</title>
    <url>/kaoyan/201/index.html</url>
    <content><![CDATA[<h2 id="考察"><a href="#考察" class="headerlink" title="考察"></a>考察</h2><p>选拔性考试</p>
<p>听说读写</p>
<p>初始不考听力</p>
<p>复试(面试)考察听力和口语</p>
<h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><ol>
<li><p>完型填空</p>
<p>20个空 10分</p>
</li>
<li><p>阅读理解</p>
<p>4篇文章*5小题 40分</p>
</li>
<li><p>新题型</p>
<p> 七选五/排序题/标题匹配</p>
<p> 10分</p>
</li>
<li><p>翻译</p>
<p> 5句话(长难句) 10分</p>
</li>
<li><p>小作文</p>
<p> 应用文(信/通知/备忘录/报告) 10分</p>
</li>
<li><p>大作文</p>
<p> 20分</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>考研301 数学一 大纲</title>
    <url>/kaoyan/301/index.html</url>
    <content><![CDATA[<h2 id="分值构成-数学一"><a href="#分值构成-数学一" class="headerlink" title="分值构成 (数学一)"></a>分值构成 (数学一)</h2><ol>
<li>高数 90分</li>
<li>线代 30分</li>
<li>概率论 30分</li>
</ol>
<h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><p>一共22道题目</p>
<ol>
<li><p>单选 </p>
<p> 10小题 50分 —— 考基本概念, 性质</p>
</li>
<li><p>填空</p>
<p> 6小题 30分 —— 考运算, 方法</p>
<p> 注重准确率!</p>
</li>
<li><p>解答题(包括证明) </p>
<p> 6大题 70分 —— 综合性</p>
</li>
</ol>
<h2 id="21大纲新增"><a href="#21大纲新增" class="headerlink" title="21大纲新增"></a>21大纲新增</h2><ol>
<li>反常积分比较判别法</li>
<li>无穷级数积分判别法</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>计算机网络复习</title>
    <url>/computer-network/index.html</url>
    <content><![CDATA[<h1 id="按章节"><a href="#按章节" class="headerlink" title="按章节"></a>按章节</h1><h2 id="1-9-OSI七层模型"><a href="#1-9-OSI七层模型" class="headerlink" title="1.9 OSI七层模型"></a>1.9 OSI七层模型</h2><p>设计者: 国际标准化组织ISO, 国际电信联盟ITU</p>
<p>OSI七层模型: 物理层/数据链路层/网络层/传输层/会话层/表示层/应用层</p>
<p>TCP/IP位于: 传输层/网络层</p>
<p>会话层和表示层几乎没有内容</p>
<h2 id="3-4-CS模型"><a href="#3-4-CS模型" class="headerlink" title="3.4 CS模型"></a>3.4 CS模型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>服务端程序S</th>
<th>客户端程序A</th>
</tr>
</thead>
<tbody>
<tr>
<td>先启动</td>
<td>后启动</td>
</tr>
<tr>
<td>不知道C</td>
<td>必须知道S的位置</td>
</tr>
<tr>
<td>积极等待C来连接</td>
<td>需要通讯时初始化连接</td>
</tr>
<tr>
<td>通过收发数据进行通讯</td>
<td>通过收发数据进行通讯</td>
</tr>
<tr>
<td>服务之后继续运行, 等待下一个C来连接</td>
<td>可能结束</td>
</tr>
</tbody>
</table>
</div>
<p>Internet只提供基本通讯, 实际上是由计算机上的程序来处理连接</p>
<h2 id="3-5-C-S程序的特点"><a href="#3-5-C-S程序的特点" class="headerlink" title="3.5 C/S程序的特点"></a>3.5 C/S程序的特点</h2><p>略</p>
<h2 id="3-13-网络编程Socket-API"><a href="#3-13-网络编程Socket-API" class="headerlink" title="3.13 网络编程Socket API"></a>3.13 网络编程Socket API</h2><p>事实标准: Socket API</p>
<h2 id="4-6-URL和超链接"><a href="#4-6-URL和超链接" class="headerlink" title="4.6 URL和超链接"></a>4.6 URL和超链接</h2><h2 id="4-7-HTTP"><a href="#4-7-HTTP" class="headerlink" title="4.7 HTTP"></a>4.7 HTTP</h2><h2 id="4-17-DNS和域名"><a href="#4-17-DNS和域名" class="headerlink" title="4.17 DNS和域名"></a>4.17 DNS和域名</h2><h2 id="4-20-名字解析"><a href="#4-20-名字解析" class="headerlink" title="4.20 名字解析"></a>4.20 名字解析</h2><h2 id="5-5-与数据传输相关的话题"><a href="#5-5-与数据传输相关的话题" class="headerlink" title="5.5 与数据传输相关的话题"></a>5.5 与数据传输相关的话题</h2><ul>
<li>信息源</li>
<li>数据源编码/解码器</li>
<li>加密/解密器</li>
<li>通道编码/解码器</li>
<li>复用/解复用器</li>
<li>调制/解调器</li>
<li>物理信道和传输</li>
</ul>
<h2 id="7-18-低地卫星-LEO-和集群"><a href="#7-18-低地卫星-LEO-和集群" class="headerlink" title="7.18 低地卫星(LEO)和集群"></a>7.18 低地卫星(LEO)和集群</h2><p>LEO卫星群协同工作以转发消息。集群成员必须知道当前在地球给定区域上的卫星，并将消息转发给适当的成员以传输到地面站。</p>
<h2 id="8-6-奇偶校验码"><a href="#8-6-奇偶校验码" class="headerlink" title="8.6 奇偶校验码"></a>8.6 奇偶校验码</h2><p>单奇偶校验（SPC）是信道编码的一种基本形式，其中发送方<strong>在每个字节上添加一个额外的位，以使1的个数为偶数（或奇数）</strong>，接收方验证输入的数据是否具有正确的1位数。</p>
<h2 id="8-12-因特网使用的16位校验和"><a href="#8-12-因特网使用的16位校验和" class="headerlink" title="8.12 因特网使用的16位校验和"></a>8.12 因特网使用的16位校验和</h2><p>源数据M, 任意长度</p>
<ol>
<li>补零, 直至长度是16位的倍数</li>
<li>将M按照16位分组并求和, 最多允许溢出到32位</li>
<li>将结果对半相加(高16位加低16位), 只保留16位</li>
<li>将结果取反</li>
<li>如果是0则再取反</li>
</ol>
<p>取反的目的: 方便验证, 只要求完相加判断是否溢出剩0就行了</p>
<h2 id="8-13-CRC"><a href="#8-13-CRC" class="headerlink" title="8.13 CRC"></a>8.13 CRC</h2><p>例: data=<code>10010101010</code>, G=<code>10101</code><br>多项式表示: $G=x^5+x^3+1$</p>
<ol>
<li><p>补零</p>
<p><code>mdata = data + &#39;0&#39; * (G.length - 1)</code></p>
<p>得到<code>mdata = 100101010100000</code></p>
</li>
<li><p>模2除法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">      ___101100101100_</span><br><span class="line"><span class="number">10101</span>/<span class="number">100101010100000</span></span><br><span class="line">    / <span class="number">10101</span> |   | | |</span><br><span class="line">     =  <span class="number">11110</span>   | | |</span><br><span class="line">        <span class="number">10101</span>   | | |</span><br><span class="line">       = <span class="number">10111</span>  | | |</span><br><span class="line">         <span class="number">10101</span>  | | |</span><br><span class="line">        =   <span class="number">10010</span> | |</span><br><span class="line">            <span class="number">10101</span> | |</span><br><span class="line">           =  <span class="number">11100</span> |</span><br><span class="line">              <span class="number">10101</span> |</span><br><span class="line">             = <span class="number">10010</span>|</span><br><span class="line">               <span class="number">10101</span>|</span><br><span class="line">              =  <span class="number">1110</span></span><br></pre></td></tr></table></figure>
<p>得到CRC=<code>1110</code></p>
</li>
<li><p>拼接</p>
<p>发送的数据<code>send = data + CRC</code></p>
<p><code>send = 1000101010 1110</code></p>
</li>
</ol>
<h2 id="9-12-单工-半双工-全双工传输"><a href="#9-12-单工-半双工-全双工传输" class="headerlink" title="9.12 单工/半双工/全双工传输"></a>9.12 单工/半双工/全双工传输</h2><p>信道的三种类型</p>
<p>单工: 只能单向传输, 单根光纤就是单工, 类比收音机, 电视</p>
<p>全双工: 可以同时双向传输, 有两个光纤就可以组成全双工, 类比电话</p>
<p>半双工: 需要一个共享传输介质, 可以双向传输但是不能同时, 类比对讲机</p>
<h2 id="10-3-模拟调制"><a href="#10-3-模拟调制" class="headerlink" title="10.3 模拟调制"></a>10.3 模拟调制</h2><p>载波: 信息发送出去时以电波的形式, 负责承载信息的波就是载波</p>
<p>调制: 根据要发送的信息, 对载波进行的调整</p>
<pre><code>原始载波(输入1) --\
                (调制器) ---&gt; 调制过的载波(输出)
信息 (输入2)    --/
</code></pre><p>三种主要调制技术: </p>
<ul>
<li>振幅调制</li>
<li>频率调制</li>
<li>移相调制</li>
</ul>
<h2 id="10-12-Modem"><a href="#10-12-Modem" class="headerlink" title="10.12 Modem"></a>10.12 Modem</h2><p>为了方便网络安装, 一般将调制和解调功能集成在一个叫做调制解调器的设备中</p>
<h2 id="12-6-局部环路特性和适应"><a href="#12-6-局部环路特性和适应" class="headerlink" title="12.6 局部环路特性和适应"></a>12.6 局部环路特性和适应</h2><p>接入技术: ISP到用户的连接</p>
<p>本地用户环路(local subscriber line)/本地环路(local loop): 电话公司交换局到用户之间的物理连接, 一般是使用双绞线 (其实就是电话线路?)</p>
<p>DSL: 一种利用local loop提供网络的技术</p>
<p>ADSL: 不对称DSL, 利用频分复用将local loop的带宽分成三个区域</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>频率</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-4</td>
<td>普通老式电话业务</td>
</tr>
<tr>
<td>26-138</td>
<td>上行频带</td>
</tr>
<tr>
<td>138-1100</td>
<td>下行频带</td>
</tr>
</tbody>
</table>
</div>
<p>因为本地环路的电气特性变化各异，ADSL采用了自适应技术，即一对调制解调器先探测彼此之间连接线路上的许多频率，然后选择在此线路上能产生最优传输质量的频率和相应的调制技术。</p>
<h2 id="12-7-ADSL的传输速率"><a href="#12-7-ADSL的传输速率" class="headerlink" title="12.7 ADSL的传输速率"></a>12.7 ADSL的传输速率</h2><p>上行: 32 - 640 Kbps, 去掉控制信道: 32 - 576 Kbps</p>
<p>下行: 32 - 8448 Kbps</p>
<h2 id="12-9-电缆调制解调器技术"><a href="#12-9-电缆调制解调器技术" class="headerlink" title="12.9 电缆调制解调器技术"></a>12.9 电缆调制解调器技术</h2><p>本地环路具有局限性: 双绞线不抗干扰, </p>
<p>因此创造了基于 同轴电缆 + FDM + 统计复用 的电缆调制解调器技术, 每一组用户共享一个数据信道, 通过Modem判断数据是否属于该用户</p>
<p>传输速率: 上行 512 Kbps, 下行 52 Mbps</p>
<h2 id="13-4-本地和广域包交换网络"><a href="#13-4-本地和广域包交换网络" class="headerlink" title="13.4 本地和广域包交换网络"></a>13.4 本地和广域包交换网络</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>距离</th>
</tr>
</thead>
<tbody>
<tr>
<td>LAN</td>
<td>房间/建筑</td>
</tr>
<tr>
<td>MAN</td>
<td>大城市</td>
</tr>
<tr>
<td>WAN</td>
<td>多个城市</td>
</tr>
</tbody>
</table>
</div>
<h2 id="13-9-包识别-解复用-MAC地址"><a href="#13-9-包识别-解复用-MAC地址" class="headerlink" title="13.9 包识别, 解复用, MAC地址"></a>13.9 包识别, 解复用, MAC地址</h2><p>地址: 在包交换系统中, 解复用时使用的标识符, 每个包都包含了目的地地址</p>
<p>IEEE地址(MAC地址): 48位地址, 每个NIC都不一样, 分为前24位OUI, 24位NIC地址</p>
<h2 id="13-10-单播-广播-多播"><a href="#13-10-单播-广播-多播" class="headerlink" title="13.10 单播, 广播, 多播"></a>13.10 单播, 广播, 多播</h2><p>IEEE保留了MAC地址中的一位(最高有效字节的最低位)来区分单播(0)和多播(1)</p>
<p>广播视为一种特殊的多播, 广播地址所有位全1</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>单播</td>
<td>唯一标识一台计算机，并规定只有被标识的那台计算机才能接收分组的副本</td>
</tr>
<tr>
<td>广播</td>
<td>对应所有的计算机，并规定网络上每台计算机都应该接收分组的副本</td>
</tr>
<tr>
<td>组播</td>
<td>标识指定网络上所有计算机的一个子集，并规定该子集中的每台计算机都应该接收分组的副本</td>
</tr>
</tbody>
</table>
</div>
<h2 id="13-11-广播-多播和多点传递"><a href="#13-11-广播-多播和多点传递" class="headerlink" title="13.11 广播, 多播和多点传递"></a>13.11 广播, 多播和多点传递</h2><p>在LAN中, 广播和多播极大地提高了效率</p>
<h2 id="14-6-随机接入协议"><a href="#14-6-随机接入协议" class="headerlink" title="14.6 随机接入协议"></a>14.6 随机接入协议</h2><p>接入技术: 多台相互独立的计算机如何进行协调接入一个<strong>共享介质</strong></p>
<p>MAC层: Media <strong>Access</strong> Control 介质接入控制</p>
<p>方法: 采用复用技术的改进形式, 采用分布式算法</p>
<p>多址接入协议</p>
<ul>
<li>受控接入协议<ul>
<li>预约</li>
<li>轮询</li>
<li>令牌传递</li>
</ul>
</li>
<li>随机接入协议<ul>
<li>ALOHA</li>
<li>CSMA/CD</li>
<li>CSMA/CA</li>
</ul>
</li>
<li>信道分配协议<ul>
<li>FDMA</li>
<li>TDMA</li>
<li>CDMA</li>
</ul>
</li>
</ul>
<p>在LAN中, 用户接入共享介质的时机是随机的, 因此可能造成冲突, 需要用合适的方法解决</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ALOHA</td>
<td>教科书中流行的协议, 但没有实际应用, 划分上行/下行两个频段用来传输信息, 上行采用随机延迟来解决冲突问题, 下行采用广播机制</td>
</tr>
<tr>
<td>CSMA/CD</td>
<td>带冲突检测的载波侦听多址接入, 原始以太网使用, 但交换式以太网不再使用, 使用载波侦听+冲突检测+指数退避算法解决冲突问题</td>
</tr>
<tr>
<td>CSMA/CA</td>
<td>带冲突避免的载波侦听多址接入, 无线LAN使用, 与CSMA/CD类似, 不同在于分组传输前会发送一个控制报文, 接收方广播控制消息</td>
</tr>
</tbody>
</table>
</div>
<p>CSMA/CD: </p>
<ul>
<li>Carrier Sense载波侦听</li>
<li>Multiple Access多址接入</li>
<li>Collision Detect冲突检测</li>
</ul>
<p>CSMA/CA: </p>
<ul>
<li>Carrier Sense载波侦听</li>
<li>Multiple Access多址接入</li>
<li>Collision Avoidance冲突避免</li>
</ul>
<h2 id="15-3-以太网帧格式"><a href="#15-3-以太网帧格式" class="headerlink" title="15.3 以太网帧格式"></a>15.3 以太网帧格式</h2><p>(传统)以太网: 是一种LAN技术, 最早在施乐公司的PARC中发明, 后来被标准化</p>
<p>帧: 数据链路层的协议数据单元</p>
<p>(传统)以太网帧格式:</p>
<p><img src="index/ethernet_frame.png" alt=""></p>
<ul>
<li><p>以太网帧(64-1518) := 头部(14) + 载荷(46-1500) + CRC(4)</p>
</li>
<li><p>头部 := 目的地址(MAC地址, 6) + 源地址(MAC地址, 6) + 类型(2)</p>
</li>
</ul>
<h2 id="15-4-以太网帧的类型域"><a href="#15-4-以太网帧的类型域" class="headerlink" title="15.4 以太网帧的类型域"></a>15.4 以太网帧的类型域</h2><p>以太网帧类型域包含了载荷中的报文类型, 如IPv4/IPv6/ARP等, 接收方检查该值来进行复用与解复用</p>
<h2 id="15-5-802-3以太网"><a href="#15-5-802-3以太网" class="headerlink" title="15.5 802.3以太网"></a>15.5 802.3以太网</h2><p>802.3以太网: IEEE 802.3重新修订后的以太网标准, (但不是很成功)</p>
<p><img src="index/8023_ethernet_frame.png" alt=""></p>
<ul>
<li><p>802.3以太网帧(64-1518) := 头部(14) + <strong>SNAP头部(8)</strong> + 新载荷(46(存疑)-<strong>1492</strong>) + CRC(4)</p>
</li>
<li><p>头部 := 目的地址(MAC地址, 6) + 源地址(MAC地址, 6) + <strong>帧长度(2)</strong></p>
</li>
<li><p><strong>SNAP头部 := LLC(3) + OUI(3) + 类型(2)</strong></p>
</li>
<li><p>兼容性处理: 类型域&lt;=1500是802.3帧, 否则是传统以太网帧 </p>
</li>
</ul>
<h2 id="15-7-粗缆布线的以太网"><a href="#15-7-粗缆布线的以太网" class="headerlink" title="15.7 粗缆布线的以太网"></a>15.7 粗缆布线的以太网</h2><p>粗缆以太网(Thick wire Ethernet)/粗网(Thicknet, 10Base5): 最初版本的以太网布线方案, 因为其使用笨重的同轴电缆+收发器+AUI电缆方式而得名.</p>
<p><img src="index/thicknet.png" alt=""></p>
<h2 id="15-8-细缆布线的以太网"><a href="#15-8-细缆布线的以太网" class="headerlink" title="15.8 细缆布线的以太网"></a>15.8 细缆布线的以太网</h2><p>细缆以太网(Thin wire Ethernet)/细网(Thinnet, 10Base2): 第二代以太网布线方案, 使用细同轴电缆依次串联计算机, 不再需要AUI线, 收发器集成到NIC中, 缺点是容易单点故障 </p>
<p><img src="index/thinnet.png" alt=""></p>
<h2 id="15-9-双绞线布线的以太网"><a href="#15-9-双绞线布线的以太网" class="headerlink" title="15.9 双绞线布线的以太网"></a>15.9 双绞线布线的以太网</h2><p>双绞线以太网(10BaseT): 第三代以太网布线系统, 使用了双绞线取代同轴电缆, 引入中心集线器(hub)</p>
<p><img src="index/twistnet.png" alt=""></p>
<p>集线器是物理层设备, 具有一定的功能, 比如CSMA/CD等, 现在大部分已经被交换机取代</p>
<h2 id="16-2-无线网络的分类"><a href="#16-2-无线网络的分类" class="headerlink" title="16.2 无线网络的分类"></a>16.2 无线网络的分类</h2><p>和有线网络类似: 个域网/局域网/城域网/广域网</p>
<h2 id="16-3-个域网"><a href="#16-3-个域网" class="headerlink" title="16.3 个域网"></a>16.3 个域网</h2><p>蓝牙/红外/ISM无线</p>
<h2 id="16-5-WLAN和Wi-Fi"><a href="#16-5-WLAN和Wi-Fi" class="headerlink" title="16.5 WLAN和Wi-Fi"></a>16.5 WLAN和Wi-Fi</h2><p>WLAN技术的种类很多, 归类于IEEE802.11标准</p>
<p>Wi-Fi联盟: 一群无线设备供应商组成的非营利性组织, 使用802.11标准对无线设备进行测试与认证</p>
<h2 id="16-8-WLAN基础结构"><a href="#16-8-WLAN基础结构" class="headerlink" title="16.8 WLAN基础结构"></a>16.8 WLAN基础结构</h2><p>WLAN的三个构件: 接入点(Access Point, AP, 非正式也称基站), 互联机构(交换机或路由器等), 无线主机(Station)</p>
<p><img src="index/wlan.png" alt=""></p>
<p><img src="index/wlan2.png" alt=""></p>
<p>WLAN的两种类型: Adhoc无接入点结构(很少), Infrastructure有中心接入点</p>
<p>互联设备到AP的有线连接通常使用双绞线以太网</p>
<p>基本服务组(BSS): 在某一个给定AP范围内的计算机集合</p>
<h2 id="16-9-重叠-关联-802-11帧格式"><a href="#16-9-重叠-关联-802-11帧格式" class="headerlink" title="16.9 重叠, 关联, 802.11帧格式"></a>16.9 重叠, 关联, 802.11帧格式</h2><p>重叠: 两个AP太近, 一台STA可以同时触及到两个AP</p>
<p>802.11要求每个主机只能与一个AP相关联(associate), 而且在802.11帧中携带了AP的MAC地址</p>
<ul>
<li>接入点MAC</li>
<li>本机地址</li>
<li>路由器MAC</li>
<li>专用地址</li>
</ul>
<p><img src="index/80211_frame.png" alt=""></p>
<h2 id="16-11-竞争与无竞争接入"><a href="#16-11-竞争与无竞争接入" class="headerlink" title="16.11 竞争与无竞争接入"></a>16.11 竞争与无竞争接入</h2><p>802.11定义了两种接入方法</p>
<ul>
<li>点协调功能PCF</li>
<li>分布式协调功能DCF</li>
</ul>
<p>隐蔽站问题: WLAN中所用的发射机有一个受限的发射范围, 离发射机的距离超过发射范围的接收方将无法收到信号, 因而无法检测载波</p>
<p>802.11使用CSMA/CA协议来解决接入中的隐蔽站问题</p>
<ul>
<li>传输分组前交换一对RTS,CTS控制报文</li>
<li>没有冲突检测, 而是采用确认ACK+超时重传机制</li>
<li>设定SIFS(发ACK前延时)/DIFS(传输前延时)/Slot Time等时间间隔参数</li>
</ul>
<p><img src="index/csma_ca.png" alt=""></p>
<h2 id="16-13-PAN技术与标准"><a href="#16-13-PAN技术与标准" class="headerlink" title="16.13 PAN技术与标准"></a>16.13 PAN技术与标准</h2><ul>
<li>802.15.1a  蓝牙</li>
<li>802.15.3a  UWB 超宽带</li>
<li>802.15.4   Zigbee 工业无线控制标准 </li>
</ul>
<h2 id="17-3-光纤猫扩展"><a href="#17-3-光纤猫扩展" class="headerlink" title="17.3 光纤猫扩展"></a>17.3 光纤猫扩展</h2><p>最简单的LAN扩展机制: 光纤+一对光纤猫, 连接一台计算机和一个远程以太网</p>
<h2 id="17-4-中继器"><a href="#17-4-中继器" class="headerlink" title="17.4 中继器"></a>17.4 中继器</h2><p>中继器: 信号放大, 信号转发, 早期广泛应用</p>
<h2 id="17-5-网桥与桥接"><a href="#17-5-网桥与桥接" class="headerlink" title="17.5 网桥与桥接"></a>17.5 网桥与桥接</h2><p>网桥: 往往用来连接两个LAN网段(比如hub), 保证两边的计算机都能互相连通</p>
<p>计算机无法分辨LAN中有无网桥</p>
<h2 id="17-6-自学习网桥与帧过滤"><a href="#17-6-自学习网桥与帧过滤" class="headerlink" title="17.6 自学习网桥与帧过滤"></a>17.6 自学习网桥与帧过滤</h2><p>网桥与一根网线直连的区别: 网桥分隔冲突域, 但不分隔广播域 <strong>网桥仅在有必要的时候才进行转发</strong></p>
<ul>
<li>源地址和目标地址位于两个网段</li>
<li>广播帧和多播帧</li>
</ul>
<p>网桥能够自动学习设备位于网桥的哪一侧(基于分组中的源MAC地址)</p>
<h2 id="17-7-桥接的好处"><a href="#17-7-桥接的好处" class="headerlink" title="17.7 桥接的好处"></a>17.7 桥接的好处</h2><p>桥接的各个网段可以同时进行传输, 使得不同建筑物之间的通讯成为了可能</p>
<h2 id="17-8-分布式生成树"><a href="#17-8-分布式生成树" class="headerlink" title="17.8 分布式生成树"></a>17.8 分布式生成树</h2><p>如果网桥连接导致网络中存在环路, 那么广播和多播帧会被无限循环转发下去</p>
<p>因此网桥会执行生成树算法来生成一个树</p>
<h2 id="18-7-下一条转发"><a href="#18-7-下一条转发" class="headerlink" title="18.7 下一条转发"></a>18.7 下一条转发</h2><p>分组交换机收到一个分组后, 如果分组的目的地不是直连在交换机上, 就需要查表转发</p>
<p>交换机的转发表: 目的地址:输出接口</p>
<h2 id="18-9-广域网动态路由更新"><a href="#18-9-广域网动态路由更新" class="headerlink" title="18.9 广域网动态路由更新"></a>18.9 广域网动态路由更新</h2><p>转发表的要求</p>
<ul>
<li>全局通信 - 必须覆盖所有可能目的地的</li>
<li>最优路径 - 下一条必须是距目的地的最短路径</li>
</ul>
<p>路由软件: 自动重新配置转发表的软件</p>
<h2 id="18-12-分布式路径计算"><a href="#18-12-分布式路径计算" class="headerlink" title="18.12 分布式路径计算"></a>18.12 分布式路径计算</h2><p>分布式路径计算的两种常用形式:</p>
<ul>
<li>链路状态路由LSR, 采用Dijkstra算法</li>
<li>距离向量路由DVR</li>
</ul>
<p>LSR: 每台交换机定期广播一条边的状态, 相邻交换机据此更新自己的转发表</p>
<p>DVR: 每台交换机定期告诉相邻交换机自己的距离向量表(包含一对(目的,距离)), 相邻交换机据此更新自己的转发表</p>
<h2 id="18-13-最短路径的计算"><a href="#18-13-最短路径的计算" class="headerlink" title="18.13 最短路径的计算"></a>18.13 最短路径的计算</h2><p>Dijkstra算法</p>
<h2 id="20-6-用路由器连接物理网络"><a href="#20-6-用路由器连接物理网络" class="headerlink" title="20.6 用路由器连接物理网络"></a>20.6 用路由器连接物理网络</h2><p>路由器是一台专门完成网络互联任务的专用硬件系统, 可以将多个使用不同技术（包括不同的传输介质、物理编址方案或帧格式）的网络互相连接（互联）起来 (比如连接以太网和WiFi网)</p>
<h2 id="21-7-IP有类编址方案"><a href="#21-7-IP有类编址方案" class="headerlink" title="21.7 IP有类编址方案"></a>21.7 IP有类编址方案</h2><p>IP地址<strong>有类编址方案</strong><br>| 类别    | 标识位 | 前缀长度 | 最大网络数量 | 后缀长度 | 最大主机数量 |<br>| ———- | ——— | ———— | —————— | ———— | —————— |<br>| A       | 0      | 7        | 128          | 24       | 2^24         |<br>| B       | 10     | 14       | 16384        | 16       | 65536        |<br>| C       | 110    | 21       | 2^21         | 8        | 256          |<br>| D(组播) | 1110   | -        | -            | -        | -            |<br>| E(保留) | 1111   | -        | -            | -        | -            |</p>
<h2 id="21-10-IP无类编址方案"><a href="#21-10-IP无类编址方案" class="headerlink" title="21.10 IP无类编址方案"></a>21.10 IP无类编址方案</h2><p>IP地址<strong>无类/子网编址方案</strong>: 引入附加的地址掩码(子网掩码)来指定网络地址和主机地址的分界线</p>
<p>无类地址 &amp; 子网掩码 == 网络地址</p>
<h2 id="21-21-IPv6地址"><a href="#21-21-IPv6地址" class="headerlink" title="21.21 IPv6地址"></a>21.21 IPv6地址</h2><p>和IPv4类似, IPv6为每个接入网络的计算机分配了一个独一无二的地址</p>
<p>IPv6的特点</p>
<ul>
<li><p>将<code>网络地址</code>进一步细分为<code>全球单播地址</code>和<code>子网地址</code>两部分, <code>主机地址</code>仍保留, 两者共128位, 用<code>/xx</code>来表示<code>网络地址</code>的长度, 如不指定默认是64位</p>
<p><img src="index/ipv6.png" alt=""></p>
</li>
<li><p>取消<code>广播</code>, 支持<code>多播</code>, 增加<code>任播</code>(anycast)</p>
<p><img src="index/ipv6_special.png" alt=""></p>
</li>
</ul>
<h2 id="22-4-IP数据报"><a href="#22-4-IP数据报" class="headerlink" title="22.4 IP数据报"></a>22.4 IP数据报</h2><p>IP数据报(-65535) := 头部 + 数据区(载荷区)</p>
<h2 id="22-5-IP数据报头部格式"><a href="#22-5-IP数据报头部格式" class="headerlink" title="22.5 IP数据报头部格式"></a>22.5 IP数据报头部格式</h2><p><img src="index/ip_datagram.png" alt=""></p>
<h2 id="22-7-网络前缀提取与数据报转发"><a href="#22-7-网络前缀提取与数据报转发" class="headerlink" title="22.7 网络前缀提取与数据报转发"></a>22.7 网络前缀提取与数据报转发</h2><p>根据网络地址查询转发表发给下一站</p>
<h2 id="22-8-最长前缀匹配"><a href="#22-8-最长前缀匹配" class="headerlink" title="22.8 最长前缀匹配"></a>22.8 最长前缀匹配</h2><p>查询转发表时如果有多项匹配, 采用<strong>最长前缀匹配</strong>规则</p>
<h2 id="22-11-IP封装"><a href="#22-11-IP封装" class="headerlink" title="22.11 IP封装"></a>22.11 IP封装</h2><p>IP数据报要被封装到一个帧里才能发送出去, 帧的目的地址是下一站的IP地址对应的MAC地址(通过ARP协议获得)</p>
<h2 id="22-14-IP分片和重装机制"><a href="#22-14-IP分片和重装机制" class="headerlink" title="22.14 IP分片和重装机制"></a>22.14 IP分片和重装机制</h2><h2 id="22-15-分片数据报的收集"><a href="#22-15-分片数据报的收集" class="headerlink" title="22.15 分片数据报的收集"></a>22.15 分片数据报的收集</h2><p>最大传输单元MTU: 每种物理网络规定的一帧能够携带的最大数据量</p>
<p>IP数据报分片机制: 当一个数据报长度大于前方网络的MTU时, 路由器会将数据报分成若干较小的片(fragment), 然后将每一片独立地封装发送出去</p>
<p>分片: 每个片与数据报的格式一样, 头部部分参数不同</p>
<ul>
<li>标识: 每个数据报的唯一标识, 同一个原始数据报的所有片段的标识是一样的</li>
<li>标志: 标识了该数据报是片还是完整的数据报, 以及是否是最后一片</li>
<li>片偏移: 该片在原数据报中的位置</li>
</ul>
<p>重装: 在所有片的基础上重新产生原数据报的过程, <strong>IP规定只有最终目的主机才能对片进行重装</strong></p>
<h2 id="23-9-ICMP报文格式与封装"><a href="#23-9-ICMP报文格式与封装" class="headerlink" title="23.9 ICMP报文格式与封装"></a>23.9 ICMP报文格式与封装</h2><p>因特网控制报文协议(ICMP): 利用IP来传输IP传输中发生的错误</p>
<p>ICMP报文放置在IP数据报的数据区传输</p>
<h2 id="23-10-协议软件-参数和配置"><a href="#23-10-协议软件-参数和配置" class="headerlink" title="23.10 协议软件, 参数和配置"></a>23.10 协议软件, 参数和配置</h2><p>协议软件采用参数化设计</p>
<p>主机配置采用自举过程, 运行时获取到IP地址, 掩码, DNS服务器地址等参数填入程序中运行</p>
<h2 id="24-3-UDP"><a href="#24-3-UDP" class="headerlink" title="24.3 UDP"></a>24.3 UDP</h2><p>UDP的特征: </p>
<ul>
<li>端到端: UDP是一个传输协议, 它能区分运行在给定计算机上的多个应用程序</li>
<li>无连接: UDP提供给应用的接口遵从无连接模式</li>
<li>面向报文: 使用UDP的应用进程所发送和接收的数据是单个报文</li>
<li>尽力而为: UDP提供给应用的是与IP一样的尽力传递机制</li>
<li>任意交互: UDP允许应用进程给很多其他应用进程发送数据, 也允许从很多其他应用进程那里接收数据, 或者只跟一个其他应用进程相互通信</li>
<li>操作系统无关: UDP所提供的标识应用程序的方法, 不取决于本地操作系统所使用的标识符</li>
</ul>
<p><img src="index/udp_segment.png" alt=""></p>
<h2 id="24-4-无连接的通信模式"><a href="#24-4-无连接的通信模式" class="headerlink" title="24.4 无连接的通信模式"></a>24.4 无连接的通信模式</h2><p>UDP采用无连接通信模式, 可以在任何时候发送数据, 不需要维护通信状态, 也不使用控制报文, 因此传输开销极低</p>
<h2 id="24-7-交互模式和广播传递"><a href="#24-7-交互模式和广播传递" class="headerlink" title="24.7 交互模式和广播传递"></a>24.7 交互模式和广播传递</h2><p>UDP支持四种交互通信方式:</p>
<ul>
<li>一对一</li>
<li>一对多</li>
<li>多对一</li>
<li>多对多</li>
</ul>
<p>底层是利用IP组播和广播机制实现的</p>
<h2 id="24-8-用协议端口号标识端点"><a href="#24-8-用协议端口号标识端点" class="headerlink" title="24.8 用协议端口号标识端点"></a>24.8 用协议端口号标识端点</h2><p>协议端口号: 用来标识应用程序的<strong>标识符抽象集</strong>, 独立于底层操作系统</p>
<h2 id="25-3-TCP"><a href="#25-3-TCP" class="headerlink" title="25.3 TCP"></a>25.3 TCP</h2><p>TCP提供的服务有7个主要特点:</p>
<ul>
<li>面向连接: TCP提供面向连接的服务, 应用程序必须首先请求建立一个到目的地的连接, 然后使用这个连接来传输数据 </li>
<li>点对点通信: 每个TCP连接上只有两个端点 </li>
<li>完全的可靠性: TCP能保证在一个连接上发送的数据被正确地传递, 且保证数据的完整和按序到达 </li>
<li>全双工通信: TCP连接允许数据在任何一个方向上流动, 并允许任何应用程序在任何时刻发送数据 </li>
<li>流接口: TCP提供一个流接口, 利用它应用进程可以在一个连接上发送连续的字节流. TCP不必将数据组合成记录或是报文, 也不要求传递给接收应用进程的数据段大小一定要与发送端所送出的数据段大小相同 </li>
<li>可靠的连接建立: TCP允许两个应用进程可靠地开始通信 </li>
<li>友好的连接关闭: 在关闭一个连接之前, TCP必须保证所有数据已经传递完毕, 并且通信双方都要同意关闭这个连接 </li>
</ul>
<p><img src="index/tcp_segment.png" alt=""></p>
<h2 id="25-4-端对端服务与虚拟连接"><a href="#25-4-端对端服务与虚拟连接" class="headerlink" title="25.4 端对端服务与虚拟连接"></a>25.4 端对端服务与虚拟连接</h2><p>TCP和UDP都是<strong>端到端协议</strong>: 提供在一台计算机上的应用进程与另一台计算机上的应用进程之间的通信能力</p>
<p>TCP是<strong>面向连接</strong>的协议, TCP提供的连接是一种虚拟连接, 因为它是软件实现的连接</p>
<p>TCP将底层因特网视为一个通信系统</p>
<h2 id="25-5-一般可靠传输协议所采用的技术"><a href="#25-5-一般可靠传输协议所采用的技术" class="headerlink" title="25.5 一般可靠传输协议所采用的技术"></a>25.5 一般可靠传输协议所采用的技术</h2><ul>
<li><p>分组乱序</p>
<ul>
<li>排序技术: 每个分组都附加一个序号</li>
</ul>
</li>
<li><p>分组丢失</p>
<ul>
<li>带重传的正向确认: 接收方发送ACK报文表示成功接收; 若超时仍未收到ACK, 则重传</li>
</ul>
</li>
<li><p>分组重复(重放错误)</p>
<ul>
<li>每一次会话用一个唯一的ID标识</li>
</ul>
</li>
<li><p>数据过载</p>
<ul>
<li>停-走系统: 不好, 效率很低</li>
<li>滑动窗口: 定义<strong>窗口大小</strong>为接收方一次可以承载的最大数据量/发送方收到ACK前可以发送的最大数据量, 发送方收到ACK之后窗口向后移动</li>
</ul>
</li>
</ul>
<h2 id="25-11-缓冲-流控制-窗口"><a href="#25-11-缓冲-流控制-窗口" class="headerlink" title="25.11 缓冲, 流控制, 窗口"></a>25.11 缓冲, 流控制, 窗口</h2><p>TCP使用了以字节计量的窗口, 接收方将自己剩余的缓冲区大小放在ACK报文中, 发送方根据这个窗口大小来决定是继续发送还是停止</p>
<h2 id="26-4-动态路由和路由器"><a href="#26-4-动态路由和路由器" class="headerlink" title="26.4 动态路由和路由器"></a>26.4 动态路由和路由器</h2><p>每个路由器都运行路由软件，该软件了解其他路由器可以到达的目的地，并向其他路由器通知其可以到达的目的地。路由软件使用传入的信息来连续更新本地转发表。</p>
<h2 id="26-7-两类因特网路由协议"><a href="#26-7-两类因特网路由协议" class="headerlink" title="26.7 两类因特网路由协议"></a>26.7 两类因特网路由协议</h2><p>因特网路由协议的分类:</p>
<ul>
<li>内部网关协议IGP: 自治系统内部使用的协议, 可以自由选择, 例如RIP, OSPF, is-is等</li>
<li>外部网关协议EGP: 自治系统之间使用的协议, 例如BGP</li>
</ul>
<p>路由度量指标: 评价路由路径好坏的指标</p>
<ul>
<li><p>尽管大多数Internet路由协议都设计为使用跃点作为路由指标，网络管理员也可以覆盖该指标以实施策略。</p>
</li>
<li><p>在自治系统中，IGP软件使用路由度量来选择到达每个目的地的最佳路径。 EGP软件可以找到到达每个目的地的路径，但是找不到最佳路径，因为它无法比较来自多个自治系统的路由度量。</p>
</li>
</ul>
<h2 id="26-12-OSPF协议"><a href="#26-12-OSPF协议" class="headerlink" title="26.12 OSPF协议"></a>26.12 OSPF协议</h2><p>RIP是内部网关协议, 使用<strong>距离矢量算法</strong>来传递路由信息。RIP 是在 UDP 协议之上的一种路由协议，应用于 OSI 网络七层模型的<strong>网络层</strong>。</p>
<p>OSPF是内部网关协议，它使用<strong>链路状态算法</strong>来传播路由信息。路由器使用<strong>Dijkstra算法</strong>计算最短路径。</p>
<h2 id="26-16-组播路由技术"><a href="#26-16-组播路由技术" class="headerlink" title="26.16 组播路由技术"></a>26.16 组播路由技术</h2><p>IP组播群组的成员关系构成是动态的，即计算机可以随时加入或离开一个群组。群组成员关系只是定义了一组接收者；任意一个应用进程（即使它不是一个群组成员）都能发送数据报给组播群组。</p>
<p>因特网组播的动态特性使它的组播路径传播问题变得很困难。虽然已经提出了很多协议，但是目前因特网还没有全网范围内的组播路由设施。</p>
<h2 id="29-9-私有密钥-对称-加密"><a href="#29-9-私有密钥-对称-加密" class="headerlink" title="29.9 私有密钥(对称)加密"></a>29.9 私有密钥(对称)加密</h2><h2 id="29-10-公开密钥-非对称-加密"><a href="#29-10-公开密钥-非对称-加密" class="headerlink" title="29.10 公开密钥(非对称)加密"></a>29.10 公开密钥(非对称)加密</h2><h2 id="29-11-使用数字签名的鉴别"><a href="#29-11-使用数字签名的鉴别" class="headerlink" title="29.11 使用数字签名的鉴别"></a>29.11 使用数字签名的鉴别</h2><p>签名: 发送方使用自己的私钥对报文进行加密</p>
<p>验证: 接收方使用发送方的公钥进行解密</p>
<p>认证+加密: 发送者先对报文进行签名, 再用接收者的公钥进行加密</p>
<h2 id="29-13-防火墙"><a href="#29-13-防火墙" class="headerlink" title="29.13 防火墙"></a>29.13 防火墙</h2><p>防火墙: 防止因特网上的问题扩散到本地内部的计算机上的技术, 一般放置在本单位的网络与外部因特网之间</p>
<h2 id="29-14-包过滤防火墙的实现"><a href="#29-14-包过滤防火墙的实现" class="headerlink" title="29.14 包过滤防火墙的实现"></a>29.14 包过滤防火墙的实现</h2><p>防火墙利用包过滤技术来防止不希望有的通信交互。每种过滤器规则都要给出数据包头部参数的组合，包括IP源地址、目的地址、协议端口号和传输协议类型等。</p>
<h2 id="30-7-SNMP"><a href="#30-7-SNMP" class="headerlink" title="30.7 SNMP"></a>30.7 SNMP</h2><p>简单网络管理协议SNMP: 基于IP的网络管理的标准协议</p>
<h1 id="按作业内容"><a href="#按作业内容" class="headerlink" title="按作业内容"></a>按作业内容</h1><h2 id="TCP-IP的分层模型"><a href="#TCP-IP的分层模型" class="headerlink" title="TCP/IP的分层模型"></a>TCP/IP的分层模型</h2><p>物理层/网络接口层/网络层/传输层/应用层</p>
<h2 id="导线类型"><a href="#导线类型" class="headerlink" title="导线类型"></a>导线类型</h2><ul>
<li>无屏蔽双绞线(UTP)</li>
<li>屏蔽双绞线(STP)</li>
<li>同轴电缆(CC)</li>
</ul>
<h2 id="通信卫星类型"><a href="#通信卫星类型" class="headerlink" title="通信卫星类型"></a>通信卫星类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>低地球轨道(LEO)</td>
<td>低时延</td>
<td>相对地球移动</td>
</tr>
<tr>
<td>中地球轨道(MEO)</td>
<td>主要提供南北级通信</td>
<td>-</td>
</tr>
<tr>
<td>地球静止轨道(GEO)</td>
<td>相对地球静止</td>
<td>距离远</td>
</tr>
</tbody>
</table>
</div>
<h2 id="为什么要区分上下行通信"><a href="#为什么要区分上下行通信" class="headerlink" title="为什么要区分上下行通信"></a>为什么要区分上下行通信</h2><p>大多数因特网用户都是按非对称（asymmetric）模式使用网络的，即典型的居民用户从因特网接收的数据要多于他们发送出去的数据。例如，为了浏览一个网页，浏览器发送一个只包含几个字节的 URL，而 Web 服务器响应回来的内容可能是包含几千字节的文本或者是一个包含好几万字节的图片。运行 Web 服务器的商业用户可能具有相反的流量模式——商业用户发送的数据要多于接收的数据。</p>
<h2 id="宽带与窄带"><a href="#宽带与窄带" class="headerlink" title="宽带与窄带"></a>宽带与窄带</h2><p>窄带接入技术:</p>
<ul>
<li>拨号电话连接</li>
<li>使用调制解调器的租用电路</li>
<li>部分 T1 数据电路</li>
<li>ISDN 及其他电信数据服务</li>
</ul>
<p>宽带接入技术:</p>
<ul>
<li>DSL 技术</li>
<li>电缆调制解调器技术</li>
<li>无线接入技术</li>
<li>T1 速率或更高速率的数据线路</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="背背背"><a href="#背背背" class="headerlink" title="背背背"></a>背背背</h1><h2 id="TCP的特征"><a href="#TCP的特征" class="headerlink" title="TCP的特征"></a>TCP的特征</h2><ul>
<li>面向连接: TCP提供面向连接的服务, 应用程序必须首先请求建立一个到目的地的连接, 然后使用这个连接来传输数据 </li>
<li>点对点通信: 每个TCP连接上只有两个端点 </li>
<li>完全的可靠性: TCP能保证在一个连接上发送的数据被正确地传递, 且保证数据的完整和按序到达 </li>
<li>全双工通信: TCP连接允许数据在任何一个方向上流动, 并允许任何应用程序在任何时刻发送数据 </li>
<li>流接口: TCP提供一个流接口, 利用它应用进程可以在一个连接上发送连续的字节流. TCP不必将数据组合成记录或是报文, 也不要求传递给接收应用进程的数据段大小一定要与发送端所送出的数据段大小相同 </li>
<li>可靠的连接建立: TCP允许两个应用进程可靠地开始通信 </li>
<li>友好的连接关闭: 在关闭一个连接之前, TCP必须保证所有数据已经传递完毕, 并且通信双方都要同意关闭这个连接 </li>
</ul>
<h2 id="UDP的特征"><a href="#UDP的特征" class="headerlink" title="UDP的特征"></a>UDP的特征</h2><ul>
<li>端到端: UDP 是一个传输协议，它能区分运行在给定计算机上的多个应用程序。</li>
<li>无连接: UDP 提供给应用的接口遵从无连接模式。</li>
<li>面向报文: 使用 UDP 的应用进程所发送和接收的数据是单个报文。</li>
<li>尽力而为: UDP 提供给应用的是与 IP 一样的尽力传递机制。</li>
<li>任意交互: UDP 允许应用进程给很多其他应用进程发送数据，也允许从很多其他应用进程那里接收数据，或者只跟一个其他应用进程相互通信。</li>
</ul>
<h2 id="服务端-客户端特征"><a href="#服务端-客户端特征" class="headerlink" title="服务端-客户端特征"></a>服务端-客户端特征</h2><p>虽然存在少量的变种，但大多数客户——服务器交互模式都具有相同的一般特征。一般情况<br>下，客户软件具有如下特征：</p>
<ol>
<li>它是一个任意的应用程序，仅在需要进行远程访问时才暂时成为客户，同时还要完成其他的计算任务。</li>
<li>直接受用户介入操作，并且只执行一个会话过程。</li>
<li>在用户的个人计算机上进行本地运行。</li>
<li>主动地发起与服务器的连接请求。</li>
<li>能访问所需的多种服务，但通常一次只与一个远地服务器请求连接。</li>
<li>不会特别地要求功能强大的计算机硬件。</li>
</ol>
<p>而服务器软件的特征如下：</p>
<ol>
<li>它是一个专门提供某种服务的专用特权程序，但同时可以处理多个远程客户的请求。</li>
<li>在系统启动时自动被调入执行，进行多次会话并持续不断地运行。</li>
<li>运行在大型、高性能计算机上。</li>
<li>被动地等待来自任意的远端客户的通信请求。</li>
<li>接收来自任何客户的通信请求，但只提供单一的服务。</li>
<li>要求功能强大的硬件和高级复杂的操作系统支持。</li>
</ol>
<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>FTP: 20/数据流, 21/控制流<br>TELNET: 23<br>SMTP: 25<br>DNS: 53<br>SNMP: 161/162</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/eda/An%20introduction%20to%20the%20logical%20simulation.html</url>
    <content><![CDATA[<p>An introduction</p>
<p>主讲：陈昕老师<br>电子与信息工程学院</p>
<p><strong>Introduction</strong></p>
<ul>
<li><p>Computer aids are not limited to chip design. There has been increasing emphasis on the need for system design rather than purely chip design.</p>
</li>
<li><p>One of the problems with building hardware is that, once built, it is not easily change. It is estimated that the relative cost of finding faults at design time, chip-test time, printed circuit board construction time, or in the finished machine in the field is 1:10:100:1000 (Sec. 3.1.1). </p>
</li>
<li><p>Simulation is the process by which a model of the hardware is set up in software, or better still, in data structures that are ‘run’ by the software.</p>
</li>
<li><p>The simulation can then be used to test the ‘hardware’ before it is ever built. When errors are found the data can be changed and further runs made until a correct design is achieved.</p>
</li>
<li><p>If budget and time to market considerations allow, it is possible to try out alternative designs –sometimes called ‘playing “what if” games’.</p>
</li>
</ul>
<p>Cont.</p>
<ul>
<li>Three important tutorials:</li>
</ul>
<p>1) A computer aided design systems is what it says it is –an aid.<br>Q: Is a computer aided design system a substitute for the intelligence of the designer?<br>2) It is not meaningful for a simulation run without error reports. The design time is reduced, but redesign will be necessary.<br>Q: How must a simulator be used?<br>3) Simulation does not generally reduce design time. It frequently increase it, possibly by several hundred percent.<br>Q: What is the advantage gained for this very expensive process?  </p>
<p>Four aims of simulation</p>
<ol>
<li>Functional correctness（功能正确性）<br>A simulator is required to give an accurate prediction of the behavior of a good system.<br>A simulator is required to give warning of a faulty system.</li>
</ol>
<ul>
<li>In order that functional correctness can be checked, two matters must be considered.</li>
</ul>
<p>a)The correct operation must be known.This requires a specification of the function which is unambiguous, and which is clearly understood by both customer and designer. </p>
<p>b)The functionality of the system under unusual conditions of operation may be important. This can include what happens if one or more faults appear or if input data patterns are incorrectly generated.</p>
<ul>
<li>Consider the logic shown in Fig. 1.1, where the square boxes are pieces of combinational logic. </li>
</ul>
<p>Fig. 1.1 Demonstration circuit</p>
<ul>
<li>The waveforms of Fig. 1.2 show the result of a check for functional correctness. </li>
</ul>
<p>Fig. 1.2 Notional waveforms for Fig. 1.1</p>
<p>Cont.</p>
<ol>
<li>Speed of the system（对输入信号的响应时间）<br>Most systems will have some form of limit on the time they take to respond to given conditions. For example, designs using logic with basic gate speeds of 10ns will quite easily build up delays of 500 ns without the designer’s noticing.<br>Speed of operation depends on three criteria.<br>1)The circuit type</li>
</ol>
<p>2)How heavily the circuits are loaded and their driving capability</p>
<p>3)The time that signals take to pass down the wires, which can be significant</p>
<p>Cont.</p>
<ul>
<li><p>For example, a simple TTL gate has basic delay of 8.5 ns, delay per unit load(one similar gate) of 0.25 ns. Then, it is specified to have a delay of 11ns with load of 10 similar gates.</p>
</li>
<li><p>Wiring delays may or may not be serious. Within a single PCB of 300 mm x 300 mm, the time from corner to corner diagonally using strictly x-y tracks will be about 3 ns. </p>
</li>
<li><p>If the logic is TTL with gate delays as above, this could matter for the longest connections, but not in general.</p>
</li>
<li><p>For faster ECL logic with delays of around 1 ns per gate  it is very serious.</p>
</li>
</ul>
<ul>
<li><p>The wiring delay is also important on chips with polysilicon connections. The polysilicon is very resistive –say 50Ωper square. </p>
</li>
<li><p>A track 2 μm wide and 1 mm long is 500 squares long, and hence has a resistance of 25 kΩ.</p>
</li>
<li><p>The capacitance is likely to be of the order of  0.15 fFper μm2, giving a capacitance for the 1 mm by 2μm line of 0.3 pF.</p>
</li>
<li><p>The delay of a wire is of the order of one or two time constants. In this case, the  time constant is 7.5 ns, which is very significant. </p>
</li>
</ul>
<p>Cont.</p>
<ul>
<li><p>Wire delays are unknown until a late stage  in the design process. In the early stages a guess figure may be used. </p>
</li>
<li><p>For later stages it is necessary to have software capable of extracting  wire  characteristics from the layoutand feeding them to  the data used  by the simulator.</p>
</li>
<li><p>The simulator is then run with these additional delays to check that the speed specification can be met.</p>
</li>
<li><p>The feedback of layout data to the simulator is one example of what is known as back annotation.</p>
</li>
</ul>
<p>Cont.</p>
<ol>
<li>Hazard detection<br>Fig. 1.1 shows Z being used as the clock input of a flip-flop. The function（功能）suggests that the pulse shown in Fig. 1.3 should not be there.  However, it is, and will probably cause the flip-flop to trigger incorrectly. This is an example of a raceor hazard. </li>
</ol>
<p>Fig. 1.3 Waveforms for Fig. 1.1 –actual timing</p>
<p>Cont.</p>
<ul>
<li><p>Other timing constraints include</p>
</li>
<li><p>Data to a flip-flop  does not change  just before the clock (set-up time)</p>
</li>
<li><p>Data to a flip-flop does not change just after the clock (hold time)</p>
</li>
<li><p>Timing to dynamic memories meets the chip specifications under conditions of tolerance (RAS, CAS, R/W etc.).</p>
</li>
</ul>
<ul>
<li>It is important that the timing specifications should not be violated during normal operation of the equipment, and so the simulator should be able to detect and report if any violations occur.</li>
</ul>
<p>Cont.</p>
<ol>
<li>Expected outputs for test and fault simulation<br>Once the system can be shown its according to the specification, it will be necessary to develop a test program. It will give an output that is different from the good system for as many faults as possible. This will be run on a machine to test the production hardware.<br>To discover which faults are being tested a fault simulation is run. </li>
</ol>
<ul>
<li><p>In this situation, a fault is introduced into the good network and a simulation run. </p>
</li>
<li><p>The outputs are compared with the output of the good system.</p>
</li>
<li><p>The procedure is repeated for every possible fault.</p>
</li>
</ul>
<p>Another purpose of simulationwill be to determine the outputs of the good circuit for each new test.<br>Q: Whether the system is presumed to be functionally correct or not when simulations are run for test and fault simulation ?</p>
<p>Components of a simulator</p>
<ul>
<li><p>The process of simulation requires three sets of data and a program</p>
</li>
<li><p>A description of the system to be simulated</p>
</li>
<li><p>A description of the inputs to the simulated system</p>
</li>
<li><p>A set of models  of the components  of the system being simulated</p>
</li>
<li><p>A mechanism(the simulator) to process these three in a manner which simulates the system being designed.</p>
</li>
</ul>
<ul>
<li><p>To follow simulation properly, there is also a need for</p>
</li>
<li><p>Assistance to find and follow indications of errors to their sources</p>
</li>
</ul>
<ul>
<li><p>During test generation, the design is regarded as functionally correct. Hence the expected outputs for the test fixture to check against can be derived by simulation. </p>
</li>
<li><p>A model of a component is a representation of its behavior in a form which the simulator can use.</p>
</li>
<li><p>The models of the components used by the simulated system may be built into the simulator in some way.</p>
</li>
<li><p>However, the simulator is much more flexible if the models are held separately in a library available to the simulator. In this way, new components can be added with relative ease and without having to recompile the simulator itself.</p>
</li>
<li><p>The number of possible components which a simulator may at some time wish to use will run into the thousands. If only subset of models is actually needed by a particular network, it is better put it in the computer memory at run time. This may be only 10 to 20 models, possible less. </p>
</li>
</ul>
<p>Levels of simulation</p>
<ol>
<li>System design</li>
</ol>
<ul>
<li>As a rule, a customer will present the design engineer with a specification of the system. The engineer will first divide this  into functional blocks –memory, CPU, control, etc. as shown in Fig. 1.4. Each of these major blocks can then be specified clearly and passed to different people for more detailed work. Eventually, the individual circuits such as 4-bit arithmetic logic units (ALUs) are designed. This is described as atop-down procedure.</li>
</ul>
<p>Fig. 1.4 A computer architecture</p>
<p>Cont.</p>
<ul>
<li><p>However, it may well be apparent at an early stage that certain circuits or small blocks of logic(e.g. the 4-bit ALU) will be required. It is possible to do detailed work on these before their specific place in the system is fully defined. This is bottom-up design. </p>
</li>
<li><p>In order to clarify the interface specification of the major blocks of the system, it is necessary to simulate these blocks without knowing their detailed internal structure . For example, a multiplier might be simulated with a statement such as</p>
</li>
</ul>
<p>a: = x * y;<br>inPASCAL.HDLs,suchasVHDL,makesuseofthemultiplierofthecomputerratherthansomesimulationdescription.<br>Caution:</p>
<ul>
<li><p>A particular case occurs if the machine works with signed numbersand the new design with unsigned numbers.</p>
</li>
<li><p>Theeffectsofspecialoperands.Forexample,(-215)<em>(-216)isnotrepresentableona32-bitmachinebut(-215)</em>216isforatruecomplementnumberdesign.</p>
</li>
</ul>
<p>Cont.</p>
<ul>
<li>As the design progresses, there are two options here.</li>
</ul>
<p>I.The system has to be described separately at each level of the deign, and these levels must be proved to be equivalent.</p>
<p>II.The design may not progress through the levels evenly, so there is a requirement to be able to simulate some blocks with high level statements and some at gate level.</p>
<ul>
<li>The solution is to design a simulator which can handle all levels of design. Then, it should be able to</li>
</ul>
<p>I.Check a low level block against a high level one;</p>
<p>II.Run multilevel simulations  to</p>
<h1 id="enable-simulations-to-run-faster-since-only-a-few-blocks-are-simulated-in-detail"><a href="#enable-simulations-to-run-faster-since-only-a-few-blocks-are-simulated-in-detail" class="headerlink" title="enable simulations to run faster, since only a few blocks are simulated in detail;"></a>enable simulations to run faster, since only a few blocks are simulated in detail;</h1><h1 id="enable-larger-systems-to-be-simulated-since-high-level-blocks-generally-requires-less-resources"><a href="#enable-larger-systems-to-be-simulated-since-high-level-blocks-generally-requires-less-resources" class="headerlink" title="enable larger systems to be simulated, since high level blocks generally requires less resources."></a>enable larger systems to be simulated, since high level blocks generally requires less resources.</h1><p>Cont.</p>
<ul>
<li>Benkoski(1987) gives an example of a 4-bit adder.</li>
</ul>
<p>component level(Spice)</p>
<p> Four 1-bit adders</p>
<p> Single4-bit adder</p>
<p>293 (s)</p>
<p> 0.5 (s)</p>
<p> 0.1 (ms)</p>
<p>Table 1.1 Simulation time with different description level</p>
<p>Cont.</p>
<ol>
<li>High level<br>This is the level of description equivalent to the high level language procedure in programming.<br>The words ‘functional’ and ‘behavioral’ are frequently used in this area. Refer to Fig. 1.4 as an example. We will follow Abramoviciet al. (1990) using the following definition:<br>Functionaldescribes the logic function only and no timing.<br>Behavioraldescribe logic andtiming.<br>3.Gatelevel<br>Thislevelofdescriptionusesmodelsof‘simple’gates.Thelogicalelementsmayincludemultiplexersandflip-flops,thoughbothmaybedescribedinthedatabooksintermsofANDsand/orORs.<br>Fig.1.5showsonepossibleformofa1-bitALU.SpecialmodelsnotconstructedofANDsandORsshouldalwaysbeconsideredinthesecases.</li>
</ol>
<p>Fig. 1.5 One bit of an ALU. </p>
<p>Cont.</p>
<ol>
<li>Circuit level</li>
</ol>
<ul>
<li><p>The circuit is described in terms of resistances, capacitances and voltage and current sources which are the models. A set of mathematical equations relating current and voltage is set up and solved by numerical techniques. Compared with gate and higher levels of simulation, circuit level simulation is essentially different from others.</p>
</li>
<li><p>Circuit simulators typically can handle only a few hundred circuit components and nodes, since they require large in-store data structures and large amounts of computing resource. Usually they are used to characterize relatively small blocks(e.g. gates) which are then re-described for the higher level simulators.</p>
</li>
<li><p>Circuit simulators give analog results. That is the transient response with real rise and fall times, and oscillations where relevant. Other simulators are for digital circuits only. Circuit simulators can also give frequency domain results –that is the zero frequency working point, and frequency responses.  </p>
</li>
</ul>
<p>Cont.</p>
<ol>
<li>Switch level</li>
</ol>
<ul>
<li><p>Between circuit and gate level, there are a number of modelling methodswith the trade off between speed and accuracy at different points. The primary technique is to regard the transistors as switches that are either open or closed. These techniques are known as switch level (Bryant 1984).</p>
</li>
<li><p>At its simplest, no timing is involved. The circuit is divided into sections starting from a gate output and proceeding to the following inputs.</p>
</li>
</ul>
<p>Fig. 1.6 Section of circuit for switch level simulation</p>
<p>Cont.</p>
<ul>
<li><p>Timing may be included in switch level simulation. One form of this is to estimate the capacitance of each wire, the driving gate output and the driven gate input, together with the source resistance of the driving gate(s).</p>
</li>
<li><p>They can handle only the transient performance of digital circuits. They cannot give frequency responses of true analog circuits such as amplifiers.</p>
</li>
</ul>
<ol>
<li>Mixed mode</li>
</ol>
<ul>
<li>Some effort has been made to link circuit simulation and digital simulation.There are at least three ways that has been attempted. </li>
</ul>
<p>1) Write a link between a circuit simulator and a digital simulator. Suitable pseudo-analog to digital converters are used. The digital sections also feed the analog part via appropriate conversions. Since the time scales are not really compatible, the whole thing seems unsatisfactory.</p>
<p>Cont.</p>
<p>2) A circuit analysis system based on events has been developed (Sakallah1985).In this system, an estimate is made of the largest time step that can be made without the signals changing by too large an amount. The analog circuit operates in relatively small partitions to keep the solution simpler(compared with the switch level system). This can be made to work with feedback, and the analog and digital simulations use the same base mechanism.<br>3) ‘Behavioral analog’ (Visweswariahet al. 1988). In this model of the system, the analog blocks are simulated by a circuit simulator, and a model are developed describing the block in terms understandable by the digital simulator. The block can then be treated as a ‘digital’ component by the digital simulator. Actually, writing the analog blocks’ ‘digital’ model is very difficult.</p>
<p>Cont.</p>
<ul>
<li>What is a good simulator?</li>
</ul>
<p>One performshierarchical and mixed level simulation of digital logic, together with timing error detection, independent of technology, but recognizing the distinct features of known technologies. </p>
<p>Models</p>
<ul>
<li><p>Simulation is about building and exercising a model of a system(electrical or otherwise) that is being designed.</p>
</li>
<li><p>Writing accurate models of components is a difficult and skilled activity(Chap. 7). Consider an example of a D-type flip-flop(e.g. 74ALS74) as shown in Fig. 1.7</p>
</li>
</ul>
<p>1)Functionality: It has to respond to 4 inputs, i.e. preset, clear, clock, and data, to give an output Q(Q’ is also available). </p>
<p>2)Timing check list:</p>
<ul>
<li><p>Dmust not change &lt; tsubefore the active edge of the clock</p>
</li>
<li><p>Dmust not change &lt; thafter the active edge of the clock</p>
</li>
<li><p>Clockmust not have an active edge &lt; tpcafter presetor cleargo inactive</p>
</li>
<li><p>Presetand clearmust have a minimum width</p>
</li>
<li><p>Clockmust have a minimum period, high phase and low phase</p>
</li>
</ul>
<p>Fig. 1.7 74ALS74 type flip-flop</p>
<ul>
<li>An accurate model for such a flip-floprequires</li>
</ul>
<p>upwards of 300 high level programming language<br>statements. It is hoped that any path through<br>as a result of an input change will require only a<br>fraction of these to be executed. </p>
<p>Test generation</p>
<ul>
<li>Once a simulator is in place, a network described and models are available, the network must be exercised. This is done by means of test generation. The goal of the test generation is to exercise the circuit for two purposes.</li>
</ul>
<p>I.To show that the design is correct and the system performs according to specification. The test pattern must be agreed between designer and customer. This set of test patterns is used during the design phase, primarily in simulation, to demonstrate that the design is correct. </p>
<p>II.A second set of test patterns is required to detect faults in the implementation. For example, if a wire has a break in it due to faulty manufacture, then the signal on the ‘driven’ end of this wire will probably be at a fixed logical level. This second set of test generation is needed to give a thorough test of each system built. It is not possible to assess the functionality of the system using these tests, which was the purpose of the first set.</p>
<p>Cont.</p>
<ul>
<li><p>A further set of tests may be needed to check thesystem timing. </p>
</li>
<li><p>Some of the tests in the first set may be provided for this purpose but further tests may still be needed.</p>
</li>
</ul>
<ul>
<li><p>Producing a test generation to exercise the specified functions of the design must be done ‘by hand’ since only the designer understands the system behavior. </p>
</li>
<li><p>Consider Table 1.1, which represents a test generation of the clock and data sections of the flip-flop of Fig. 1.7, presetand clearbeing assumed inactive. This length of program for such a ‘simple’ device, and not including effects of preset and clear, or checks for possible timing faults, demonstrates the difficultywhen many thousands of gates are involved.</p>
</li>
<li><p>The really big problem in test generation is, how do we know that the set of test patterns is comprehensive?Consider a 32-bit adder.</p>
</li>
<li><p>The problem can be made easier if the design is done with testabilityin mind.</p>
</li>
</ul>
<p>Table 1.1 Test data(excerpts) for a flip-flop</p>
<p>(Inactive)</p>
<p>(Active)</p>
<p>Fault simulation</p>
<ul>
<li><p>When a set of test patterns has been generated, it is required to check which faults can be detected. This is done with a fault simulator. </p>
</li>
<li><p>Basically, a set of tests is run on a ‘good’ network, and the results recorded. </p>
</li>
<li><p>A fault is now introduced into the network, the simulation re-run, and its outputs compared with the good network. </p>
</li>
<li><p>If a difference in the primary outputs is found, the fault is detectable.</p>
</li>
</ul>
<ul>
<li><p>The number of possible faults is very large.</p>
</li>
<li><p>It has been found in practice that, if a set of test patterns will detect all stuck-at faults, it will detect most other faults as well.</p>
</li>
</ul>
<p>Cont.</p>
<ul>
<li><p>The number of possible faults in a large network, and hence the number of simulations to be run, is still very large. </p>
</li>
<li><p>If each run were to take several days, the cost would be prohibitive.</p>
</li>
<li><p>Techniques have been developed to speed things up.</p>
</li>
<li><p>Fault simulation is a time consuming and expensive business. It is one which is often ignored at the cost of one’s peril.</p>
</li>
</ul>
<p>Timing verification</p>
<ul>
<li><p>The timing verifier examines the structure of the network and determines where the paths of signal groups converge in such a way that a timing error might occur. These include narrow clock pulses(Fig. 1.3) and the usual flip-flop or memory timing problems. </p>
</li>
<li><p>However, it may be very pessimistic due to including paths which would be improperly used, and may report many narrow pulses  which are not at critical points in the network or in the timing.</p>
</li>
<li><p>There are techniques to make timing verifiers less pessimistic, but care has to be taken not to miss significant events as a result. </p>
</li>
</ul>
<p>Conclusion</p>
<ul>
<li><p>The remainder of the course will expand upon many of the previous sections. </p>
</li>
<li><p>Firstly, simulation will be set in the context of electronic computer aided design (ECAD) as a whole.</p>
</li>
<li><p>The mechanisms involved in the simulator itself are then discussed (These include Chap. 6, 7, and 8).</p>
</li>
<li><p>The course will continue with an introduction to issues involved in design for testability (DFT). This will be followed by a discussion of fault simulation.</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/eda/Q1.html</url>
    <content><![CDATA[<p><strong>Q1: Why is it important to find faults at design time?</strong></p>
<ul>
<li>One of the problems with building hardware is that, once built, it is not easily change. It is estimated that the relative cost of finding faults at design time,</li>
</ul>
<p><strong>Q2: What is the process of simulation? And when is it used?</strong></p>
<ul>
<li>Simulation is the process by which a model of the hardware is set up in software, or better still, in data structures that are ‘run’ by the software.</li>
</ul>
<p><strong>Q3: Is a computer aided design system a substitute for the intelligence of the designer?</strong></p>
<ul>
<li>A computer aided design systems is what it says it is – an aid. </li>
</ul>
<p><strong>Q4: What is the importance for a simulation to run with error reports open?</strong></p>
<ul>
<li>It is not meaningful for a simulation run without error reports. The design time is reduced, but redesign will be necessary.</li>
</ul>
<p><strong>Q5: What is the advantage gained for this very expensive process?</strong></p>
<ul>
<li>Simulation does not generally reduce design time. It frequently increase it, possibly by several hundred percent.</li>
</ul>
<p><strong>Q6: What is the first of all aims of a simulation?</strong></p>
<ul>
<li>Functional correctness（功能正确性）</li>
</ul>
<p><strong>Q7: Why does simulation need to check the responding time of a system?</strong></p>
<ul>
<li>Most systems will have some form of limit on the time they take to respond to given conditions. For example, designs using logic with basic gate speeds of 10ns will quite easily build up delays of 500 ns without the designer’s noticing.</li>
</ul>
<p><strong>Q8: Given basic delay of a simple TTL gate being 8.5 ns, with delays of ECL logic around 1 ns per gate, which technology is faster?</strong></p>
<ul>
<li>ECL logic</li>
</ul>
<p><strong>Q9: Give decreasing order of conductivity of the following metal materials: Au, Ag, polysilicon, Cu, Al.</strong></p>
<ul>
<li>Ag&gt;Cu&gt;Au&gt;Al&gt;polysilicon</li>
</ul>
<p><strong>Q10: What is time constant of a wire? How to compute it?</strong></p>
<ul>
<li>时间常数是在导线电压衰减到1/e的时间，计算公式为R*C。</li>
</ul>
<p><strong>Q11: In which stage in the design process, are wire delays known by the designer?</strong></p>
<ul>
<li>Wire delays are unknown until a late stage in the design process.</li>
</ul>
<p><strong>Q12: What is back annotation?</strong></p>
<ul>
<li>The feedback of layout data to the simulator is one example of what is known as back annotation.</li>
</ul>
<p><strong>Q13: If Z is used as the clock input of a flip-flop, please give an example of a race or hazard.</strong></p>
<ul>
<li>以图1.3为例，信号A与信号B进行与运算，由于A与逻辑门之间过长的组合逻辑电路产生的较长延时，导致输出信号Z产生了一个毛刺。</li>
</ul>
<p><strong>Q14: Please list two of the timing constraints for a flip-flop. What do they (set-up time, and hold time) mean?</strong></p>
<ul>
<li>1.Data to a flip-flop does not change just before the clock (set-up time)</li>
<li>2.Data to a flip-flop does not change just after the clock (hold time)</li>
<li>Setup Time: the  amount  of  time  the  data  at  the  synchronous  input  (D)  must  be  stable  before  the active edge of clock</li>
<li>Hold Time: the amount of time the data at the synchronous input (D) must be stable after the active edge of clock.</li>
</ul>
<p><strong>Q15: What is the use of outputs of the good circuit determined by simulation？</strong></p>
<ul>
<li>The outputs are compared with the output of production hardware to find as many faults as possible.</li>
</ul>
<p><strong>Q16：Which three sets of data does the process of simulation require? And what is the mechanism to process these data?</strong></p>
<ul>
<li>A description of the system to be simulated</li>
<li>A description of the inputs to the simulated system</li>
<li>A set of models of the components of the system being simulated</li>
<li>A mechanism(the simulator) to process these three in a manner which simulates the system being designed.</li>
</ul>
<p><strong>Q17: How can expected outputs for the test fixture be derived by simulation?</strong></p>
<ul>
<li>During test generation, the design is regarded as functionally correct. Hence the expected outputs for the test fixture to check against can be derived by simulation.</li>
</ul>
<p><strong>Q18: What is a top-down procedure as in Fig. 1.4 ?</strong></p>
<ul>
<li>As a rule, a customer will present the design engineer with a specification of the system. The engineer will first divide this into functional blocks – memory, CPU, control, etc. as shown in Fig. 1.4. Each of these major blocks can then be specified clearly and passed to different people for more detailed work. Eventually, the individual circuits such as 4-bit arithmetic logic units (ALUs) are designed. This is described as a top-down procedure.</li>
</ul>
<p><strong>Q19: How many bits does the machine doing the simulation need to represent -2 16?</strong></p>
<ul>
<li>18, 17 for the value and 1 for the sign.</li>
</ul>
<p><strong>Q20: What does the system being designed do, for example, (-2 15) * 2 16 ? How does that compare with the results from a 32-bit machine doing the simulation?</strong></p>
<ul>
<li>-2^31, 当后者是无符号数时是可以在32位乘法器中实现</li>
<li></li>
</ul>
<p><strong>Q21: What does it need for the simulator in the case that the design progressed through the levels unevenly?</strong></p>
<ul>
<li><ol>
<li>Check a low level block against a high level one;</li>
</ol>
</li>
<li><ol>
<li>Run multilevel simulations to<ul>
<li>enable simulations to run faster, since only a few blocks are simulated in detail;</li>
<li>enable larger systems to be simulated, since high level blocks generally requires less resources.</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>Q22: What should a simulator, which can handle all levels of design, be able to do?</strong></p>
<ul>
<li>Functional describes the logic function only and no timing.</li>
<li>Behavioral describe logic and timing.</li>
</ul>
<p><strong>Q23: What is the meaning of ‘functional description’? And what is that of ‘behavioral description’?</strong></p>
<ul>
<li>Functional describes the logic function only and no timing.</li>
<li>Behavioral describe logic and timing.</li>
</ul>
<p><strong>Q24: Which kind of models does gate-level description use?</strong></p>
<ul>
<li>This level of description uses models of ‘simple’ gates. The logical elements may include multiplexers and flip-flops, though both may be described in the data books in terms of ANDs and/or ORs.</li>
</ul>
<p><strong>Q25: What is the Boolean expression for ‘Sum’ and ‘Carry’, respectively, as in Fig. 1.5?</strong></p>
<ul>
<li>C = ~(AB) D = ~(A+B) E = C XOR D</li>
<li>E = ~C D + ~D C = A XOR B</li>
<li>Sum = A XOR B XOR Carry</li>
</ul>
<p><strong>Q26: Which element models are used in description of circuit-level simulation?</strong></p>
<ul>
<li>The circuit is described in terms of resistances, capacitances and voltage and current sources which are the models.</li>
</ul>
<p><strong>Q27: What is the primary technique with the trade off between speed and accuracy, which is known as switch level?</strong></p>
<ul>
<li>The primary technique is to regard the transistors as switches that are either open or closed.</li>
</ul>
<p><strong>Q28: Can switch-level simulation handle the transient performance of digital circuits? And can it give frequency responses of true analog circuits, like amplifiers? Why?</strong></p>
<ul>
<li>Yes. </li>
<li>No, At its simplest, no timing is involved. The circuit is divided into sections starting from a gate output and proceeding to the following inputs.</li>
</ul>
<p><strong>Q29: What is purpose of mixed-mode simulation?</strong></p>
<ul>
<li>To link circuit simulation and digital simulation</li>
</ul>
<p><strong>Q30: What way can be attempted to achieve mixed-mode simulation? Which one could be the best selection according to your analysis?</strong></p>
<ul>
<li>1) Write a link between a circuit simulator and a digital simulator.</li>
<li>2) A circuit analysis system based on events has been developed</li>
<li>3) ‘Behavioral analog’</li>
<li>The 2nd.</li>
</ul>
<p><strong>Q31: Why does the text say ‘writing accurate models of components is a difficult and skilled activity’? Please give an example to explain it.</strong></p>
<ul>
<li>设计者需要注意时序的问题，防止产生错误的逻辑。</li>
<li>An accurate model for such a flip-flop requires upwards of 300 high level programming language statements. It is hoped that any path through as a result of an input change will require only a fraction of these to be executed.</li>
</ul>
<p><strong>Q32: What are the purposes for the test generation to exercise the circuit?</strong></p>
<ul>
<li><ol>
<li>To show that the design is correct and the system performs according to specification.</li>
</ol>
</li>
<li><ol>
<li>A second set of test patterns is required to detect faults in the implementation.</li>
</ol>
</li>
</ul>
<p><strong>Q33: What is the really big problem in test generation? How the problem can be made easier?</strong></p>
<ul>
<li>The really big problem in test generation is, how do we know that the set of test patterns is comprehensive?</li>
<li>The problem can be made easier if the design is done with testability in mind.</li>
</ul>
<p><strong>Q34: What is required to check with a fault simulator, when a set of test patterns has been generated?</strong></p>
<ul>
<li>it is required to check which faults can be detected.</li>
</ul>
<p><strong>Q35: Why stuck-at faults is usually the detective goal of a set of test patterns?</strong></p>
<ul>
<li>It has been found in practice that, if a set of test patterns will detect all stuck-at faults, it will detect most other faults as well.</li>
</ul>
<p><strong>Q36: What is the problem of ignoring the time consuming and expensive fault simulation?</strong></p>
<ul>
<li>Fault simulation is a time consuming and expensive business. It is one which is often ignored at the cost of one’s peril.</li>
</ul>
<p><strong>Q37: Which techniques could be used to make timing verifiers less pessimistic? Will these techniques take care to not miss significant events as well?</strong></p>
<ul>
<li>There are techniques to make timing verifiers less pessimistic, but care has to be taken not to miss significant events as a result.</li>
<li>Yes</li>
</ul>
<p><strong>Q1: How many approaches to simulation? And what are they?</strong></p>
<ul>
<li>There are two approaches to simulation:</li>
<li><ol>
<li>Simulate for functional correctness, ignoring all timing considerations.</li>
</ol>
</li>
<li><ol>
<li>Simulate in an environment in which the models include timing.</li>
</ol>
</li>
</ul>
<p><strong>Q2: What is the simplest approach to simulation? What is the according advantage and disadvantage, respectively?</strong></p>
<ul>
<li>The simplest approach to simulation is to have a separate procedure for every logical element in the network, and the connections between the elements are then mirrored in the machine code of the program.</li>
</ul>
<p><strong>Q3: By having only one procedure for each element type, how about the storage and computing cost changes as compared with for every logical element?</strong></p>
<ul>
<li>Procedure calls need machine states to be saved temporarily and restored on exit, which is expensive in CPU resources.</li>
<li>Storage space is saved, since only one copy of each different procedure is needed. The cost is the time taken in procedure calling.</li>
</ul>
<p><strong>Q4: How about element’s delay in the simplest simulator?</strong></p>
<ul>
<li>In the simplest simulator, all elements will have the same delay.</li>
</ul>
<p><strong>Q5: Could the simplest simulator be used for timing verification?</strong></p>
<ul>
<li>No. 因为在简单仿真器中所有的器件被视为拥有相同的延时，也就是说最简仿真器没有考虑时序因素。</li>
</ul>
<p><strong>Q6: How is the first type of simulator designed to check logical correctness and timing accuracy, respectively? What is the name of this type of simulator?</strong></p>
<ul>
<li>It is usually run by compiling the network, and is frequently known as the compiled code simulator, since the structure is reflected in the machine storage and the program. </li>
<li>It is a static structure, allowing no timing detail to be seen.</li>
</ul>
<p><strong>Q7: What is the name of the second type of simulator? How usually is it run?</strong></p>
<ul>
<li>It is referred to as a table-based event driven simulator (or table based or event driven for brevity). Such a simulator usually (but not necessarily) is run interpretively.</li>
</ul>
<p><strong>Q8: What are other distinctions between the two?</strong></p>
<ul>
<li>The compiled code approach presumes a synchronous system is being simulated – that is a system consisting essentially of blocks of combinational logic separated by clocked registers.</li>
<li>The event driven approach can handle any system, including asynchronous systems.</li>
</ul>
<p><strong>Q9: What is the essence of a compiled code simulator?</strong></p>
<ul>
<li>The essence of a compiled code simulator is that the structure of the system under simulation is reflected in the computer storage, and that each logical element has its own code.</li>
</ul>
<p><strong>Q10: What is the logic function of the not equivalence circuit as in Fig. 6.1?</strong></p>
<ul>
<li>Z=¯(¯(A⋅¯AB) ¯(B⋅¯AB))=A⋅¯AB+B⋅¯AB=(A+B)(¯A+¯B)=A⊕B</li>
</ul>
<p><strong>Q11: What is the full name of ‘LCC’? What is it based on?</strong></p>
<ul>
<li>The full name of ‘LCC’ is levelized compiled code simulator.</li>
<li>这个问题是想问使用LCC的目的，是为了检查电路的逻辑正确性。</li>
</ul>
<p><strong>Q12: With real timing, is it possible for a narrow pulse to occur at D or E?</strong></p>
<ul>
<li>Yes.</li>
</ul>
<p><strong>Q13: What is the elements limitation in the Yorktown Simulation Engine?</strong></p>
<ul>
<li>In the Yorktown Simulation Engine (YSE), the elements are limited to 4-input 1-output devices. Thus only 5 addresses are needed per element in the YSE and all are provided for every element. There will still be some wastage, but it will be strictly limited.</li>
</ul>
<p><strong>Q14: By what will the network compiler ensure connectivity of the network in the ‘instruction memory’?</strong></p>
<ul>
<li>The network compiler will ensure that connectivity of the network is implied by signal addresses in the ‘instruction memory’. These signal addresses refer to the data memory.</li>
</ul>
<p><strong>Q15: What is the relationship between the ‘instruction memory’ and the data memory?</strong></p>
<ul>
<li>The connectivity of the network is implied by signal addresses in the ‘instruction memory’.</li>
<li>These signal addresses refer to the data memory.</li>
</ul>
<p><strong>Q16: Will the instruction memory change with different input values?</strong></p>
<ul>
<li>No. 因为instruction memory是描述器件的网表，与你的信号值是无关的，所以不同的输入信号并不会改变它的内容</li>
</ul>
<p><strong>Q17: Will the data memory change with different input values?</strong></p>
<ul>
<li>Yes.</li>
</ul>
<p><strong>Q18: Is the simple R-S flip-flop a deadlock situation for a LCC simulator? And, why?</strong></p>
<ul>
<li>Yes. R-S flip-flop has feedback in it.</li>
</ul>
<p><strong>Q19: In which memory is table 6.3 stored?</strong></p>
<ul>
<li>data memory.</li>
</ul>
<p><strong>Q20: What danger is there in all simulators according to table 6.4, in networks involving feedback?</strong></p>
<ul>
<li>In all simulators there is a danger of oscillation in networks involving feedback.</li>
</ul>
<p><strong>Q21: Is the LCC simulator a powerful tool for asynchronous logic? Give an example of asynchronous circuit, and give some comments.</strong></p>
<ul>
<li><p>No, LCC simulators should only be used with synchronous systems.</p>
</li>
<li><p>In digital electronics, an asynchronous circuit, clockless, or self-timed circuit, is a sequential digital logic circuit which is not governed by a clock circuit or global clock signal. Instead it often uses signals that indicate completion of instructions and operations, specified by simple data transfer protocols. (From Wikipedia) For example: </p>
</li>
<li></li>
</ul>
<p><strong>Q22: Why does the compiled code simulator run very fast?</strong></p>
<ul>
<li>The compiled code simulator runs very fast, since the code traces the links between elements, and time is ignored.</li>
</ul>
<p><strong>Q23: How to solve the problem that any change in network or devices require a full recompilation?</strong></p>
<ul>
<li>Use the event driven simulator.</li>
</ul>
<p><strong>Q24: What is the activity rate does it corresponds to the clock period of the synchronous logic for a LCC simulator?</strong></p>
<ul>
<li>As every logical element is evaluated in this time period, the activity is said to be 100%.</li>
<li>For synchronous logic this corresponds to the activity in one clock period of the system.</li>
<li></li>
</ul>
<p><strong>Q25: Why is the number of elements that requires evaluating is typically 1% or less at each time step for the event driven simulator?</strong></p>
<ul>
<li>Because time steps are much less than a clock period.</li>
</ul>
<p><strong>Q26: What is meaning of the ‘time step’ for a compiled code simulator?</strong></p>
<ul>
<li>In a compiled code simulator, a ‘time step’ is equivalent to a clock period.</li>
</ul>
<p><strong>Q27: What is the strength of an event driven simulator?</strong></p>
<ul>
<li>The strength of an event driven simulator is its ability to provide detailed timing.</li>
</ul>
<p><strong>Q28: What is the primary advantage of an event driven simulator?</strong></p>
<ul>
<li>The primary advantage of the event driven simulator is not speed, but time accuracy.</li>
</ul>
<p><strong>Q29: How many steps are there in the simulator’s working with the set of events for the time T? Describe the process step by step.</strong></p>
<ul>
<li>Three.</li>
<li>An event is extracted from the list. The event data includes an address in the gate’s fan-out table.</li>
<li>Starting at this address, the value of this output signal is updated. Subsequent fan-out table addresses point to element inputs driven by the current event. For each of the driven elements in turn, the data is extracted from other tables, the element type is determined, and the model evaluated.</li>
<li>Outputs will be predicted to occur some time in the future, 𝛿t say, and these will be added to the event list for time T+𝛿t .</li>
</ul>
<p><strong>Q30: Where will the events be added to the event list for time T if outputs predicted to occur δt in the future?</strong></p>
<ul>
<li>The events will be added to the event list for time T+𝛿t .</li>
</ul>
<p><strong>Q31: What is the information contained in the fan-out memory?</strong></p>
<ul>
<li>The fan-out memory, FOM, containing information on where to find the inputs which are driven by that output.</li>
</ul>
<p><strong>Q32: In the case of no change at present, whether an output prediction is forwarded to the event memory or not?</strong></p>
<ul>
<li>Yes. All output predictions must be forwarded to the event memory, even if, at this stage, there appears to be no change.</li>
</ul>
<p><strong>Q33: What fields do records contain in a single linked list for an event memory?</strong></p>
<ul>
<li>value, fan-out index and absolute time.</li>
</ul>
<p><strong>Q34: What is the deficiency of using a single linked list for an event memory? And, what is the solution?</strong></p>
<ul>
<li>The total number of events in the memory for a reasonable sized piece of logic will be very large, and hence finding the place at which to insert an event could take a long time.</li>
<li>The usual approach is to form a list of lists in order of time, called a ‘time wheel’.</li>
</ul>
<p><strong>Q35: What is the size of the total number of events in an EM for a reasonable sized piece of logic?</strong></p>
<ul>
<li>The total number of events in the memory for a reasonable sized piece of logic will be very</li>
<li>large, and hence finding the place at which to insert an event could take a long time.</li>
</ul>
<p><strong>Q36: What kind of structure can you form for a ‘time wheel’?</strong></p>
<ul>
<li>The usual approach is to form a list of lists in order of time, called a ‘time wheel’.</li>
</ul>
<p><strong>Q37: What is a ‘time wheel’ or chronwheel?</strong></p>
<ul>
<li>The list pointers are thus a circular list, and is called a time WHEEL or chronwheel. The wheel itself is an array of pointers.</li>
</ul>
<p><strong>Q38: Where does each pointer in the time wheel indicate? Does a list of events make good use of storage? Why?</strong></p>
<ul>
<li>Each pointer in the time wheel indicates the address of a list of events that has been scheduled for that time. </li>
<li>It doesn’t make good use of storage, because:</li>
<li>Each list must be long enough to hold the maximum number of events for any time interval.</li>
<li>Furthermore, the lists for the times furthest ahead are likely to have relatively few events.</li>
<li>This is a very poor use of storage.</li>
</ul>
<p><strong>Q39: What is the alternative structure for each time slot in the time wheel?</strong></p>
<ul>
<li>An alternative is to use a linked list for each time slot in the time wheel. It is only necessary to provide sufficient storage for the sum of all the event lists, and there is much less wastage.</li>
</ul>
<p><strong>Q40: Which fields are there in each record of EM?</strong></p>
<ul>
<li>Each record holds the predicted value of a signal, the fan-out index (FOI), and a pointer.</li>
<li></li>
</ul>
<p><strong>Q41: How many events are there in the set for this time in Fig. 6.11?</strong></p>
<ul>
<li>2 events. 包含两个事件，分别在地址137和地址31的事件寄存器中。</li>
</ul>
<p><strong>Q42: When is the address 137 added to the end of the free list?</strong></p>
<ul>
<li>The time wheel pointer is 137. The record at location 137 (in EM) is read. The pointer value, 31, is placed in the time wheel (for ‘T’) and the address 137 added to the end of the free list.</li>
</ul>
<p><strong>Q43: What is the processing sequence for events at time ‘T’, as in Fig. 6.11? Is the order of processing of all events in a given  list, which take place at the same time, important?</strong></p>
<ul>
<li>The sequence of event is the event 137 to event 31.</li>
<li>事件处理的顺序不重要，因为每一个事件作用于一个单独的信号，因此事件之间互不影响，可以并行处理。</li>
</ul>
<p><strong>Q44: What does 3.5 sets of data out consist of according to conventional wisdom suggestion?</strong></p>
<ul>
<li>Conventional wisdom suggests that each output drives 2.5 inputs on average, so for each event, there are 3.5 sets of data out, that is for the output and 2.5 inputs (of the driven elements).</li>
</ul>
<p><strong>Q45: Do the elements driven by C need to be evaluated again at time 17, as in Fig. 6.13? Why?</strong></p>
<ul>
<li>No. Since all driven elements have already been evaluated for this change, they do not need to be evaluated again as a result of this event.</li>
</ul>
<p><strong>Q46: What does the simulator do if the output prediction is different from the value in the state table?</strong></p>
<ul>
<li>If the output prediction is different from the value in the state table, the event is passed on to the evaluation routines. The signal value in the state table is updated.</li>
</ul>
<p><strong>Q47: Which interested memories are there in an event driven simulator as in Fig. 6.7?</strong></p>
<ul>
<li>There are 4 interested memories (Fig. 6.7), which are each an allocated area of the real machine memory. </li>
<li>Network memory, event memory, fan-out memory, state table</li>
</ul>
<p><strong>Q48: What is the form of addressing of the memories? What will be NM234 for the base of 10,000?</strong></p>
<ul>
<li>Addressing of the memories will be written in the form of base and offset.</li>
<li>To find an item of data, the offset is added to the base to give the real address. Thus, NM234 will be 10234.</li>
</ul>
<p><strong>Q49: What is the Boolean expression of Z with the primary inputs as in Fig. 6.14?</strong></p>
<ul>
<li>Z=A⊕B</li>
</ul>
<p><strong>Q50: According to Table 6.5, what data is stored in a network memory? You may give your explanation using G1 as an example.</strong></p>
<ul>
<li>第一行是器件的名称以及在输出信号在FM的地址，</li>
<li>第二行是器件输出信号的名称和信号值，之后是输入信号的名称和信号值</li>
<li>最后是器件的功能，或者工艺信息。</li>
<li>The 1st contains the base address of data relating to G1 in the fan-out memory.</li>
<li>The 2nd contains the output value and the next two contain the input values.</li>
<li>The last line contains the element type (or a pointer to the evaluation routine for this element)</li>
</ul>
<p><strong>Q51: Which information can you find in FOM for a signal? Give your explanation using signal C as an example in Table 6.6.</strong></p>
<ul>
<li>For G1, the output C is on line NM(1+1), and the two fan-in’s on lines NM(6+3) and NM(11+2)</li>
<li>of the network memory.</li>
</ul>
<p><strong>Q53: Is the delay of tpLH equivalent to that of tpHL for the elements of example circuit? What is the value for each of them,  respectively?</strong></p>
<ul>
<li>No. The tpLH is 9ns, while the tpHL is 5ns.</li>
</ul>
<p><strong>Q54: What is the fan-out index of signal A as known by the primary input controller?</strong></p>
<ul>
<li>The fan-out index of A is known by the primary input controller to be FOM1.</li>
</ul>
<p><strong>Q55: What is to do if the value from the state table different from the new value of A?</strong></p>
<ul>
<li>The state table value is updated.</li>
</ul>
<p><strong>Q56: Must an input change be sent to the event memory even if gate-output’s prediction is unchanged?</strong></p>
<ul>
<li>Yes.</li>
</ul>
<p><strong>Q57: What is indicated as the flag in FOM1 of the fan-out memory is 1? Which memory location is set to 0 with the output of G2 being  predicted to 0 at time 5?</strong></p>
<ul>
<li>The flag in FOM1 of the fan-out memory is 1, indicating that another gate input is driven by A.</li>
<li>The next free memory location in the event memory is at address EM1. The value in this location is set to 0, and the fan-out index to FOM8.</li>
</ul>
<p><strong>Q58: What does time do since the flag in line 2 of the fan-out memory is 0？Why？</strong></p>
<ul>
<li>Time now advances to find the next event., because there are no further fan-outs of signal A</li>
</ul>
<p><strong>Q59: What is the wheel pointer, at time 5? Which steps does simulator follow after find address EM1 of the event memory?</strong></p>
<ul>
<li>At time 5, the time wheel pointer is EM1.</li>
<li>Address EM1 of the event memory has a fan-out index of FOM8.Reading line FOM8 of the fan-out memory finds the state table line ST2. Considering state table for line ST2, it is found that the value is 1 prior to time 5. The value from the event memory is 0, so there is a change. The value in line ST2 of the state table is updated accordingly. The fan-out memory of line FOM8 points to line NM(6+1) in the network memory. This is the output of G2, so Dis also updated. As this is an output, an evaluation is not required. Line EM1 location is returned to the free list.</li>
</ul>
<p><strong>Q60: What should the simulator do if a line of the fan-out memory has its flag set?</strong></p>
<ul>
<li>Read a further line.</li>
</ul>
<p><strong>Q61: When does the evaluation at time 5 predict that Z will change from ‘0’to ‘1’?</strong></p>
<ul>
<li>The evaluation predicts that Z will change to 1 in tpLH, at time 5+9 = 14.</li>
</ul>
<p><strong>Q62: What operation was taken on the EM when the event at time 5 was read out?</strong></p>
<ul>
<li>Event memory location EM1 was recovered when the event at time 5 was read out, so this is the next available location.</li>
</ul>
<p><strong>Q63: Why is there no further activity as a result of the change of A at time 0 after the event at time 14 is processed?</strong></p>
<ul>
<li>There are no fan-outs of this signal and there are no more events in the time wheel, so there is no further activity as a result of this change of A.</li>
</ul>
<p><strong>Q64: What is the new change that the primary input controller applies at time 100?</strong></p>
<ul>
<li>This is B going to 1.</li>
</ul>
<p><strong>Q65: What problem does consideration of the potential changes from 114 illustrate? And, what is the solution?</strong></p>
<ul>
<li>The first indicates a change of E to 1. As D is still 0(data not yet read), a prediction that Z will change to 1 at time 123 is made.</li>
<li>However, on reading the D change, it is found that Z is predicted to go to 0 at time 119.</li>
<li><p>It is assumed that the event at time 123 is deleted after the second event is read on processing T =114.</p>
</li>
<li><p>There are two solution, both of which are required.</p>
</li>
<li>For this specific case, it is sufficient if it can be arranged to evaluate each element not more than once in each time slot. This is described further in Sec. 6.5.1(*some refinements).</li>
<li>The second solution is to remove the event at time 123. This in turn requires knowledge that the event has been placed, followed by a search of all event memory lists which might contain the false prediction.</li>
<li>However, the use of unequal rising and falling delays, as here, makes it necessary to have some such mechanism.</li>
</ul>
<p><strong>Q66: What is the longest delay through the circuit for the input (B)’s changing at time 100? And, what is that for A’s changing to 0  at 200 ns?</strong></p>
<ul>
<li>19ns; 23ns.</li>
</ul>
<p><strong>Q67: What is the aim of a timing verifier?</strong></p>
<ul>
<li>The aim of a timing verifier is to perform a full analysis of the circuit independent of the input patterns</li>
</ul>
<p><strong>Q68: What is the horizontal ordinate and vertical ordinate for the state table, respectively?</strong></p>
<ul>
<li>horizontal ordinate: address</li>
<li>vertical ordinate: T</li>
<li>横坐标是仿真的时间点，纵坐标是每一个信号的指针</li>
</ul>
<p><strong>Q69: What is the use of Free List of EM?</strong></p>
<ul>
<li>For prediction and recover. </li>
<li>free list用于存储事件寄存器中哪些空间可用，他可以让所有时轮中的事件列表共用一块内存。</li>
</ul>
<p><strong>Q70: Notice the short pulse on E. Does the ‘logic only’ LCC simulator predict this? Why is the difference?</strong></p>
<ul>
<li>No. 我们注意到e的一个短脉冲是由于c信号翻转的延时导致的，因此不考虑时延的LCC模型是不能对其进行描述的。</li>
</ul>
<p><strong>Q71: Which are examples of groups of signals?</strong></p>
<ul>
<li>Examples might include: memory address signals; data buses in a processor.</li>
</ul>
<p><strong>Q72: What benefits does treating such groups as a unit leads to?</strong></p>
<ul>
<li>Since the group is treated as a unit, it requires only one fan-out index.</li>
<li>As there is only one set of fan-out data per group, the storage requirements of the fan-out memory are also reduced.</li>
<li>As the group is a single unit, only one event has to pass around the simulator for each group.</li>
</ul>
<p><strong>Q73: How many fan-out index does it require since the group is treated as a unit? And, how about the number of events?</strong></p>
<ul>
<li>Since the group is treated as a unit, it requires only one fan-out index.</li>
</ul>
<p><strong>Q74: How many bits are defined in IEEE 754 standard for single-precision floating point number and double-precision number,  respectively?</strong></p>
<ul>
<li>32 bits for single-precision, 64 bits for double-precision number.</li>
</ul>
<p><strong>Q75: How does the simulator know a group and identify the size of its?</strong></p>
<ul>
<li>There is a bit to indicate that this is a group and some means of identifying the size of the group.</li>
</ul>
<p><strong>Q76: Where is a new routine named group split unit placed in Fig. 6.7? What does the group split unit do when it notices a new  prediction?</strong></p>
<ul>
<li>A new routine is placed in the simulator between the evaluator and the event memory (Fig. 6.7)</li>
<li>When the 32-bit register prediction reaches the group split unit, the unit notices that it is a group rather than a single signal. The group split unit now calls the splitting procedure for this group. For the example quoted two groups are formed.</li>
</ul>
<p><strong>Q77: How many groups are there in line FOM53 after group splitting?</strong></p>
<ul>
<li>3</li>
</ul>
<p><strong>Q78: What is the offset for the 8-bit subgroup, 2 single bits, and the 20-bit group, respectively, supposing that the combined group  starts at NM (1234 + 5) in the network memory? And, which locations does each of them occupy?</strong></p>
<ul>
<li>Each subgroup, including the single bits, will have address NM1234 in the fan-out memory. All the offsets are computed by the network compiler at compile time.</li>
</ul>
<p><strong>Q79: What are major times involved in simulation?</strong></p>
<ul>
<li>The major times involved in simulation are</li>
<li>calling and evaluating models,</li>
<li>extracting data from the time wheel, following fan-out linkages and forming the affected components list,</li>
<li>searching for erroneous data.</li>
</ul>
<p><strong>Q80: Which kinds of models do switch level simulators require?</strong></p>
<ul>
<li>Switch level simulators require different modelling approaches.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/eda/Q2.html</url>
    <content><![CDATA[<p><strong>Q1: How many approaches to simulation? And what are they?</strong></p>
<ul>
<li>There are two approaches to simulation:</li>
<li><ol>
<li>Simulate for functional correctness, ignoring all timing considerations.</li>
</ol>
</li>
<li><ol>
<li>Simulate in an environment in which the models include timing.</li>
</ol>
</li>
</ul>
<p><strong>Q2: What is the simplest approach to simulation? What is the according advantage and disadvantage, respectively?</strong></p>
<ul>
<li>The simplest approach to simulation is to have a separate procedure for every logical element in the network, and the connections between the elements are then mirrored in the machine code of the program.</li>
</ul>
<p><strong>Q3: By having only one procedure for each element type, how about the storage and computing cost changes as compared with for every logical element?</strong></p>
<ul>
<li>Procedure calls need machine states to be saved temporarily and restored on exit, which is expensive in CPU resources.</li>
<li>Storage space is saved, since only one copy of each different procedure is needed. The cost is the time taken in procedure calling.</li>
</ul>
<p><strong>Q4: How about element’s delay in the simplest simulator?</strong></p>
<ul>
<li>In the simplest simulator, all elements will have the same delay.</li>
</ul>
<p><strong>Q5: Could the simplest simulator be used for timing verification?</strong></p>
<ul>
<li>No. 因为在简单仿真器中所有的器件被视为拥有相同的延时，也就是说最简仿真器没有考虑时序因素。</li>
</ul>
<p><strong>Q6: How is the first type of simulator designed to check logical correctness and timing accuracy, respectively? What is the name of this type of simulator?</strong></p>
<ul>
<li>It is usually run by compiling the network, and is frequently known as the compiled code simulator, since the structure is reflected in the machine storage and the program. </li>
<li>It is a static structure, allowing no timing detail to be seen.</li>
</ul>
<p><strong>Q7: What is the name of the second type of simulator? How usually is it run?</strong></p>
<ul>
<li>It is referred to as a table-based event driven simulator (or table based or event driven for brevity). Such a simulator usually (but not necessarily) is run interpretively.</li>
</ul>
<p><strong>Q8: What are other distinctions between the two?</strong></p>
<ul>
<li>The compiled code approach presumes a synchronous system is being simulated – that is a system consisting essentially of blocks of combinational logic separated by clocked registers.</li>
<li>The event driven approach can handle any system, including asynchronous systems.</li>
</ul>
<p><strong>Q9: What is the essence of a compiled code simulator?</strong></p>
<ul>
<li>The essence of a compiled code simulator is that the structure of the system under simulation is reflected in the computer storage, and that each logical element has its own code.</li>
</ul>
<p><strong>Q10: What is the logic function of the not equivalence circuit as in Fig. 6.1?</strong></p>
<ul>
<li>Z=¯(¯(A⋅¯AB) ¯(B⋅¯AB))=A⋅¯AB+B⋅¯AB=(A+B)(¯A+¯B)=A⊕B</li>
</ul>
<p><strong>Q11: What is the full name of ‘LCC’? What is it based on?</strong></p>
<ul>
<li>The full name of ‘LCC’ is levelized compiled code simulator.</li>
<li>这个问题是想问使用LCC的目的，是为了检查电路的逻辑正确性。</li>
</ul>
<p><strong>Q12: With real timing, is it possible for a narrow pulse to occur at D or E?</strong></p>
<ul>
<li>Yes.</li>
</ul>
<p><strong>Q13: What is the elements limitation in the Yorktown Simulation Engine?</strong></p>
<ul>
<li>In the Yorktown Simulation Engine (YSE), the elements are limited to 4-input 1-output devices. Thus only 5 addresses are needed per element in the YSE and all are provided for every element. There will still be some wastage, but it will be strictly limited.</li>
</ul>
<p><strong>Q14: By what will the network compiler ensure connectivity of the network in the ‘instruction memory’?</strong></p>
<ul>
<li>The network compiler will ensure that connectivity of the network is implied by signal addresses in the ‘instruction memory’. These signal addresses refer to the data memory.</li>
</ul>
<p><strong>Q15: What is the relationship between the ‘instruction memory’ and the data memory?</strong></p>
<ul>
<li>The connectivity of the network is implied by signal addresses in the ‘instruction memory’.</li>
<li>These signal addresses refer to the data memory.</li>
</ul>
<p><strong>Q16: Will the instruction memory change with different input values?</strong></p>
<ul>
<li>No. 因为instruction memory是描述器件的网表，与你的信号值是无关的，所以不同的输入信号并不会改变它的内容</li>
</ul>
<p><strong>Q17: Will the data memory change with different input values?</strong></p>
<ul>
<li>Yes.</li>
</ul>
<p><strong>Q18: Is the simple R-S flip-flop a deadlock situation for a LCC simulator? And, why?</strong></p>
<ul>
<li>Yes. R-S flip-flop has feedback in it.</li>
</ul>
<p><strong>Q19: In which memory is table 6.3 stored?</strong></p>
<ul>
<li>data memory.</li>
</ul>
<p><strong>Q20: What danger is there in all simulators according to table 6.4, in networks involving feedback?</strong></p>
<ul>
<li>In all simulators there is a danger of oscillation in networks involving feedback.</li>
</ul>
<p><strong>Q21: Is the LCC simulator a powerful tool for asynchronous logic? Give an example of asynchronous circuit, and give some comments.</strong></p>
<ul>
<li><p>No, LCC simulators should only be used with synchronous systems.</p>
</li>
<li><p>In digital electronics, an asynchronous circuit, clockless, or self-timed circuit, is a sequential digital logic circuit which is not governed by a clock circuit or global clock signal. Instead it often uses signals that indicate completion of instructions and operations, specified by simple data transfer protocols. (From Wikipedia) For example: </p>
</li>
<li></li>
</ul>
<p><strong>Q22: Why does the compiled code simulator run very fast?</strong></p>
<ul>
<li>The compiled code simulator runs very fast, since the code traces the links between elements, and time is ignored.</li>
</ul>
<p><strong>Q23: How to solve the problem that any change in network or devices require a full recompilation?</strong></p>
<ul>
<li>Use the event driven simulator.</li>
</ul>
<p><strong>Q24: What is the activity rate does it corresponds to the clock period of the synchronous logic for a LCC simulator?</strong></p>
<ul>
<li>As every logical element is evaluated in this time period, the activity is said to be 100%.</li>
<li>For synchronous logic this corresponds to the activity in one clock period of the system.</li>
<li></li>
</ul>
<p><strong>Q25: Why is the number of elements that requires evaluating is typically 1% or less at each time step for the event driven simulator?</strong></p>
<ul>
<li>Because time steps are much less than a clock period.</li>
</ul>
<p><strong>Q26: What is meaning of the ‘time step’ for a compiled code simulator?</strong></p>
<ul>
<li>In a compiled code simulator, a ‘time step’ is equivalent to a clock period.</li>
</ul>
<p><strong>Q27: What is the strength of an event driven simulator?</strong></p>
<ul>
<li>The strength of an event driven simulator is its ability to provide detailed timing.</li>
</ul>
<p><strong>Q28: What is the primary advantage of an event driven simulator?</strong></p>
<ul>
<li>The primary advantage of the event driven simulator is not speed, but time accuracy.</li>
</ul>
<p><strong>Q29: How many steps are there in the simulator’s working with the set of events for the time T? Describe the process step by step.</strong></p>
<ul>
<li>Three.</li>
<li>An event is extracted from the list. The event data includes an address in the gate’s fan-out table.</li>
<li>Starting at this address, the value of this output signal is updated. Subsequent fan-out table addresses point to element inputs driven by the current event. For each of the driven elements in turn, the data is extracted from other tables, the element type is determined, and the model evaluated.</li>
<li>Outputs will be predicted to occur some time in the future, 𝛿t say, and these will be added to the event list for time T+𝛿t .</li>
</ul>
<p><strong>Q30: Where will the events be added to the event list for time T if outputs predicted to occur δt in the future?</strong></p>
<ul>
<li>The events will be added to the event list for time T+𝛿t .</li>
</ul>
<p><strong>Q31: What is the information contained in the fan-out memory?</strong></p>
<ul>
<li>The fan-out memory, FOM, containing information on where to find the inputs which are driven by that output.</li>
</ul>
<p><strong>Q32: In the case of no change at present, whether an output prediction is forwarded to the event memory or not?</strong></p>
<ul>
<li>Yes. All output predictions must be forwarded to the event memory, even if, at this stage, there appears to be no change.</li>
</ul>
<p><strong>Q33: What fields do records contain in a single linked list for an event memory?</strong></p>
<ul>
<li>value, fan-out index and absolute time.</li>
</ul>
<p><strong>Q34: What is the deficiency of using a single linked list for an event memory? And, what is the solution?</strong></p>
<ul>
<li>The total number of events in the memory for a reasonable sized piece of logic will be very large, and hence finding the place at which to insert an event could take a long time.</li>
<li>The usual approach is to form a list of lists in order of time, called a ‘time wheel’.</li>
</ul>
<p><strong>Q35: What is the size of the total number of events in an EM for a reasonable sized piece of logic?</strong></p>
<ul>
<li>The total number of events in the memory for a reasonable sized piece of logic will be very</li>
<li>large, and hence finding the place at which to insert an event could take a long time.</li>
</ul>
<p><strong>Q36: What kind of structure can you form for a ‘time wheel’?</strong></p>
<ul>
<li>The usual approach is to form a list of lists in order of time, called a ‘time wheel’.</li>
</ul>
<p><strong>Q37: What is a ‘time wheel’ or chronwheel?</strong></p>
<ul>
<li>The list pointers are thus a circular list, and is called a time WHEEL or chronwheel. The wheel itself is an array of pointers.</li>
</ul>
<p><strong>Q38: Where does each pointer in the time wheel indicate? Does a list of events make good use of storage? Why?</strong></p>
<ul>
<li>Each pointer in the time wheel indicates the address of a list of events that has been scheduled for that time. </li>
<li>It doesn’t make good use of storage, because:</li>
<li>Each list must be long enough to hold the maximum number of events for any time interval.</li>
<li>Furthermore, the lists for the times furthest ahead are likely to have relatively few events.</li>
<li>This is a very poor use of storage.</li>
</ul>
<p><strong>Q39: What is the alternative structure for each time slot in the time wheel?</strong></p>
<ul>
<li>An alternative is to use a linked list for each time slot in the time wheel. It is only necessary to provide sufficient storage for the sum of all the event lists, and there is much less wastage.</li>
</ul>
<p><strong>Q40: Which fields are there in each record of EM?</strong></p>
<ul>
<li>Each record holds the predicted value of a signal, the fan-out index (FOI), and a pointer.</li>
<li></li>
</ul>
<p><strong>Q41: How many events are there in the set for this time in Fig. 6.11?</strong></p>
<ul>
<li>2 events. 包含两个事件，分别在地址137和地址31的事件寄存器中。</li>
</ul>
<p><strong>Q42: When is the address 137 added to the end of the free list?</strong></p>
<ul>
<li>The time wheel pointer is 137. The record at location 137 (in EM) is read. The pointer value, 31, is placed in the time wheel (for ‘T’) and the address 137 added to the end of the free list.</li>
</ul>
<p><strong>Q43: What is the processing sequence for events at time ‘T’, as in Fig. 6.11? Is the order of processing of all events in a given  list, which take place at the same time, important?</strong></p>
<ul>
<li>The sequence of event is the event 137 to event 31.</li>
<li>事件处理的顺序不重要，因为每一个事件作用于一个单独的信号，因此事件之间互不影响，可以并行处理。</li>
</ul>
<p><strong>Q44: What does 3.5 sets of data out consist of according to conventional wisdom suggestion?</strong></p>
<ul>
<li>Conventional wisdom suggests that each output drives 2.5 inputs on average, so for each event, there are 3.5 sets of data out, that is for the output and 2.5 inputs (of the driven elements).</li>
</ul>
<p><strong>Q45: Do the elements driven by C need to be evaluated again at time 17, as in Fig. 6.13? Why?</strong></p>
<ul>
<li>No. Since all driven elements have already been evaluated for this change, they do not need to be evaluated again as a result of this event.</li>
</ul>
<p><strong>Q46: What does the simulator do if the output prediction is different from the value in the state table?</strong></p>
<ul>
<li>If the output prediction is different from the value in the state table, the event is passed on to the evaluation routines. The signal value in the state table is updated.</li>
</ul>
<p><strong>Q47: Which interested memories are there in an event driven simulator as in Fig. 6.7?</strong></p>
<ul>
<li>There are 4 interested memories (Fig. 6.7), which are each an allocated area of the real machine memory. </li>
<li>Network memory, event memory, fan-out memory, state table</li>
</ul>
<p><strong>Q48: What is the form of addressing of the memories? What will be NM234 for the base of 10,000?</strong></p>
<ul>
<li>Addressing of the memories will be written in the form of base and offset.</li>
<li>To find an item of data, the offset is added to the base to give the real address. Thus, NM234 will be 10234.</li>
</ul>
<p><strong>Q49: What is the Boolean expression of Z with the primary inputs as in Fig. 6.14?</strong></p>
<ul>
<li>Z=A⊕B</li>
</ul>
<p><strong>Q50: According to Table 6.5, what data is stored in a network memory? You may give your explanation using G1 as an example.</strong></p>
<ul>
<li>第一行是器件的名称以及在输出信号在FM的地址，</li>
<li>第二行是器件输出信号的名称和信号值，之后是输入信号的名称和信号值</li>
<li>最后是器件的功能，或者工艺信息。</li>
<li>The 1st contains the base address of data relating to G1 in the fan-out memory.</li>
<li>The 2nd contains the output value and the next two contain the input values.</li>
<li>The last line contains the element type (or a pointer to the evaluation routine for this element)</li>
</ul>
<p><strong>Q51: Which information can you find in FOM for a signal? Give your explanation using signal C as an example in Table 6.6.</strong></p>
<ul>
<li>For G1, the output C is on line NM(1+1), and the two fan-in’s on lines NM(6+3) and NM(11+2)</li>
<li>of the network memory.</li>
</ul>
<p><strong>Q53: Is the delay of tpLH equivalent to that of tpHL for the elements of example circuit? What is the value for each of them,  respectively?</strong></p>
<ul>
<li>No. The tpLH is 9ns, while the tpHL is 5ns.</li>
</ul>
<p><strong>Q54: What is the fan-out index of signal A as known by the primary input controller?</strong></p>
<ul>
<li>The fan-out index of A is known by the primary input controller to be FOM1.</li>
</ul>
<p><strong>Q55: What is to do if the value from the state table different from the new value of A?</strong></p>
<ul>
<li>The state table value is updated.</li>
</ul>
<p><strong>Q56: Must an input change be sent to the event memory even if gate-output’s prediction is unchanged?</strong></p>
<ul>
<li>Yes.</li>
</ul>
<p><strong>Q57: What is indicated as the flag in FOM1 of the fan-out memory is 1? Which memory location is set to 0 with the output of G2 being  predicted to 0 at time 5?</strong></p>
<ul>
<li>The flag in FOM1 of the fan-out memory is 1, indicating that another gate input is driven by A.</li>
<li>The next free memory location in the event memory is at address EM1. The value in this location is set to 0, and the fan-out index to FOM8.</li>
</ul>
<p><strong>Q58: What does time do since the flag in line 2 of the fan-out memory is 0？Why？</strong></p>
<ul>
<li>Time now advances to find the next event., because there are no further fan-outs of signal A</li>
</ul>
<p><strong>Q59: What is the wheel pointer, at time 5? Which steps does simulator follow after find address EM1 of the event memory?</strong></p>
<ul>
<li>At time 5, the time wheel pointer is EM1.</li>
<li>Address EM1 of the event memory has a fan-out index of FOM8.Reading line FOM8 of the fan-out memory finds the state table line ST2. Considering state table for line ST2, it is found that the value is 1 prior to time 5. The value from the event memory is 0, so there is a change. The value in line ST2 of the state table is updated accordingly. The fan-out memory of line FOM8 points to line NM(6+1) in the network memory. This is the output of G2, so Dis also updated. As this is an output, an evaluation is not required. Line EM1 location is returned to the free list.</li>
</ul>
<p><strong>Q60: What should the simulator do if a line of the fan-out memory has its flag set?</strong></p>
<ul>
<li>Read a further line.</li>
</ul>
<p><strong>Q61: When does the evaluation at time 5 predict that Z will change from ‘0’to ‘1’?</strong></p>
<ul>
<li>The evaluation predicts that Z will change to 1 in tpLH, at time 5+9 = 14.</li>
</ul>
<p><strong>Q62: What operation was taken on the EM when the event at time 5 was read out?</strong></p>
<ul>
<li>Event memory location EM1 was recovered when the event at time 5 was read out, so this is the next available location.</li>
</ul>
<p><strong>Q63: Why is there no further activity as a result of the change of A at time 0 after the event at time 14 is processed?</strong></p>
<ul>
<li>There are no fan-outs of this signal and there are no more events in the time wheel, so there is no further activity as a result of this change of A.</li>
</ul>
<p><strong>Q64: What is the new change that the primary input controller applies at time 100?</strong></p>
<ul>
<li>This is B going to 1.</li>
</ul>
<p><strong>Q65: What problem does consideration of the potential changes from 114 illustrate? And, what is the solution?</strong></p>
<ul>
<li>The first indicates a change of E to 1. As D is still 0(data not yet read), a prediction that Z will change to 1 at time 123 is made.</li>
<li>However, on reading the D change, it is found that Z is predicted to go to 0 at time 119.</li>
<li><p>It is assumed that the event at time 123 is deleted after the second event is read on processing T =114.</p>
</li>
<li><p>There are two solution, both of which are required.</p>
</li>
<li>For this specific case, it is sufficient if it can be arranged to evaluate each element not more than once in each time slot. This is described further in Sec. 6.5.1(*some refinements).</li>
<li>The second solution is to remove the event at time 123. This in turn requires knowledge that the event has been placed, followed by a search of all event memory lists which might contain the false prediction.</li>
<li>However, the use of unequal rising and falling delays, as here, makes it necessary to have some such mechanism.</li>
</ul>
<p><strong>Q66: What is the longest delay through the circuit for the input (B)’s changing at time 100? And, what is that for A’s changing to 0  at 200 ns?</strong></p>
<ul>
<li>19ns; 23ns.</li>
</ul>
<p><strong>Q67: What is the aim of a timing verifier?</strong></p>
<ul>
<li>The aim of a timing verifier is to perform a full analysis of the circuit independent of the input patterns</li>
</ul>
<p><strong>Q68: What is the horizontal ordinate and vertical ordinate for the state table, respectively?</strong></p>
<ul>
<li>horizontal ordinate: address</li>
<li>vertical ordinate: T</li>
<li>横坐标是仿真的时间点，纵坐标是每一个信号的指针</li>
</ul>
<p><strong>Q69: What is the use of Free List of EM?</strong></p>
<ul>
<li>For prediction and recover. </li>
<li>free list用于存储事件寄存器中哪些空间可用，他可以让所有时轮中的事件列表共用一块内存。</li>
</ul>
<p><strong>Q70: Notice the short pulse on E. Does the ‘logic only’ LCC simulator predict this? Why is the difference?</strong></p>
<ul>
<li>No. 我们注意到e的一个短脉冲是由于c信号翻转的延时导致的，因此不考虑时延的LCC模型是不能对其进行描述的。</li>
</ul>
<p><strong>Q71: Which are examples of groups of signals?</strong></p>
<ul>
<li>Examples might include: memory address signals; data buses in a processor.</li>
</ul>
<p><strong>Q72: What benefits does treating such groups as a unit leads to?</strong></p>
<ul>
<li>Since the group is treated as a unit, it requires only one fan-out index.</li>
<li>As there is only one set of fan-out data per group, the storage requirements of the fan-out memory are also reduced.</li>
<li>As the group is a single unit, only one event has to pass around the simulator for each group.</li>
</ul>
<p><strong>Q73: How many fan-out index does it require since the group is treated as a unit? And, how about the number of events?</strong></p>
<ul>
<li>Since the group is treated as a unit, it requires only one fan-out index.</li>
</ul>
<p><strong>Q74: How many bits are defined in IEEE 754 standard for single-precision floating point number and double-precision number,  respectively?</strong></p>
<ul>
<li>32 bits for single-precision, 64 bits for double-precision number.</li>
</ul>
<p><strong>Q75: How does the simulator know a group and identify the size of its?</strong></p>
<ul>
<li>There is a bit to indicate that this is a group and some means of identifying the size of the group.</li>
</ul>
<p><strong>Q76: Where is a new routine named group split unit placed in Fig. 6.7? What does the group split unit do when it notices a new  prediction?</strong></p>
<ul>
<li>A new routine is placed in the simulator between the evaluator and the event memory (Fig. 6.7)</li>
<li>When the 32-bit register prediction reaches the group split unit, the unit notices that it is a group rather than a single signal. The group split unit now calls the splitting procedure for this group. For the example quoted two groups are formed.</li>
</ul>
<p><strong>Q77: How many groups are there in line FOM53 after group splitting?</strong></p>
<ul>
<li>3</li>
</ul>
<p><strong>Q78: What is the offset for the 8-bit subgroup, 2 single bits, and the 20-bit group, respectively, supposing that the combined group  starts at NM (1234 + 5) in the network memory? And, which locations does each of them occupy?</strong></p>
<ul>
<li>Each subgroup, including the single bits, will have address NM1234 in the fan-out memory. All the offsets are computed by the network compiler at compile time.</li>
</ul>
<p><strong>Q79: What are major times involved in simulation?</strong></p>
<ul>
<li>The major times involved in simulation are</li>
<li>calling and evaluating models,</li>
<li>extracting data from the time wheel, following fan-out linkages and forming the affected components list,</li>
<li>searching for erroneous data.</li>
</ul>
<p><strong>Q80: Which kinds of models do switch level simulators require?</strong></p>
<ul>
<li>Switch level simulators require different modelling approaches.</li>
</ul>
]]></content>
  </entry>
</search>
